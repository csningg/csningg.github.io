<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何使用C++的String流</title>
    <link href="/posts/2997844977/"/>
    <url>/posts/2997844977/</url>
    
    <content type="html"><![CDATA[<p>最近在打印<code>vector</code>中的向量时，自己用的是非常蹩脚的<code>string str</code>，遍历<code>vector</code>然后一个一个的相加，不够优雅。看到可以使用<code>stringstream</code>来实现这种功能，看着代码比较优雅，特地学习一下。</p><span id="more"></span><p><code>ostringstream</code>、<code>istringstream</code> 和 <code>stringstream</code> 是 C++ 中非常有用的字符串流类，它们分别用于<strong>输出</strong>、<strong>输入</strong>和<strong>同时输入输</strong>出字符串。通过使用这些类，我们可以更方便地处理字符串数据，以及实现数据类型和字符串之间的转换。在实际编程中，可以根据具体需求选择合适的字符串流类来简化代码的实现。</p><h1 id="ostringstream"><a href="#ostringstream" class="headerlink" title="ostringstream"></a><strong>ostringstream</strong></h1><p>ostringstream 是 C++ 中用于输出字符串的流类。它继承自 ostream，可以将各种数据类型输出到一个字符串中，方便地<span class="label label-primary">构造字符串</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ostringstream oss;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">42</span>;<br>    <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-comment">// 向 ostringstream 中输出数据</span><br>    oss &lt;&lt; <span class="hljs-string">&quot;The answer is: &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;, and the value of pi is: &quot;</span> &lt;&lt; pi;<br><br>    <span class="hljs-comment">// 获取 ostringstream 的内容（字符串）</span><br>    std::string result = oss.<span class="hljs-built_in">str</span>();<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// The answer is: 42, and the value of pi is: 3.14159</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a><strong>istringstream</strong></h1><p><code>istringstream</code> 是 C++ 中用于<strong>输入字符串</strong>的流类。它继承自 istream，可以将一个字符串解析成各种数据类型，方便地从字符串中读取数据。</p><ol><li><code>istringstream</code>必须在定义的时候就初始化，<code>std::istringstream iss(data)</code></li><li>每次读取后应检查状态（如 <code>fail()</code>、<code>eof()</code>）</li><li>可以随时用 <code>.str()</code> 方法重置字符串内容</li><li>如果流进入错误状态（如读取失败），必须用 <code>clear()</code> 重置状态才能继续使用</li><li><code>std::istringstream</code> 会拷贝初始字符串，内存开销较小，但频繁创建&#x2F;销毁可能影响性能。</li><li>可以通过<code>std::setprecision(5)</code>设置精度。具体用法<code>ss &lt;&lt; std::setprecision(5) &lt;&lt; num</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;John 25 3.14&quot;</span>;<br>    <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(data)</span></span>;<br><br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">double</span> pi;<br><br>    <span class="hljs-comment">// 从 istringstream 中读取数据</span><br>    iss &gt;&gt; name &gt;&gt; age &gt;&gt; pi;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value of pi: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a><strong>stringstream</strong></h1><p>stringstream 是 C++ 中同时支持输入和输出的字符串流类。它继承自 iostream，可以将各种数据类型输出到一个字符串中，也可以从一个字符串中读取数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">42</span>;<br>    <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-comment">// 向 stringstream 中输出数据</span><br>    ss &lt;&lt; <span class="hljs-string">&quot;The answer is: &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;, and the value of pi is: &quot;</span> &lt;&lt; pi;<br><br>    <span class="hljs-comment">// 获取 stringstream 的内容（字符串）</span><br>    std::string result = ss.<span class="hljs-built_in">str</span>();<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 清空 stringstream</span><br>    ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    ss.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-comment">// 从一个字符串中读取数据</span><br>    std::string data = <span class="hljs-string">&quot;John 25 3.14&quot;</span>;<br>    ss &lt;&lt; data;<br><br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">double</span> value;<br><br>    <span class="hljs-comment">// 从 stringstream 中读取数据</span><br>    ss &gt;&gt; name &gt;&gt; age &gt;&gt; value;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我为什么是个学渣？</title>
    <link href="/posts/100616916/"/>
    <url>/posts/100616916/</url>
    
    <content type="html"><![CDATA[<p>今天在<a href="https://www.bilibili.com/video/BV1tTJuzMErq?spm_id_from=333.788.videopod.sections&vd_source=e0aee50f101b406f0d1414f984f3f5c0">B站</a>上听到这个课程，醍醐灌顶，需要经常拿出来鞭策自己……</p><span id="more"></span><p>我为什么学习学不会，因为流程出现了问题。明确学习的过程分两个大阶段，<strong>输入</strong>和<strong>输出</strong>，少任何一个阶段任何一个环节都不可！</p><p>首先需要明确一点，学不明白，一定是这两个阶段出现的问题，不是智商不够，也不是天赋不够，也不是努力不够，先把这个流程走完了再谈其他。</p><p>要么输入有问题，要么输出偷懒，这两个部分没搞好，就不配说自己做出努力了！！！</p><p><img src="/../pictures/20250523/06/1.png" alt=" "></p><p>输入：</p><ol><li>品质与质量：要输入高阶的知识，学习顶尖的思想，学习顶尖的方法，不要怕学不明白，要在思路上认为自己是优秀的，才能把知识学明白。对于此项，我最大的问题是畏难！</li><li>输入速度：能一天学会的，觉不拖拉两天，能一周学会的，觉不拖拉一个月，能一个月学会的，绝不拖拉半年。对于此项，要克服拖延症！</li><li>学习必要的知识：这个一定是前人已经总结好的，只需要自己拿过来即可，不需要自己总结，不用自己专研，一定向高人学习。这个需要有自己的判断，那些是必要的，那些是非必要的！比如目前，机器学习对我来说就不是必要的知识！</li><li>完整程度：保证知识的完备性，比如学完三角函数，一定要懂三角函数的所有性质。这个要学习体系的课程，看体系的书，不能东一榔头，西一棒槌的学习。</li></ol><p>输出：</p><ol><li>精确程度：输出一定要精确，不能模糊，得过且过。丁是丁，卯是卯，尤其是写代码，不能有一点含糊。</li><li>完整：输出一定要具备所有，不要觉得事情简单就跳过，每次跳一点，最后就失之毫厘谬以千里。</li></ol><p>在当前信息爆炸的时代，对于输入的知识，高品质与质量比较好找到，国外课程，优秀的专家，比比皆是……，完整度也不必担心，只要注重品质与质量，就能找到完整度比较高的知识。我最大的问题在于输入的速度，以及输入必要的知识。太过于拖拉，一件事情能拖很久也完不成。</p><p>对于输出，我几乎没有正确的输出过，更谈不上精度和准确度。接下来，对于每个知识点的学习，我都应该精准和完整的输出。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB:如何用x查看内存?</title>
    <link href="/posts/3364006008/"/>
    <url>/posts/3364006008/</url>
    
    <content type="html"><![CDATA[<p>GDB是C++程序员常用的工具，很多时候需要查看内存情况，本文主要介绍x命令的使用</p><span id="more"></span><p>可以使用命令 <code>x</code>（“examine”的缩写）以多种格式检查内存，<strong>不受程序数据类型</strong>的限制。</p><p><strong>语法有以下3种：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x/nfu addr<br>x addr<br>x<br></code></pre></td></tr></table></figure><p>使用 <code>x</code> 命令检查内存，是本节的主题！</p><p><code>n</code>、<code>f</code> 和 <code>u</code> 是可选参数，用于指定<strong>显示多少内存</strong>以及<strong>如何格式化（其中fu可以换位置，无所谓）</strong>；</p><p><code>addr</code> 是一个表达式，表示开始显示内存的地址。如果使用 <code>nfu</code> 的默认值，可以省略斜杠 <code>/</code>。某些命令会为 <code>addr</code> 设置方便的默认值。</p><p><strong>参数说明：</strong></p><ol><li><p><strong><code>n</code>（重复计数）</strong></p><p> 重复计数是一个十进制整数，默认值为 1。它指定要显示多少内存（以单位 <code>u</code> 字节计算）。如果指定负数，则从 <code>addr</code> 开始向后检查内存。</p></li><li><p><strong><code>f</code>（显示格式）</strong></p><p> 显示格式是 <code>print</code> 命令使用的格式之一（如 <code>x</code>、<code>d</code>、<code>u</code>、<code>o</code>、<code>t</code>、<code>a</code>、<code>c</code>、<code>f</code>、<code>s</code>），还包括 <code>i</code>（机器指令）和 <code>m</code>（显示内存标签）。初始默认格式为 <code>x</code>（十六进制），每次使用 <code>x</code> 或 <code>print</code> 后默认格式会改变。经常使用的是<code>x</code>、<code>d</code>(十进制)、<code>u</code>(无符号数)</p></li><li><p><strong><code>u</code>（单位大小）</strong></p><p> 单位大小可以是以下之一：</p><ul><li><code>b</code>：字节。</li><li><code>h</code>：半字（两个字节）。</li><li><code>w</code>：字（四个字节）。这是初始默认值。</li><li><code>g</code>：大字（八个字节）。每次使用 <code>x</code> 指定单位大小后，该单位会成为下次使用 <code>x</code> 时的默认单位。对于 <code>i</code> 格式，单位大小会被忽略且通常不写。对于 <code>s</code> 格式，单位大小默认为 <code>b</code>，除非显式指定。例如：<ul><li><code>x/hs</code> 显示 16 位字符字符串。</li><li><code>x/ws</code> 显示 32 位字符串。下次使用 <code>x/s</code> 时会恢复显示 8 位字符串。注意，结果取决于当前编译单元的编程语言。例如，C 语言中 <code>s</code> 会使用 UTF-16 编码，而 <code>w</code> 会使用 UTF-32。编码由编程语言决定，不可更改。</li></ul></li></ul></li><li><p><strong><code>addr</code>（起始地址）</strong></p><p> <code>addr</code> 是 GDB 开始显示内存的地址。表达式不必是指针（但可以是），它始终被解释为字节内存的整数地址。默认地址通常是上次检查地址的下一个位置，但其他命令也会设置默认地址：</p><ul><li><code>info breakpoints</code>：设置为最后列出的断点地址。</li><li><code>info line</code>：设置为某行的起始地址。</li><li><code>print</code>：如果用它显示内存中的值。</li></ul></li></ol><p><strong>示例：</strong></p><ul><li><code>x/3uh 0x54320</code>：从地址 <code>0x54320</code> 开始，显示 3 个半字（<code>h</code>），格式为无符号十进制整数（<code>u</code>）。</li><li><code>x/4xw $sp</code>：以十六进制（<code>x</code>）显示栈指针（<code>$sp</code>）上方的 4 个字（<code>w</code>）。</li><li>指定负重复计数可反向检查内存。例如，<code>x/-3uh 0x54320</code> 会显示 <code>0x5431a</code>、<code>0x5431c</code> 和 <code>0x5431e</code> 处的 3 个半字。</li></ul><p><strong>顺序灵活性：</strong></p><p>单位大小字母和格式字母是独立的，顺序无关。例如 <code>4xw</code> 和 <code>4wx</code> 等效，但计数 <code>n</code> 必须在前（如 <code>wx4</code> 无效）。</p><p><strong>特殊格式说明：</strong></p><ul><li><code>i</code> 格式（机器指令）：即使忽略单位大小 <code>u</code>，仍可使用计数 <code>n</code>。例如 <code>3i</code> 显示 3 条指令（包括操作数）。为方便起见，<code>i</code> 还会显示分支延迟槽指令（如果有）。<code>disassemble</code> 是另一种检查指令的方式。</li><li><code>s</code> 或 <code>i</code> 格式的负计数：会从给定地址向前显示字符串或指令（数量为计数的绝对值）。对于 <code>i</code> 格式，使用调试信息中的行号准确定位指令边界；若无行信息，会报错停止。</li></ul><p><strong>默认行为：</strong></p><p><code>x</code> 的<strong>默认参数设计为便于连续扫描内存</strong>。例如：</p><ul><li>用 <code>x/3i addr</code> 检查 3 条指令后，可用 <code>x/7</code> 检查接下来的 7 条。</li><li>按 <code>RET</code> 重复 <code>x</code> 命令时，会复用上次的计数 <code>n</code>，其他参数按 <code>x</code> 的默认规则更新。 –&gt;</li></ul><p><strong>当前指令标记：</strong></p><p>检查机器指令时，当前程序计数器（PC）指向的指令会用 <code>=&gt;</code> 标记。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) x/<span class="hljs-number">5</span>i $pc<span class="hljs-number">-6</span><br>   <span class="hljs-number">0x804837f</span> &lt;main<span class="hljs-number">+11</span>&gt;: mov    %esp,%ebp<br>   <span class="hljs-number">0x8048381</span> &lt;main<span class="hljs-number">+13</span>&gt;: push   %ecx<br>   <span class="hljs-number">0x8048382</span> &lt;main<span class="hljs-number">+14</span>&gt;: sub    $<span class="hljs-number">0x4</span>,%esp<br>=&gt; <span class="hljs-number">0x8048385</span> &lt;main<span class="hljs-number">+17</span>&gt;: movl   $<span class="hljs-number">0x8048460</span>,(%esp)<br>   <span class="hljs-number">0x804838c</span> &lt;main<span class="hljs-number">+24</span>&gt;: call   <span class="hljs-number">0x80482d4</span> &lt;puts@plt&gt;<br></code></pre></td></tr></table></figure><p><strong>内存标签（<code>m</code> 格式）：</strong></p><p>若架构支持内存标签，可用 <code>m</code> 显示标签。标签按颗粒大小（一个标签覆盖的字节数）显示。例如 AArch64 的颗粒大小为 16 字节，因此每 16 字节显示一个标签。</p><p>由于 <code>x</code> 的输出不强制对齐边界，标签信息指向每行显示的初始地址。若一行中跨越标签边界，标签会在下一行显示。<code>m</code> 格式不影响其他指定的格式。</p><p><strong>历史记录：</strong></p><p><code>x</code> 命令输出的地址和内容不会保存在值历史中（因数据量可能过大）。但 GDB 会将其存入以下变量：</p><ul><li><code>$_</code>：最后检查的地址。</li><li><code>$__</code>：该地址的内容。若 <code>x</code> 有重复计数，保存的是最后打印的内存单元的地址和内容（可能与最后打印的地址不同）。</li></ul><p><strong>内存单元与字节：</strong></p><p>大多数目标的可寻址内存单元大小为 8 位（即一个字节）。但某些目标可能有其他大小。在 GDB 中：</p><ul><li>“可寻址内存单元”（或简称“内存单元”）指目标的数据块大小。</li><li>“字节”特指 8 位数据块（无论目标的内存单元大小如何）。多数系统中，两者是同义词。</li></ul><p><strong>比较内存与文件（<code>compare-sections</code>）：</strong></p><p>在远程调试或需要验证程序是否修改了只读段时，可用此命令：</p><p><code>compare-sections [section-name|-r]</code></p><ul><li>无参数：比较所有可加载段。</li><li><code>r</code>：比较所有只读可加载段。对于远程目标，若支持内存块 CRC 校验（<code>qCRC</code> 数据包），可加速比较。</li></ul><hr><p><strong>总结：</strong></p><p>GDB 的 <code>x</code> 命令用于灵活检查内存，支持多种格式（如十六进制、指令、字符串等）和单位大小（字节、字等）。关键特性包括：</p><ol><li><strong>参数组合</strong>：<code>nfu</code> 分别控制数量、格式和单位，顺序灵活。</li><li><strong>默认继承</strong>：上次使用的参数（如单位、格式）会成为下次默认值。</li><li><strong>反向检查</strong>：负计数可从地址向前扫描。</li><li><strong>指令标记</strong>：当前 PC 指令用 <code>=&gt;</code> 高亮。</li><li><strong>内存标签</strong>：支持显示架构相关的内存标签（如 AArch64）。</li><li><strong>变量缓存</strong>：<code>$_</code> 和 <code>$__</code> 分别存储最后检查的地址和内容。</li><li><strong>字节与内存单元</strong>：明确区分术语，兼容不同寻址大小的目标。</li><li><strong>段比较</strong>：<code>compare-sections</code> 可验证内存与文件的一致性，支持远程加速。</li></ol><p>此命令是调试内存相关问题（如数据损坏、指令流分析）的核心工具，通过灵活的参数适应多种场景。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc/free详解</title>
    <link href="/posts/3614768602/"/>
    <url>/posts/3614768602/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>内存管理-侯捷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::allocate解析</title>
    <link href="/posts/1398903302/"/>
    <url>/posts/1398903302/</url>
    
    <content type="html"><![CDATA[<p>本文是对STL中标准分配器原理的剖析，通过13张流程图详尽在使用分配器时遇到的各种情况，值得好好揣摩…</p><span id="more"></span><h1 id="不同编译器对标准分配器的实现"><a href="#不同编译器对标准分配器的实现" class="headerlink" title="不同编译器对标准分配器的实现"></a>不同编译器对标准分配器的实现</h1><p><img src="/../pictures/20250523/0601/image.png" alt=" "></p><p><img src="/../pictures/20250523/0601/image%201.png" alt=" "></p><p><img src="/../pictures/20250523/0601/image%202.png" alt=" "></p><ul><li>通过看源代码可得，以上两种分配器的<code>allocator</code>只是以<code>::operator new()</code>和<code>::operator delete()</code>完成<code>allocate()</code>和<code>deallocate()</code>。没有对内存进行管理，所以这两种编译器的分配效率并不高，因为直接使用<code>::operator new()</code>和<code>::operator delete()</code> 会产生大量的cookies。</li><li>v此处的分配是<strong>以指定的元素的类型为单位</strong>，比方说类型指定为 int，分配 512 就是 512 个 int</li><li>我们为什么要着重看容器的分配器呢？因为现在写代码大部分时间都是用容器，所以重视容器的效率</li></ul><h1 id="std-alloc概述"><a href="#std-alloc概述" class="headerlink" title="std::alloc概述"></a>std::alloc概述</h1><p><img src="/../pictures/20250523/0601/image%203.png" alt=" "></p><p><code>std::alloc</code>是STL中高效的内存分配器实现，分配器一定要提供两个重要的函数：<code>allocate()</code>（分配）和<code>deallocate()</code>（回收）</p><p><code>std::alloc</code>提供了16 条链表，超过这个链表最大管理的内存块大小范围（128 字节）的内存分配不再受 <code>std::alloc</code> 管理，而是通过 <code>malloc()</code> 进行分配，对于上图有如下解释：</p><ul><li>#0 串联 8 字节的内存块，#1 串联 16 字节的内存块，#2 串联 24 字节的内存块… 链表间的内存块相差 8 字节</li><li>如果容器中的每个元素需求的内存块的大小不是 8 的倍数，比如需要 6，则进入<code>std::alloc</code>这个系统后，会被调成 8；这个设计在所有的分配器上都一样，<code>malloc()</code> 也是这样的设计，一定会调整为设定好的边界</li><li>如果声明一个 vector，每个元素的大小都是 32 字节。#3 是管理 32 字节的内存块的，一开始 #3 是空的，它就会去挖（<code>malloc()</code>）一块 20 * 32 大小的内存以备使用（20 应该是开发 <code>std::alloc</code> 的人员的经验值）；当这 20 块 32 字节的内存使用完之后，又会再要 20* 32 字节大小的内存，以此类推</li><li>实际上挖的大小是 20* 32 字节，其中一半拿来切 32 字节的内存块，另一半空置等待使用</li><li>声明另一个 vector，每个元素的大小是 64 字节。需要 #7 链表来管理 64 字节的内存块，当 #7 链表需要的时候，将剩余的 20*32 切割成每个内存块 64 字节的大小，可以切出 10 个，可以看到它们 #3 和 #7 的内存块是相连的；至此，分配的内存都使用完了</li><li>再声明一个 vector，每个元素的大小是 96 字节。#11 是管理 96 字节内存块的，此时它是空的，而且之前 #3 多分出来的也都用光了，于是<code>malloc()</code> 20 * <em>6</em>2 字节内存，一半拿来用，一半备用</li><li>容器不再需要元素的时候，要归还内存，根据内存大小就回收到负责该大小的内存块的链表上</li><li>如果容器中的每个元素的大小为 256 字节，超出了链表的内存块的范围（8~128），于是调用 malloc 进行分配，将分配得到的空间传回给容器</li><li>容器每次动态分配得到的都是指针，它并不会知道分配到的内存是否带 cookie</li><li>最初分配的 20 * 2 的一大块是<code>malloc()</code>出来的，带 cookie，但<code>std::alloc</code>管理的内存块都是 cookie free 的</li></ul><p><img src="/../pictures/20250523/0601/image%204.png" alt=" "></p><ul><li>链表借用每个内存块的前4个字节做指针，当把内存块分给容器后，这4个字节会被容器的数据填充，容器归还内存块后，分配器会重新把前 4 个字节用作指针，接到链表上。这种做法称为 embedded pointer（嵌入式指针）</li><li>好的内存管理一定会使用嵌入式指针，否则 class 里还要多设计一个指针</li><li>源代码中的<code>char client_data[1];</code>并没有用到，可以删除，删掉后是 union 还是 struct 就没区别了</li><li>如果对象本身小于 4 个字节，就不能被借用作指针了。但是通常对象大小会大于等于 4 字节</li></ul><h1 id="GNU-allocator-行为剖析"><a href="#GNU-allocator-行为剖析" class="headerlink" title="GNU allocator 行为剖析"></a>GNU allocator 行为剖析</h1><p>接下来会对alloc的行为进行解释，总共有13个幻灯片，对于每个幻灯片，解释为与下方。</p><p><img src="/../pictures/20250523/0601/image%205.png" alt=" "></p><p>开始，定义了<code>free_list[16]</code></p><p><img src="/../pictures/20250523/0601/image%206.png" alt=" "></p><ul><li>容器首次申请32字节，此时链表为空，直接调用malloc申请 32 * 20 * 2 + RoundUp(0&gt;&gt;4) &#x3D; 1280个字节，从中切除1个返回用户，另外19个挂在list 3中，余下的640备用。</li><li>pool 指的就是之前说的多出来的备用空间，称它为战备池，由 start_free 和 end_free 两个指针围起来。只是蓝色的那个部分，注意区分。</li><li><code>RoundUp()</code>的作用是把数字上调到 8 的倍数，0&gt;&gt;4 指的是 0 右移 4 位，即 0 除以 16。RoundUp(0&gt;&gt;4) 结果是 0，这部分我们可以称为“追加量”</li><li>#3 是空的，先看 pool 有没有，发现也是空的，于是给 pool 申请 32 * 20 * 2 +RoundUp(0&gt;&gt;4) &#x3D;1280 的空间。640 给客户，另一半 640 备用（pool）</li><li>这一整块是用<code>malloc()</code>分配的，头尾都有 cookie</li></ul><p><img src="/../pictures/20250523/0601/image%207.png" alt=" "></p><ul><li>另一个容器申请 64 字节，因为 pool 有余量，所以从 pool 中切出 10 个，第一个给用户，剩余的9个挂在list 7。此时战备池已经为空了。注意7号链表的开始是从3号链表的末尾指上去的。</li><li>因为是同一块，所以没有产生额外cookie</li></ul><p><img src="/../pictures/20250523/0601/image%208.png" alt=" "></p><ul><li>又有一个容器申请 96 字节</li><li>pool 是空的，用<code>malloc()</code>分配 96 * 20 * 2+RoundUp(1280&gt;&gt;4)&#x3D; 3920，加上之前申请的1280，共5200。分出 20*96&#x3D;1920，pool 留下 2000，这一大块是带 cookie 的</li><li>这里可以看出追加量的计算方式，<code>RoundUp()</code> 里是累计申请量&gt;&gt;4，即累计申请量&#x2F;16，发现追加量会越来越大。为什么会有追加量，以及为何如此计算，源码的注释中并没有解释，不过这样的处理带来了安全阀门（后面讲解）</li></ul><p><img src="/../pictures/20250523/0601/image%209.png" alt=" "></p><ul><li>又有一个容器申请88字节，pool 中有余量，分出20个（哪怕 pool 还有更多，最多也只能分出 20）。此时会将11号链表的剩下的所有的都挂在10号链表下面。所以此时战备此也在10号链表下面了。</li><li>分配为88 * 10个空间后，战备词还剩240个字节。</li></ul><p><img src="/../pictures/20250523/0601/image%2010.png" alt=" "></p><ul><li>不再新建容器了，而是某个容器连续三次申请88</li><li>直接取出 3 个返回给容器，速度很快，不会影响原来战备池的大小。</li></ul><p><img src="/../pictures/20250523/0601/image%2011.png" alt=" "></p><ul><li>又有一个容器申请 8 字节，pool中有余量大小为240，分出 20 个。分出20个还剩余80个字节。</li><li>如果不同的容器（vector、list、deque……）大小相同，会共用同一条链表</li></ul><p><img src="/../pictures/20250523/0601/image%2012.png" alt=" "></p><ul><li>又有一个容器申请 104 字节</li><li>pool只有80，连 1 个都不够，这 80 便是内存碎片，需要先处理碎片</li><li>80归 #9 管理，所以处理方式就是把 80拨给 #9</li><li>然后<code>malloc()</code>分配 104<em>20</em>2+RoundUp(5200&gt;&gt;4)&#x3D;4488</li></ul><p><img src="/../pictures/20250523/0601/image%2013.png" alt=" "></p><ul><li>又有一个容器申请 112 字节，pool 中有余量，分出 20 个</li></ul><p><img src="/../pictures/20250523/0601/image%2014.png" alt=" "></p><ul><li>又有一个容器申请 48 字节，pool 中有余量，分出 3 个。</li></ul><p>以上步骤把所有可能的情况都列出来了，下面看一下内存耗尽的话会发生什么</p><p><img src="/../pictures/20250523/0601/image%2015.png" alt=" "></p><ul><li>为了测试，将系统内存大小设置为了 10000，而现在已经申请了 9688 了</li><li>又有一个容器申请 72 字节</li><li>pool 只有 24，是碎片，这 24 挂到 #2</li><li><code>malloc()</code>分配 72<em>20</em>2+RoundUp(9688&gt;&gt;4)，因为内存不足，<code>malloc()</code>失败</li><li>为了满足用户需求，从 #8 右侧找离 #8 最近的，发现 #9 有一个 80，于是从 80 中切出 72 给 #8，剩下 8 作为 pool，#9为空</li></ul><p><img src="/../pictures/20250523/0601/image%2016.png" alt=" "></p><ul><li>又有一个容器申请 72 字节</li><li>pool 只有 8，分给 #0</li><li>从 #10 中拿出一块，72 给 #8，剩下 16 作为 pool</li></ul><p><img src="/../pictures/20250523/0601/image%2017.png" alt=" "></p><ul><li>又有一个容器申请 120 字节</li><li>从 #14 右边找，发现右边的 #15 也是空的，山穷水尽，无法满足需求</li></ul><p><img src="/../pictures/20250523/0601/image%2018.png" alt=" "></p><ul><li>如果要把小块合并：因为都是链表，指来指去的，很难找到相邻的两块或几块合并，而且链表长度也不确定，虽然理论上可行，但难度极高，其他分配器也没有实现这样操作的</li><li>如果要把系统剩下的 312 用光：比较简单，<code>malloc()</code> 失败的话，就把<code>malloc()</code>内的数值减半，直到成功，但 GCC 并没有这么做，后面会给出答案</li></ul><h1 id="GNU-alloc源码分析"><a href="#GNU-alloc源码分析" class="headerlink" title="GNU alloc源码分析"></a>GNU alloc源码分析</h1><p><img src="/../pictures/20250523/0601/image%2019.png" alt=" "></p><p><img src="/../pictures/20250523/0601/image%2020.png" alt=" "></p><p><img src="/../pictures/20250523/0601/image%2021.png" alt=" "></p><ul><li>这是第一级分配器，前面讲的步骤都在第二级分配器中，如果第二级分配器分配失败就会来到第一级</li><li>第一级会模拟 new handler，不断循环给用户机会去分配</li><li>C++ 本来就有 new handler，没必要模拟，这里这么写可能是因为历史元素，GCC 4.9 就没有这个第一级分配，所以此处也跳过，不详细讲解</li><li>第一级分配器到 74 行截止。77~89 是换肤工程，第二级分配器的单位是字节，换肤工程可以把字节转换为元素的个数。</li></ul><p><img src="/../pictures/20250523/0601/image%2022.png" alt=" "></p><ul><li>第二级分配器从 90 行开始。为了教学，多线程的部分都被拿掉了。</li><li>三行 enum 其实就是常量定义，因为历史原因没有写成 static const</li><li><code>ROUND_UP()</code>会将传入参数上调为 8 的倍数</li><li>union obj 是嵌入式指针，free_list_link 其实就是我们平时常写的 next</li><li>所有的数据和函数都是静态的，可见非常容易改写为 C 语言</li><li><code>FREELIST_INDEX()</code> 计算出申请的内存块应该由第几号链表提供；</li><li><code>refill()</code> 就是当链表为空的时候，要进行充值（即申请一大块内存）；</li><li><code>chunk_alloc()</code> 申请一大块内存；</li></ul><p><img src="/../pictures/20250523/0601/image%2023.png" alt=" "></p><ul><li>最重要的<code>allocate()</code>和<code>deallocate()</code></li><li>my_free_list 是指针的指针，因为它指向 16 条链表的其中一个，而里面的元素又是个指向下面链表的指针</li><li>如果申请的内存的大小大于 128，就改用第一级分配器</li><li><code>my_free_list = free_list + FREELIST_INDEX(n);</code>表示定位到第几号链表</li><li>如果 result &#x3D;&#x3D; 0 ，即链表为空，则需要充值；</li><li>如果不为空，便<code>my_free_list = result-&gt;free_list_link;</code>将第一块内存块给到用户，并向下移动指针；</li><li><code>deallocate()</code>接收指针，并把它还回链表。如果 n&gt;128 也会改用第一级去回收</li><li>两个问题<ul><li><code>deallocate()</code>没有将内存还给操作系统（free），而是将申请到的内存全部掌握在自己手中，不算内存泄露，但是这种做法是有争议的</li><li><code>deallocate()</code>并没有检查传入指针是不是这个 alloc 给出去的，如果这个指针指的大小不是 8 的倍数，可能会有灾难性的后果</li></ul></li></ul><p><img src="/../pictures/20250523/0601/image%2024.png" alt=" "></p><p><img src="/../pictures/20250523/0601/image%2025.png" alt=" "></p><ul><li>通过图片更好地展示上面代码的作用</li></ul><p><img src="/../pictures/20250523/0601/image%2026.png" alt=" "></p><ul><li><code>chunk_alloc()</code>负责帮我们分配一大块区域</li><li>total_bytes 是 20 个的大小，bytes_left 是 pool 的大小</li><li>如果 pool 足够分出 20 个，就直接改 start_free 的位置，然后把 start_free 原先位置传回去</li><li>如果不够 20 个，但够 &gt;&#x3D; 1 个，看够几个，然后分配</li><li>如果连 1 个都不够，就是 0 或碎片了，对碎片做处理</li></ul><p><img src="/../pictures/20250523/0601/image%2027.png" alt=" "></p><ul><li>处理完碎片后 pool 为空，开始分配内存，让 start_free 和 end_free 指到对应位置，然后递归调用自己，因为 pool 大小足够了，所以肯定能满足要求，完成分配</li><li>如果<code>malloc()</code>失败，找右边的链表，拿出一块，放到 pool 中，然后再递归调用自己，完成分配</li><li>英文注释部分说明了为什么没有再申请更小的内存，后面 2.3.4 检讨部分会解释</li><li>G4.9 中 start_free 是通过 operator new 进行分配的，而非 malloc，所以可以重载 operator new 接管内存分配，这就是为什么我们在 2.4 节是用 4.9 版测试的</li></ul><p><img src="/../pictures/20250523/0601/image%2028.png" alt=" "></p><ul><li><code>refill()</code>函数</li><li>20 是个 magic number，不大好，最好是写成常量或宏</li><li>交给<code>chunk_alloc()</code>去拿一大块内存</li><li>如果只有一个，直接返回，否则就建立自由链表</li><li>注意 for 循环是从 1 开始的，因为第一个要给出去，没必要再切割、链接</li><li>所谓切割就是把指针所指处转为 obj*（嵌入式指针）</li></ul><p><img src="/../pictures/20250523/0601/image%2029.png" alt=" "></p><ul><li>因为数据是 static 的，所以需要在 class 外部定义</li></ul><h1 id="G4-9-pool-allocator-运行观察"><a href="#G4-9-pool-allocator-运行观察" class="headerlink" title="G4.9 pool allocator 运行观察"></a><strong>G4.9 pool allocator 运行观察</strong></h1><p><img src="/../pictures/20250523/0601/image%2030.png" alt=" "></p><ul><li>Foo(1) 是个临时对象，非动态分配的，存在于 stack，容器 c 的内存是通过 alloc 分配的，不带 cookie</li><li>new 底层是通过<code>malloc()</code>分配的，存在于 heap，分配的内存块带 cookie。<code>push_back()</code>到链表后也是不带 cookie 的。</li></ul><p><img src="/../pictures/20250523/0601/image%2031.png" alt=" "></p><ul><li>208、218、255 行是数值比较，一般的习惯则是把变量写左边，把要比较的值写右边，这里之所以反着写，是因为如果把变量写左边，哪怕 &#x3D;&#x3D; 写成 &#x3D; 也会通过编译，数值写左边的话编译器可以帮我们找出问题</li><li>197 行的变量一直到 207 行才用到，中间做了许多操作，这样不好，应该把变量写到 206 行。因为如果是指针的话，中间的操作可能会使指针失效，出了问题后难以排查</li><li>136 和 210 行不用管 volatile。<code>obj* *my_free_list, *p;</code> 的意思是<code>obj** my_free_list</code>和<code>obj* p</code>，所以它这种写法很容易搞错，建议分开写</li><li>34 行的内容等同于右边框里的两行，硬要把这两行写成一行，纯属炫技，可读性差</li><li>212、213、214 行说如果尝试申请小内存，会在多进程机器上造成大灾难，意思不是说这个程序会怎么样，而是如果把内存都占用光，机器上的其他程序会没有内存可用</li><li><code>deallocate()</code>没有调用<code>free()</code>或<code>delete()</code>，源于其设计上的先天缺陷：交给客户的内存块没有指针一直记录着其地址，所以归还的时候不知道地址，就无法回收。后面第四部分讲 Loki allocator 时会处理这个问题</li></ul><p><img src="/../pictures/20250523/0601/image%2032.png" alt=" "></p><ul><li>为了测试是否真的节省了 cookie，编写测试代码，通过重写 operator new&#x2F;delete 统计总分配量和总释放量</li><li>右边为什么 (1) (2) 可以并存老师也不知道</li></ul><p><img src="/../pictures/20250523/0601/image%2033.png" alt=" "></p><ul><li>右侧 lst 默认使用的是标准分配器，每个元素都带 cookie。double 占 8 字节，每个节点带两个指针，一个元素就是 16 字节，<code>push_back()</code>1000000 次，总共执行了 1000000 次<code>malloc()</code>，分配了 16000000 字节，这 1000000 次每次都带 cookie</li><li>左侧 lst 使用的分配器为 __pool_alloc，<code>push_back()</code>1000000 次，总共只执行了 122 次<code>malloc()</code>，分配了 16752832 字节，122 次每次都带 cookie，可见差距之大</li><li>不能观察到 malloc 真正分配出去的总量（含所有 overhead），因为 malloc 不能重载，除非你有很高的技巧，清楚地理解了 malloc 的行为模式，理解了它管理的每个区块其实是个链表，知道了链表的头，遍历一遍，就能得到内存块的大小。第三讲我们会为大家建立起这种能力</li></ul><h1 id="G2-9-std-alloc-移植至C"><a href="#G2-9-std-alloc-移植至C" class="headerlink" title="G2.9 std::alloc 移植至C"></a><strong>G2.9 std::alloc 移植至C</strong></h1><p><img src="/../pictures/20250523/0601/image%2034.png" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>内存管理-侯捷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存原语</title>
    <link href="/posts/572525303/"/>
    <url>/posts/572525303/</url>
    
    <content type="html"><![CDATA[<p>本文是对侯捷老师内存管理课程学习记录与总结，原课程见<a href="https://www.youtube.com/playlist?list=PLTcwR9j5y6W2eH37R2_4oEO4Y0tksot56">此处</a>,其中本文是对第一节的整理，第一节是关于内存原语~</p><span id="more"></span><h1 id="使用内存的方式有哪些？"><a href="#使用内存的方式有哪些？" class="headerlink" title="使用内存的方式有哪些？"></a>使用内存的方式有哪些？</h1><p>在日常的开发环境中，我们都是在应用层进行开发，其直接接触内存的方式有多种。如下图</p><p><img src="/../pictures/20250522/eda72137-4d4d-4349-9b25-987a8ef9aa16.png" alt="image.png"></p><ol><li>直接使用标准库，比如STL</li><li>使用C++提供的管理内存的方式，比如<code>new</code>，<code>delete</code>，<code>operator new()</code>,<code>operator delete()</code></li><li>使用C提供的内存管理方式，<code>malloc/free</code></li><li>直接使用OS的API(几乎没)，此种方式和操作会和操作系统及其绑定。</li></ol><h1 id="C-memory-primitives"><a href="#C-memory-primitives" class="headerlink" title="C++ memory primitives"></a>C++ memory primitives</h1><table><thead><tr><th>分配</th><th>释放</th><th>归属</th><th>是否可重载</th><th>单位</th></tr></thead><tbody><tr><td><code>malloc()</code></td><td><code>free()</code></td><td>C 函数</td><td>不可</td><td>byte</td></tr><tr><td><code>new</code></td><td><code>delete</code></td><td>C++ 表达式(expressions)</td><td>不可</td><td>object</td></tr><tr><td><code>::operator new()</code></td><td><code>::operator delete()</code></td><td>C++ 函数</td><td>可</td><td>byte</td></tr><tr><td><code>allocator&lt;T&gt;::allocate()</code></td><td><code>allocator&lt;T&gt;::deallocate()</code></td><td>C++ 标准库</td><td>可以自由设计并搭配容器</td><td>需要填入T，因此是object</td></tr></tbody></table><p>无论是什么方式，在CRT(<strong>C run-time library</strong>)时，基本都是执行的<code>malloc/free</code> ，对于不同的编译器，其allocate函数的接口也有所不同：</p><p><img src="/../pictures/20250522/image.png" alt="image.png"></p><p>对于GNU C，不同版本又有所不同：</p><p><img src="/../pictures/20250522/image%201.png" alt="image.png"></p><p>这张图中的<code>gnu_cxx::pool_alloc&lt; T &gt;().allocate()</code>对应于上张图中的<code>allocator&lt; T &gt;().allocate()</code>。</p><p>通过<code>malloc</code>和<code>new</code>分配内存、通过<code>free</code>和<code>delete</code>释放内存是十分常用的，通过<code>::operator new</code>操作内存比较少见，<code>allocator</code>分配器操作内存在STL源码中使用较多，对于不同的编译环境使用也有所不同。</p><h1 id="基本构件之一-new-delete-expression"><a href="#基本构件之一-new-delete-expression" class="headerlink" title="基本构件之一 new&#x2F;delete expression"></a><strong>基本构件之一 new&#x2F;delete expression</strong></h1><h2 id="1-内存申请"><a href="#1-内存申请" class="headerlink" title="1. 内存申请"></a>1. 内存申请</h2><p><img src="/../pictures/20250522/image%202.png" alt="image.png"></p><p>上面这张图揭示了new操作背后编译器做的事：</p><ul><li>1、通过<code>operator new()</code>操作分配一个目标类型的内存大小，这里是<code>Complex</code>的大小；</li><li>2、通过<code>static_cast</code>将得到的内存块强制转换为目标类型指针，这里是<code>Complex*</code></li><li>3、调用目标类型的构造方法，但是需要注意的是，直接通过<code>pc-&gt;Complex::Complex(1, 2)</code>这样的方法调用构造函数<strong>只有编译器可以做</strong>，用户这样做将产生错误。</li></ul><p>值得注意的是，<code>operator new()</code>操作的内部是调用了<code>malloc()</code>函数。</p><h2 id="2-内存释放"><a href="#2-内存释放" class="headerlink" title="2. 内存释放"></a>2. 内存释放</h2><p><img src="/../pictures/20250522/image%203.png" alt="image.png"></p><p>同样地，<code>delete</code>操作第一步也是调用了对象的析构函数，然后再通过operator delete()函数释放内存，本质上也是调用了<code>free</code>函数。</p><h2 id="3-编译器模拟调用构造函数和析构函数"><a href="#3-编译器模拟调用构造函数和析构函数" class="headerlink" title="3. 编译器模拟调用构造函数和析构函数"></a>3. 编译器模拟调用构造函数和析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">//#include &lt;memory&gt;              //std::allocator  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> jj02<br>&#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> id;<br><br>        <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>)      &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor. this=&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;ctor. this=&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;<br>        ~<span class="hljs-built_in">A</span>()             &#123; cout &lt;&lt; <span class="hljs-string">&quot;dtor. this=&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_call_ctor_directly</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\ntest_call_ctor_directly().......... \n&quot;</span>;<br><br>        string* pstr = <span class="hljs-keyword">new</span> string;<br>        cout &lt;&lt; <span class="hljs-string">&quot;str= &quot;</span> &lt;&lt; *pstr &lt;&lt; endl;<br>        <span class="hljs-comment">//! pstr-&gt;string::string(&quot;jjhou&quot;);  </span><br>        <span class="hljs-comment">//[Error] &#x27;class std::basic_string&lt;char&gt;&#x27; has no member named &#x27;string&#x27;</span><br>        <span class="hljs-comment">//! pstr-&gt;~string();    //crash -- 其語法語意都是正確的, crash 只因為上一行被 remark 起來嘛.  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;str= &quot;</span> &lt;&lt; *pstr &lt;&lt; endl;<br>            <span class="hljs-comment">//------------</span><br><br>        A* pA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">//ctor. this=000307A8 id=1</span><br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     <span class="hljs-comment">//1</span><br>        pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>);<br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;<br>        <span class="hljs-comment">//! pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3</span><br>        <span class="hljs-comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span><br><br>        A::<span class="hljs-built_in">A</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//! A::A(5);                    //in VC6 : ctor. this=0013FF60 id=5</span><br>        <span class="hljs-comment">//         dtor. this=0013FF60      </span><br>        <span class="hljs-comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span><br>        <span class="hljs-comment">//         [Note] for a function-style cast, remove the redundant &#x27;::A&#x27;</span><br><br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     <span class="hljs-comment">//in VC6 : 3</span><br>        <span class="hljs-comment">//in GCC : 1    </span><br><br>        <span class="hljs-keyword">delete</span> pA;                  <span class="hljs-comment">//dtor. this=000307A8 </span><br><br>        <span class="hljs-comment">//simulate new</span><br>        <span class="hljs-type">void</span>* p = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(A));<br>        cout &lt;&lt; <span class="hljs-string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">//p=000307A8</span><br>        pA = <span class="hljs-built_in">static_cast</span>&lt;A*&gt;(p);<br>        pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//! pA-&gt;A::A(2);                //in VC6 : ctor. this=000307A8 id=2</span><br>        <span class="hljs-comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly    </span><br><br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     <span class="hljs-comment">//in VC6 : 2</span><br>        <span class="hljs-comment">//in GCC : 0    </span><br><br>        <span class="hljs-comment">//simulate delete</span><br>        pA-&gt;~<span class="hljs-built_in">A</span>();                   <span class="hljs-comment">//dtor. this=000307A8 </span><br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pA)</span></span>;      <span class="hljs-comment">//free()</span><br>    &#125;<br>&#125; <span class="hljs-comment">//namespace</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    jj02::<span class="hljs-built_in">test_call_ctor_directly</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">215.1</span>.cpp: In function ‘<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jj02::test_call_ctor_directly</span><span class="hljs-params">()</span>’:</span><br><span class="hljs-function"><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">33</span>:<span class="hljs-number">16</span>: error: cannot call constructor ‘jj02::A::A’ directly</span><br><span class="hljs-function">   <span class="hljs-number">33</span> |         pA-&gt;A::A(<span class="hljs-number">3</span>);</span><br>      |                ^<br><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">38</span>:<span class="hljs-number">13</span>: error: cannot call constructor ‘jj02::A::A’ directly [-fpermissive]<br>   <span class="hljs-number">38</span> |         A::<span class="hljs-built_in">A</span>(<span class="hljs-number">5</span>);<br>      |         ~~~~^~~<br><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">38</span>:<span class="hljs-number">13</span>: note: <span class="hljs-keyword">for</span> a function-style cast, remove the redundant ‘::A’<br><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">53</span>:<span class="hljs-number">16</span>: error: cannot call constructor ‘jj02::A::A’ directly<br>   <span class="hljs-number">53</span> |         pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">// 将所有直接调用构造函数的注释掉，在GNU中得到如下</span><br> <span class="hljs-built_in">test_call_ctor_directly</span>().......... <br>str= <br>str= <br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae32b62f0</span> id=<span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae32b62f0</span> id=<span class="hljs-number">1</span> <span class="hljs-comment">// 调用delete</span><br>p=<span class="hljs-number">0xaaaae32b62f0</span> <span class="hljs-comment">// 调用::operator new()</span><br><span class="hljs-number">-1431424330</span> <span class="hljs-comment">// 由于无法模拟调用构造函数，因此是未知数据</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae32b62f0</span> id=<span class="hljs-number">-1431424330</span> <span class="hljs-comment">// 调用析构函数</span><br></code></pre></td></tr></table></figure><p>代码是直接复制的侯捷老师的代码，执行结果如上所示。VS下可以直接通过内存空间调用构造函数，但GNU C下无法通过，具体的内容可见代码注解和打印效果。</p><h1 id="基础构件之二-Array-new-delete"><a href="#基础构件之二-Array-new-delete" class="headerlink" title="基础构件之二 Array new&#x2F;delete"></a>基础构件之二 Array new&#x2F;delete</h1><p><img src="/../pictures/20250522/image%204.png" alt="image.png"></p><p>上图主要展示的是关于<code>new array</code>内存分配的大致情况。当<code>new</code>一个<strong>数组对象</strong>时（例如 <code>new Complex[3]</code>），编译器将分配一块内存，这块内存首部是关于对象内存分配的一些标记，然后下面会分配三个连续的对象内存，在使用<code>delete</code>释放内存时需要使用<code>delete[]</code>。如果不使用<code>delete[]</code>，只是使用<code>delete</code>会根据这块内存的cookies，只会将分配的三块内存空间释放，但不会调用对象的析构函数，如果对象内部还使用了<code>new</code>指向其他空间，如果指向的该空间里的对象的析构函数没有意义（没有申请新的内存），那么不会造成问题，如果有意义（申请了新的内存），那么由于该部分对象析构函数不会调用，那么将会导致内存泄漏。图中<code>new string[3]</code>便是一个例子，虽然<code>str[0]</code>、<code>str[1]</code>、<code>str[2]</code>被析构了，但只是调用了<code>str[0]</code>的析构函数，其他对象的析构函数不被调用，这里就会出问题。</p><p>接下来对上述进行代码验证！！！</p><p><img src="/../pictures/20250522/image%205.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> id;<br>  <br>  <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>)      &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl;  &#125;<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl;  &#125;<br>  ~<span class="hljs-built_in">A</span>()             &#123; cout &lt;&lt; <span class="hljs-string">&quot;dtor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl;  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br><span class="hljs-comment">//case 1</span><br><span class="hljs-comment">//模拟 memory pool 的作法, array new + placement new. 崩潰 </span><br> <br>    A* buf = (A*)(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(A)*size]); <span class="hljs-comment">// 注意这里是new的char</span><br>    A* tmp = buf;   <br>       <br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        <span class="hljs-keyword">new</span> (tmp++) <span class="hljs-built_in">A</span>(i);  <span class="hljs-comment">//3次 ctor </span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>            <br>    <span class="hljs-comment">//!delete [] buf;    //crash. why?</span><br>                        <span class="hljs-comment">//因为new的是一个 char array，编译器看到 delete [] buf; 编译器企图调用多次 A::~A. </span><br>                        <span class="hljs-comment">// 但 array memory layout 中找不到与 array 元素个数 (本例 3) 相关的信息, </span><br>                        <span class="hljs-comment">// -- 整个内存布局都乱掉，於是崩潰。 </span><br>    <span class="hljs-keyword">delete</span> buf;     <span class="hljs-comment">//dtor just one time, ~[0]</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 调用delete buf</span><br><span class="hljs-built_in">test_placement_new</span>()..........<br>buf=<span class="hljs-number">0xaaaae6feb2c0</span>  tmp=<span class="hljs-number">0xaaaae6feb2c0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c0</span> id=<span class="hljs-number">0</span> <span class="hljs-comment">// 相差4个字节是因为类A的大小是4个字节</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c4</span> id=<span class="hljs-number">1</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c8</span> id=<span class="hljs-number">2</span><br>buf=<span class="hljs-number">0xaaaae6feb2c0</span>  tmp=<span class="hljs-number">0xaaaae6feb2cc</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c0</span> id=<span class="hljs-number">0</span> <span class="hljs-comment">// 只调用了第一个元素的构造函数</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 调用delete [] buf</span><br><span class="hljs-built_in">test_placement_new</span>()..........<br>buf=<span class="hljs-number">0xaaaace26f2c0</span>  tmp=<span class="hljs-number">0xaaaace26f2c0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c0</span> id=<span class="hljs-number">0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c4</span> id=<span class="hljs-number">1</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c8</span> id=<span class="hljs-number">2</span><br>buf=<span class="hljs-number">0xaaaace26f2c0</span>  tmp=<span class="hljs-number">0xaaaace26f2cc</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f340</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f33c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f338</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f334</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f330</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f32c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f328</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f324</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f320</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f31c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f318</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f314</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f310</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f30c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f308</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f304</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f300</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2fc</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2f8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2f4</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2f0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2ec</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2e8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2e4</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2e0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2dc</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2d8</span> id=<span class="hljs-number">60721</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2d4</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2d0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2cc</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c8</span> id=<span class="hljs-number">2</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c4</span> id=<span class="hljs-number">1</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c0</span> id=<span class="hljs-number">0</span><br><span class="hljs-built_in">free</span>(): invalid pointer<br>[<span class="hljs-number">1</span>]    <span class="hljs-number">1773946</span> <span class="hljs-built_in">abort</span> (core dumped)  ./a<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br><span class="hljs-comment">//case 2</span><br><span class="hljs-comment">// test array new</span><br>    A* buf = <span class="hljs-keyword">new</span> A[size];  <span class="hljs-comment">//default ctor 3 次. [0]先于[1]先于[2])</span><br>             <span class="hljs-comment">//A有 default ctor, 否则 [Error] no matching function for call to &#x27;jj02::A::A()&#x27;</span><br>    A* tmp = buf;   <br>       <br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        <span class="hljs-keyword">new</span> (tmp++) <span class="hljs-built_in">A</span>(i);  <span class="hljs-comment">//3次 ctor </span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>            <br>    <span class="hljs-keyword">delete</span> [] buf;    <span class="hljs-comment">//dtor three times (次序逆反, [2]先于[1]先于[0])</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_placement_new</span>()..........<br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442c8</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442cc</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442d0</span> id=<span class="hljs-number">0</span><br>buf=<span class="hljs-number">0xaaaaee7442c8</span>  tmp=<span class="hljs-number">0xaaaaee7442c8</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442c8</span> id=<span class="hljs-number">0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442cc</span> id=<span class="hljs-number">1</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442d0</span> id=<span class="hljs-number">2</span><br>buf=<span class="hljs-number">0xaaaaee7442c8</span>  tmp=<span class="hljs-number">0xaaaaee7442d4</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442d0</span> id=<span class="hljs-number">2</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442cc</span> id=<span class="hljs-number">1</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442c8</span> id=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>构造函数调用顺序是按照构建对象顺序来执行的，但是析构函数执行却相反。值得注意的是，在调用了<code>delete</code>的case1的代码段中，数组有三个元素，但最后只调用了第一个对象的析构函数。</p><p>接下来将更具体地展示new array对象的内存分配情况：</p><p><img src="/../pictures/20250522/image%206.png" alt="image.png"></p><p>如果使用<code>new</code>分配十个内存的<code>int</code>，内存空间如上图所示，首先内存块会有一个头和尾，黄色部分为debug信息，灰色部分才是真正使用到的内存，蓝色部分的12 bytes是为了让该内存块以16字节对齐。在这个例子中<code>delete pi</code>和<code>delete[] pi</code>效果是一样的，因为<code>int</code>没有析构函数。但是下面的例子就不一样了：</p><p><img src="/../pictures/20250522/image%207.png" alt="image.png"></p><p>上图通过<code>new</code>申请三个<code>Demo</code>空间大小，内存块使用了96 byte，这里是这样计算得到的：黄色部分调试信息32 + 4 &#x3D; 36 byte；黄色部分下面的“3”用于标记实际分配给对象内存个数，这里是三个所以里面内容为3，消耗4 byte；<code>Demo</code>内有三个<code>int</code>类型成员变量，一个<code>Demo</code>消耗内存3 * 4 &#x3D; 12 byte，由于有三个<code>Demo</code>，所以消耗了12 * 3 &#x3D; 36 <code>byte</code>空间；到目前为止消耗36 + 4 + 36 &#x3D; 76 byte，加上头尾<code>cookie</code>一共8 <code>byte</code>一共消耗84 <code>byte</code>，由于需要16位对齐，所以填充蓝色部分为12 byte，一共消耗了84 + 12 &#x3D; 96 <code>byte</code>。这里释放内存时需要加上<code>delete[]</code>，上面分配内存中有个标记“3”，所以编译器将释放三个Demo对象空间，如果不加就会报错。</p><p>因为在内存的布局中了多了个3，是因为构造函数是<code>no-trivial</code>的。整个内存布局就不同了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-type">int</span> x, y, z; <span class="hljs-comment">// 假设有三个int成员变量</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Demo</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// ~Demo() &#123;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; &quot;Destructor called&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Demo* p = <span class="hljs-keyword">new</span> Demo[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br>Constructor called<br>Constructor called<br>Constructor called<br></code></pre></td></tr></table></figure><p>假如析构函数是<code>no-trivial</code>，即把注释去掉，就必须调用<code>delete []</code>，否则会出现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a.cpp: In function ‘<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>’:</span><br><span class="hljs-function">a.cpp:<span class="hljs-number">88</span>:<span class="hljs-number">12</span>: warning: ‘void operator delete(void*, std::size_t)’ called on pointer ‘&lt;unknown&gt;’ with nonzero offset <span class="hljs-number">8</span> [-Wfree-nonheap-object]</span><br><span class="hljs-function">   <span class="hljs-number">88</span> |     delete p;</span><br>      |            ^<br>a.cpp:<span class="hljs-number">87</span>:<span class="hljs-number">25</span>: note: returned from ‘<span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> [](std::<span class="hljs-type">size_t</span>)’<br>   <span class="hljs-number">87</span> |     Demo* p = <span class="hljs-keyword">new</span> Demo[<span class="hljs-number">3</span>];<br><br><span class="hljs-function">Constructor called</span><br><span class="hljs-function">Constructor called</span><br><span class="hljs-function">Constructor called</span><br><span class="hljs-function">Destructor called</span><br><span class="hljs-function"><span class="hljs-title">munmap_chunk</span><span class="hljs-params">()</span>: invalid pointer</span><br><span class="hljs-function">[<span class="hljs-number">1</span>]    <span class="hljs-number">1779694</span> abort (core dumped)  ./a</span><br></code></pre></td></tr></table></figure><h1 id="基础构件之三-placement-new-delete"><a href="#基础构件之三-placement-new-delete" class="headerlink" title="基础构件之三 placement new&#x2F;delete"></a>基础构件之三 placement new&#x2F;delete</h1><p><img src="/../pictures/20250522/image%208.png" alt="image.png"></p><h1 id="基本构件之分配流程"><a href="#基本构件之分配流程" class="headerlink" title="基本构件之分配流程"></a>基本构件之分配流程</h1><p><img src="/../pictures/20250522/image%209.png" alt="image.png"></p><p>在应用程序调用<code>new</code>和<code>delete</code>之后，编译器会调用<code>operator new/delete</code>，在正常的情况下，是调用全局的<code>operator new/delete</code>，走第二条路线，但是如果类中有重载<code>operator new/delete</code>时，会走第一条路线。注意<code>new expression</code>（即第一层<code>new</code>）是不可改变不可重载的。正式因为可以重做类中的<code>operator new/delete</code>，程序员才有机会将内存管理接管过来，做更细致和高效的内存管理。</p><aside>💡 我们的目标是把第二条线路接管过来，走第一条线路。如此，我们就可以做类的内存管理了</aside><p><img src="/../pictures/20250522/image%2010.png" alt="image.png"></p><p>对于GNU C，背后使用的<code>allocate()</code>函数最后也是调用了系统的<code>::operator new()</code>函数。</p><h1 id="基本构件之重载"><a href="#基本构件之重载" class="headerlink" title="基本构件之重载"></a>基本构件之重载</h1><p><img src="/../pictures/20250522/image%2011.png" alt="image.png"></p><p>上面这张图演示了如何重载系统的<code>::operator new()</code>函数，该方法最后也是模拟了系统的做法，效果和系统的方法一样，但一般不推荐重载<code>::operator new()</code>函数，因为它对全局有影响，如果使用不当将造成很大的问题。</p><p>如果是在类中重载<code>operator new()</code>方法，那么该方法有N多种形式，但必须保证函数参数列表第一个参数是<code>size_t</code>类型变量；对于<code>operator delete()</code>，第一个参数必须是<code>void*</code> 类型，第二个<code>size_t</code>是可选项，可以去掉。</p><p><img src="/../pictures/20250522/image%2012.png" alt="image.png"></p><p>对于<code>operator new[]</code>和<code>operator delete[]</code>函数的重载，和前面类似。</p><p><img src="/../pictures/20250522/image%2013.png" alt="image.png"></p><p><img src="/../pictures/20250522/image%2014.png" alt="image.png"></p><p><img src="/../pictures/20250522/image%2015.png" alt="image.png"></p><p><img src="/../pictures/20250522/image%2016.png" alt="image.png"></p><p>代码如下，在下面代码中，尽管重载了operator new，operator delete等。但是在底层还是用的malloc和free，只是加了些打印的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> _id; <span class="hljs-comment">// 4 bytes</span><br>  <span class="hljs-type">long</span> _data; <span class="hljs-comment">// 8 bytes</span><br>  string _str; <span class="hljs-comment">// 32 bytes</span><br>  <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* deadObject, <span class="hljs-type">size_t</span> size)</span></span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size);<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* deadObject, <span class="hljs-type">size_t</span> size);    <br>  <br>  <span class="hljs-built_in">Foo</span>() : _id(<span class="hljs-number">0</span>)      &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; endl;  &#125;<br>  <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> i) : _id(i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; endl;  &#125;<br>  <span class="hljs-comment">//virtual </span><br>  ~<span class="hljs-built_in">Foo</span>()              &#123; cout &lt;&lt; <span class="hljs-string">&quot;dtor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; endl;  &#125;<br>  <br>  <span class="hljs-comment">//不加 virtual dtor, sizeof = 48, new Foo[5] =&gt; operator new[]() 的 size 参数是 64, </span><br>  <span class="hljs-comment">//加了 virtual dtor, sizeof = 56, new Foo[5] =&gt; operator new[]() 的 size 参数是 84, </span><br>  <span class="hljs-comment">//上述二例，多出來的 4 可能就是個 size_t 欄位用來放置 array size. </span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span>* Foo::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    Foo* p = (Foo*)<span class="hljs-built_in">malloc</span>(size);  <br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator new(), size=&quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot;\t  return: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> Foo::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator delete(), pdead= &quot;</span> &lt;&lt; pdead &lt;&lt; <span class="hljs-string">&quot;  size= &quot;</span> &lt;&lt; size &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(pdead);<br>&#125;<br><br><span class="hljs-type">void</span>* Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size)<br>&#123;<br>    Foo* p = (Foo*)<span class="hljs-built_in">malloc</span>(size);  <span class="hljs-comment">//crash, 問題可能出在這兒 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator new[](), size=&quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot;\t  return: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <br>    <br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator delete[](), pdead= &quot;</span> &lt;&lt; pdead &lt;&lt; <span class="hljs-string">&quot;  size= &quot;</span> &lt;&lt; size &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">free</span>(pdead);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 测试语句</span><br>&#123;<br>Foo* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">7</span>);<br><span class="hljs-keyword">delete</span> p;<br><br>Foo* pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];<span class="hljs-comment">//無法給 array elements 以 initializer</span><br><span class="hljs-keyword">delete</span> [] pArray;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_overload_operator_new_and_array_new</span>()..........<br><span class="hljs-built_in">sizeof</span>(Foo)= <span class="hljs-number">56</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(), size=<span class="hljs-number">56</span>  <span class="hljs-keyword">return</span>: <span class="hljs-number">0xaaaaf47622c0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47622c0</span> id=<span class="hljs-number">7</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47622c0</span> id=<span class="hljs-number">7</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(), pdead= <span class="hljs-number">0xaaaaf47622c0</span>  size= <span class="hljs-number">56</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](), size=<span class="hljs-number">288</span>  <span class="hljs-keyword">return</span>: <span class="hljs-number">0xaaaaf4762300</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762308</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762340</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762378</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623b0</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623e8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623e8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623b0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762378</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762340</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762308</span> id=<span class="hljs-number">0</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](), pdead= <span class="hljs-number">0xaaaaf4762300</span>  size= <span class="hljs-number">288</span><br></code></pre></td></tr></table></figure><p>分析：当执行<code>Foo* p = new Foo(7);</code>时，编译器会调用类重载的<code>void* Foo::operator new(size_t size)</code>函数，其中参数<code>size_t</code>会自动识别为类的大小56，然后调用类的构造函数，传入的参数为7，而后执行delete p;时，会先调用类的析构函数，然后执行调用类重载的<code>void Foo::operator delete(void* pdead, size_t size)，</code>参数为自动传入的，大小也为类的大小56</p><p>当执行<code>Foo* pArray = new Foo[5];</code>，编辑器会自动调用<code>void* Foo::operator new[](size_t size)</code>，然后传入的<code>size_t</code>是288，这个参数也是自动传入的。然后调用5次类的构造函数。执行<code>void Foo::operator delete[](void* pdead, size_t size)</code>，按逆序自动调用类的析构函数后，然后调用类重载的<code>void Foo::operator delete[](void* pdead, size_t size)</code>，参数也是自动传入的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>&#123;    <br>cout &lt;&lt; <span class="hljs-string">&quot;testing global expression ::new and ::new[] \n&quot;</span>;<br><span class="hljs-comment">// 這會繞過 overloaded new(), delete(), new[](), delete[]() </span><br><span class="hljs-comment">// 但當然 ctor, dtor 都會被正常呼叫.  </span><br><br>Foo* p = ::<span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">7</span>);<br>::<span class="hljs-keyword">delete</span> p;<br><br>Foo* pArray = ::<span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];<br>::<span class="hljs-keyword">delete</span> [] pArray;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_overload_operator_new_and_array_new</span>()..........<br><span class="hljs-built_in">sizeof</span>(Foo)= <span class="hljs-number">48</span><br>testing global expression ::<span class="hljs-keyword">new</span> <span class="hljs-keyword">and</span> ::<span class="hljs-keyword">new</span>[]<br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d092c0</span> id=<span class="hljs-number">7</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d092c0</span> id=<span class="hljs-number">7</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09308</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09338</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09368</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09398</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d093c8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d093c8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09398</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09368</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09338</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09308</span> id=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当使用全局的<code>new</code>和<code>delete</code>时，会跳过重载的函数。</p><p><img src="/../pictures/20250522/image%2017.png" alt="image.png"></p><ol><li>**重载 <code>operator new()</code>**：<ul><li>可以为类定义多个版本的 <code>operator new()</code>。</li><li>每个版本必须有独特的参数列表，其中第一个参数必须是 <code>size_t</code>，因为<code>Foo</code>的大小会被传入函数里面，所以第一个必须为<code>size_t</code>于接受类型的大小。</li><li>额外参数称为 placement arguments，可以在 <code>new</code> 表达式中传递。</li><li>示例：<code>Foo* pf = new (300, &#39;c&#39;) Foo;</code> 使用了 placement new。</li></ul></li><li>**重载 <code>operator delete()</code>**：<ul><li>也可以为类定义多个版本的 <code>operator delete()</code>。</li><li>这些版本不会被常规的 <code>delete</code> 调用。</li><li>只有当 <code>new</code> 所调用的构造函数抛出异常时，才会调用这些重载的 <code>operator delete()</code>。原因是在C++中，如果<code>new</code>完数据后，构造函数构造失败，需要能够<code>delete</code>掉内存。主要用于处理未能成功构造对象时释放内存。</li></ul></li></ol><p>示例：</p><p><img src="/../pictures/20250522/image%2018.png" alt="image.png"></p><p><img src="/../pictures/20250522/image%2019.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> jj07<br>&#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bad</span> &#123; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Foo::Foo()&quot;</span> &lt;&lt; endl;  &#125;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>) &#123; <br>                cout &lt;&lt; <span class="hljs-string">&quot;Foo::Foo(int)&quot;</span> &lt;&lt; endl;  <br>                <span class="hljs-comment">// throw Bad();  </span><br>             &#125;<br><br>    <span class="hljs-comment">//(1) 这个就是一般的 operator new() 的重载</span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size), size= &quot;</span> &lt;&lt; size &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);  <br>    &#125;<br><br>    <span class="hljs-comment">//(2) 这个就是标准库已经提供的 placement new() 的重载 (形式)</span><br>    <span class="hljs-comment">//    (所以我也模拟 standard placement new 的动作, just return ptr) </span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* start)</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size, void* start), size= &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot;  start= &quot;</span> &lt;&lt; start &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br><br>    <span class="hljs-comment">//(3) 这个才是崭新的 placement new </span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra)</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size, long extra)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size+extra);<br>    &#125;<br><br>    <span class="hljs-comment">//(4) 這又是一个 placement new </span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra, <span class="hljs-type">char</span> init)</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size, long extra, char init)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; init &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size+extra);<br>    &#125;<br>    <br>    <span class="hljs-comment">//(5) 這又是一個 placement new, 但故意寫錯第一參數的 type (它必須是 size_t 以滿足正常的 operator new) </span><br><span class="hljs-comment">//!  void* operator new(long extra, char init) &#123; //[Error] &#x27;operator new&#x27; takes type &#x27;size_t&#x27; (&#x27;unsigned int&#x27;) as first parameter [-fpermissive]</span><br><span class="hljs-comment">//!  cout &lt;&lt; &quot;op-new(long,char)&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//!    return malloc(extra);</span><br><span class="hljs-comment">//!  &#125; </span><br><br>    <span class="hljs-comment">//以下是搭配上述 placement new 的各個 called placement delete. </span><br>    <span class="hljs-comment">//當 ctor 發出異常，這兒對應的 operator (placement) delete 就會被喚起. </span><br>    <span class="hljs-comment">//應該是要負責釋放其搭檔兄弟 (placement new) 分配所得的 memory.  </span><br>    <span class="hljs-comment">//(1) 這個就是一般的 operator delete() 的重载 </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">size_t</span>)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,size_t)  &quot;</span> &lt;&lt; endl;  &#125;<br><br>    <span class="hljs-comment">//(2) 这是对上述的 (2)  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">void</span>*)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,void*)  &quot;</span> &lt;&lt; endl;  &#125;<br><br>    <span class="hljs-comment">//(3) 这是对上述的 (3)  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">long</span>)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,long)  &quot;</span> &lt;&lt; endl;  &#125;<br><br>    <span class="hljs-comment">//(4) 這是对上述的 (4)  </span><br>    <span class="hljs-comment">//如果沒有一一对应, 也不會有任何编译报错</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">long</span>,<span class="hljs-type">char</span>)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,long,char)  &quot;</span> &lt;&lt; endl; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_i;<br>&#125;;<br><br><span class="hljs-comment">//-------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_overload_placement_new</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n\n\ntest_overload_placement_new().......... \n&quot;</span>;<br>    <br>    Foo start;  <span class="hljs-comment">//Foo::Foo</span><br><br>    Foo* p1 = <span class="hljs-keyword">new</span> Foo;           <span class="hljs-comment">//op-new(size_t)</span><br>    Foo* p2 = <span class="hljs-built_in">new</span> (&amp;start) Foo;  <span class="hljs-comment">//op-new(size_t,void*)</span><br>    Foo* p3 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>) Foo;     <span class="hljs-comment">//op-new(size_t,long)</span><br>    Foo* p4 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;a&#x27;</span>) Foo; <span class="hljs-comment">//op-new(size_t,long,char)</span><br><br>    Foo* p5 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>) <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);     <span class="hljs-comment">//op-new(size_t,long)  op-del(void*,long)</span><br>    Foo* p6 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//</span><br>    Foo* p7 = <span class="hljs-built_in">new</span> (&amp;start) <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//</span><br>    Foo* p8 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//VC6 warning C4291: &#x27;void *__cdecl Foo::operator new(unsigned int)&#x27;</span><br>    <span class="hljs-comment">//no matching operator delete found; memory will not be freed if</span><br>    <span class="hljs-comment">//initialization throws an exception</span><br>&#125;<br>&#125; <span class="hljs-comment">//namespace</span><br><span class="hljs-comment">//----------------------------------------------------</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    jj07::<span class="hljs-built_in">test_overload_placement_new</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_overload_placement_new</span>()..........<br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>, size</span>= <span class="hljs-number">4</span><br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* start)</span>, size</span>= <span class="hljs-number">4</span>  start= <span class="hljs-number">0xffffcd958430</span><br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra)  <span class="hljs-number">4</span> <span class="hljs-number">100</span><br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra, <span class="hljs-type">char</span> init)  <span class="hljs-number">4</span> <span class="hljs-number">100</span> a<br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra)  <span class="hljs-number">4</span> <span class="hljs-number">100</span><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra, <span class="hljs-type">char</span> init)  <span class="hljs-number">4</span> <span class="hljs-number">100</span> a<br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* start), size= <span class="hljs-number">4</span>  start= <span class="hljs-number">0xffffcd958430</span><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size), size= <span class="hljs-number">4</span><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>在进行重载new()，delete()，第一个参数默认是的size_t，是不能改变的，改变就会错误。在进行函数定义时必须要这么定义，否则就会出错。</p><p>在进行函数调用时，第一个参数是默认传入对象的大小，这个是不用写，我们只需要填写从第二个开始的函数即可。</p><p><img src="/../pictures/20250522/image%2020.png" alt="image.png"></p><p>C++中使用 <code>new(extra)</code> 来动态分配（即“扩充申请”）<code>basic_string</code>对象的内容</p><ol><li><strong><code>basic_string</code> 类的定义：</strong><ul><li>这是C++标准库中字符串类的基础模板，支持自定义字符类型（如 <code>char</code>、<code>wchar_t</code> 等）。</li><li>它内部有一个私有成员 <code>Rep</code>，代表字符串的存储结构（通常包括指针、长度、容量等信息）。</li></ul></li><li><strong><code>new(extra)</code> 的作用：</strong><ul><li>在传统的 <code>new</code> 操作中，动态分配一块内存用来存放对象。</li><li><code>new(extra)</code> 是一种“扩展”用法，允许在分配的同时为对象预留额外空间（这里指 <code>extra</code> 字节），以便存放额外数据或优化存储。</li></ul></li></ol><h1 id="Per-class-allocator-版本一"><a href="#Per-class-allocator-版本一" class="headerlink" title="Per-class allocator 版本一"></a>Per-class allocator 版本一</h1><p><img src="/../pictures/20250522/image%2021.png" alt="image.png"></p><p>类的内存分配器有两个作用，一是降低<code>malloc</code>的调用次数，二是减少每次调用<code>malloc</code>都会产生的<code>cookies</code>，因此我们希望对类设计一个分配器，我可以一次性申请24个类的大小，每次需要时都可以从已经分配好的内存池中获取。针对以上的设计目的，类可以设计成如上的版本。</p><p>对于每一个类都有一个<code>next</code>指针，指向下一个块，另外对于此类还需要一个<code>freeStore</code>来存储整个空闲块的位置。</p><p>对于类中<code>operator new的</code>设计，我们已经知道，<code>operator new</code>的第一个参数是类的大小，<code>freeStore</code>是申请的字节的大小，然后又将其转成了<code>Screen</code>类型，当把指针的类型转成<code>Screen</code>类型时，每次对指针的<code>++</code>编译器都会将其转换成对类型大小的操作。</p><p>在<code>operator delete</code>时，需要传入指针的位置以及大小，大小是我们已知的，因此是无用的，归还时直接将其插入到队列的最前端。</p><p>对应的测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Screen</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">i</span>(x) &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> i;&#125;<br>    <span class="hljs-comment">// 重载的operator new和delete的size_t的大小默认是类的大小</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-comment">// static void operator delete(void*, size_t);</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span></span>; <span class="hljs-comment">// 只能任选一个，但是两者不能共存</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 内存管理数据结构</span><br>    Screen* next;<br>    <span class="hljs-type">static</span> Screen* freeStore;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> screenChunk;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> i;<br>&#125;;<br><br><span class="hljs-comment">// 静态成员变量在类外初始化</span><br>Screen* Screen::freeStore = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Screen::screenChunk = <span class="hljs-number">24</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    Screen* p = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (!freeStore) &#123;<br>        <span class="hljs-comment">// 刚开始linklist是空，所以取一大块的memory</span><br>        <span class="hljs-comment">// 接下来是调用全局的 operator new</span><br>        <span class="hljs-type">size_t</span> chunk = screenChunk * size;<br>        freeStore = p =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Screen*&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[chunk]);<br>        <span class="hljs-comment">// 现在内存已经分配还了，需要把其链接起来</span><br>        <span class="hljs-keyword">for</span> (; p != &amp;freeStore[screenChunk - <span class="hljs-number">1</span>]; ++p) &#123;<br>            p-&gt;next = p + <span class="hljs-number">1</span>;<br>        &#125;<br>        p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    p = freeStore;<br>    freeStore = freeStore-&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span>&#123;<br>    (<span class="hljs-built_in">static_cast</span>&lt;Screen*&gt;(p))-&gt;next = freeStore;<br>    freeStore = <span class="hljs-built_in">static_cast</span>&lt;Screen*&gt;(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;test per class allocator 1.....&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(Screen) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Screen) &lt;&lt; endl;<br><br>    <span class="hljs-type">size_t</span> <span class="hljs-type">const</span> N = <span class="hljs-number">100</span>;<br>    Screen* p[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        p[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Screen</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        cout &lt;&lt; p[i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">delete</span> p[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">test per <span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator</span> <span class="hljs-number">1.</span>....<br><span class="hljs-built_in">sizeof</span>(Screen) = <span class="hljs-number">16</span><br><span class="hljs-number">0xaaaac8b402c0</span><br><span class="hljs-number">0xaaaac8b402d0</span><br><span class="hljs-number">0xaaaac8b402e0</span><br><span class="hljs-number">0xaaaac8b402f0</span><br><span class="hljs-number">0xaaaac8b40300</span><br><span class="hljs-number">0xaaaac8b40310</span><br><span class="hljs-number">0xaaaac8b40320</span><br><span class="hljs-number">0xaaaac8b40330</span><br><span class="hljs-number">0xaaaac8b40340</span><br><span class="hljs-number">0xaaaac8b40350</span><br></code></pre></td></tr></table></figure><p>由测试结果可见，我们确实已经把内存接管过来了，因为分配的几个<code>Screen</code>是连续的，<code>Screen</code>之间是只相差了16个字节，与类的大小保持一致，上下并没有<code>cookies</code>，符合预期。</p><p>但是这样做好像是有些浪费资源，因为在类中额外定义了<code>Screen*</code>的<code>next</code>指针，浪费了4个字节。如果<code>new</code>的数目足够的大，那么此部分的消耗也是不可忽略的。因此引出了接下来的版本2，不再额外定义<code>Screen*</code>的<code>next</code>指针。</p><h1 id="Per-class-allocator-版本二"><a href="#Per-class-allocator-版本二" class="headerlink" title="Per-class allocator 版本二"></a>Per-class allocator 版本二</h1><p><img src="/../pictures/20250522/image%2022.png" alt="image.png"></p><ul><li>设计<code>per-class allocator 2</code>的目的，是为了避免在每个对象中都额外存储一个<code>next</code>指针，节省空间。</li><li>为此，采用<strong>联合体（<code>union</code>）</strong>，让内存块在空闲时可以用作链表的<code>next</code>指针。</li><li><strong>当这块内存未被使用（空闲）时</strong>，前四个字节（或最开始的部分）用来存放<code>next</code>指针。</li><li><strong>当这块内存被使用（分配给对象）时</strong>，它就占用整个块，用于存放对象数据。</li></ul><p><img src="/../pictures/20250522/image%2023.png" alt="image.png"></p><p>根据图示的测试结果，如果使用的是全局的<code>operator new/delete</code>时，则类与类之间的内存间隔就会多些，因为上下cookies的占用。</p><p>接下来，用代码测试这部分是否符合预期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AirplaneRep</span> &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> miles;<br>        <span class="hljs-type">char</span> type;<br>    &#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">union</span> &#123;<br>        AirplaneRep rep; <span class="hljs-comment">// used object</span><br>        Airplane* next;  <span class="hljs-comment">// free list</span><br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">getMiles</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.miles;&#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.type;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> m, <span class="hljs-type">char</span> t)</span> </span>&#123;<br>        rep.miles = m;<br>        rep.type = t;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* deadobject, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> BLOCK_SIZZ;<br>    <span class="hljs-type">static</span> Airplane* headofFreeList;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Airplane::BLOCK_SIZZ = <span class="hljs-number">512</span>;<br>Airplane* Airplane::headofFreeList = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// static类型的变量在类外定义时不能指定static类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果大小错误，交给 global operator new</span><br>    <span class="hljs-comment">// 在常规的情况下不会走到这里</span><br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Airplane)) &#123;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>    &#125;<br>    Airplane* p = headofFreeList;<br>    <span class="hljs-comment">// if p 有效，就把free list往下一个移</span><br>    <span class="hljs-keyword">if</span> (p) &#123;<br>        headofFreeList = p-&gt;next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// free list为空，要重新分配</span><br>        Airplane* newBlock = <span class="hljs-built_in">static_cast</span>&lt;Airplane*&gt;<br>            (::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(BLOCK_SIZZ * <span class="hljs-built_in">sizeof</span>(Airplane)));<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; BLOCK_SIZZ - <span class="hljs-number">1</span>; ++i) &#123;<br>            newBlock[i].next = &amp;newBlock[i + <span class="hljs-number">1</span>];  <br>        &#125;<br>        newBlock[BLOCK_SIZZ - <span class="hljs-number">1</span>].next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 将p设置为头部，将headofFreeList设置为下一个可用的块</span><br>        p = newBlock;<br>        headofFreeList = &amp;newBlock[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* deadobject, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (deadobject == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Airplane)) &#123;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(deadobject)</span></span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Airplane *carcass = <span class="hljs-built_in">static_cast</span>&lt;Airplane*&gt;(deadobject);<br>    carcass-&gt;next = headofFreeList;<br>    headofFreeList = carcass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;test per class allocator 2.....&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(Airplane) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Airplane) &lt;&lt; endl;<br><br>    <span class="hljs-type">size_t</span> <span class="hljs-type">const</span> N = <span class="hljs-number">100</span>;<br>    Airplane* p[N];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        p[i] = <span class="hljs-keyword">new</span> Airplane;<br>    &#125;<br>    <span class="hljs-comment">// 随机测试objec 正常否</span><br>    p[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-number">10000</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>    p[<span class="hljs-number">4</span>]-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>    p[<span class="hljs-number">9</span>]-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-number">30000</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>    cout &lt;&lt; p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">getType</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">getMiles</span>() &lt;&lt; endl;<br>    cout &lt;&lt; p[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">4</span>]-&gt;<span class="hljs-built_in">getType</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">4</span>]-&gt;<span class="hljs-built_in">getMiles</span>() &lt;&lt; endl;<br>    cout &lt;&lt; p[<span class="hljs-number">9</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">9</span>]-&gt;<span class="hljs-built_in">getType</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">9</span>]-&gt;<span class="hljs-built_in">getMiles</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        cout &lt;&lt; p[i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">delete</span> p[i];<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>    Airplane* p1[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        p1[i] = <span class="hljs-built_in">static_cast</span>&lt;Airplane*&gt;(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(Airplane)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        cout &lt;&lt; p1[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">test per <span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator</span> <span class="hljs-number">2.</span>....<br><span class="hljs-built_in">sizeof</span>(Airplane) = <span class="hljs-number">16</span><br><span class="hljs-number">0xaaaac59802d0</span> A <span class="hljs-number">10000</span><br><span class="hljs-number">0xaaaac5980300</span> B <span class="hljs-number">20000</span><br><span class="hljs-number">0xaaaac5980350</span> C <span class="hljs-number">30000</span><br><span class="hljs-number">0xaaaac59802c0</span><br><span class="hljs-number">0xaaaac59802d0</span><br><span class="hljs-number">0xaaaac59802e0</span><br><span class="hljs-number">0xaaaac59802f0</span><br><span class="hljs-number">0xaaaac5980300</span><br><span class="hljs-number">0xaaaac5980310</span><br><span class="hljs-number">0xaaaac5980320</span><br><span class="hljs-number">0xaaaac5980330</span><br><span class="hljs-number">0xaaaac5980340</span><br><span class="hljs-number">0xaaaac5980350</span><br>---------------------<br><span class="hljs-number">0xaaaac59822d0</span><br><span class="hljs-number">0xaaaac59822f0</span><br><span class="hljs-number">0xaaaac5982310</span><br><span class="hljs-number">0xaaaac5982330</span><br><span class="hljs-number">0xaaaac5982350</span><br><span class="hljs-number">0xaaaac5982370</span><br><span class="hljs-number">0xaaaac5982390</span><br><span class="hljs-number">0xaaaac59823b0</span><br><span class="hljs-number">0xaaaac59823d0</span><br><span class="hljs-number">0xaaaac59823f0</span><br></code></pre></td></tr></table></figure><p>根据输出结果来看，用全局的<code>operator new</code>时，类与类之间的间隔是32个字节，如果用我们自定义的<code>new</code>方法，可以加减少<code>cookies</code>的占用，从32个字节变成了16个字节。</p><h1 id="Common-static-allocator-版本三"><a href="#Common-static-allocator-版本三" class="headerlink" title="Common static allocator 版本三"></a>Common static allocator 版本三</h1><p>对每一个类写一个上述的operator new和operator delete的静态成员函数显得有些重复，我们可以将其包装起来，以便下次使用时可以直接调用。每个分配器都是一个对象，我们可以直接调用。</p><p><img src="/../pictures/20250522/image%2024.png" alt="image.png"></p><p><img src="/../pictures/20250522/image%2025.png" alt="image.png"></p><p><img src="/../pictures/20250522/image%2026.png" alt="image.png"></p><p>任然使用embeding Point的形式，类的大小是allocator传入的size_t，我们使用的size_t的前四个字节进行内存管理。具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator_my</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">obj</span> &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">obj</span>* next;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dealloacte</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    obj* freestore&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> CHUNK = <span class="hljs-number">5</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocator_my::allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">obj</span>* p;<br>    <span class="hljs-keyword">if</span> (!freestore) &#123;<br>        <span class="hljs-type">size_t</span> chunk = CHUNK * size;<br>        freestore = p = (obj*)<span class="hljs-built_in">malloc</span>(chunk);<br><br>        <span class="hljs-comment">// 分割好后，需要将链表串起来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHUNK - <span class="hljs-number">1</span>; ++i) &#123;<br>            p-&gt;next = (obj*)(((<span class="hljs-type">char</span>*)p) + size);<br>            p = p -&gt;next;<br>        &#125;<br>        p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    p = freestore;<br>    freestore = freestore-&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocator_my::dealloacte</span><span class="hljs-params">(<span class="hljs-type">void</span>* p, <span class="hljs-type">size_t</span>)</span> </span>&#123;<br>    ((obj*)p)-&gt;next = freestore;<br>    freestore = (obj*)p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocator_my::check</span><span class="hljs-params">()</span> </span>&#123;<br>    obj* p = freestore;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        cout &lt;&lt; p &lt;&lt; endl;<br>        p = p-&gt;next;<br>        count++;<br>    &#125;<br>    cout &lt;&lt; count &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> L;<br>    string str;<br>    <span class="hljs-type">static</span> allocator_my myAlloc;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">long</span> l) : <span class="hljs-built_in">L</span>(l) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">allocate</span>(size);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">dealloacte</span>(pdead, size);<br>    &#125;<br>&#125;;<br><br>allocator_my Foo::myAlloc;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    complex&lt;<span class="hljs-type">double</span>&gt; c;<br>    string str;<br>    <span class="hljs-type">static</span> allocator_my myAlloc;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Goo</span>(<span class="hljs-type">const</span> complex&lt;<span class="hljs-type">double</span>&gt;&amp; x) : <span class="hljs-built_in">c</span>(x) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">allocate</span>(size);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">dealloacte</span>(pdead, size); <br>    &#125;<br>&#125;;<br><br>allocator_my Goo::myAlloc;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        Foo* p[<span class="hljs-number">100</span>];<br>        cout &lt;&lt; <span class="hljs-string">&quot;sizeof (Foo) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Foo) &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; ++i) &#123;<br>            p[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(i);<br>            cout &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;L &lt;&lt; endl;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; ++i) &#123;<br>            <span class="hljs-keyword">delete</span> p[i];<br>        &#125;<br>        Foo::myAlloc.<span class="hljs-built_in">check</span>();<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br>    &#123;<br>        Goo* p[<span class="hljs-number">100</span>];<br>        cout &lt;&lt; <span class="hljs-string">&quot;sizeof(Goo) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Goo) &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            p[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Goo</span>(<span class="hljs-built_in">complex</span>&lt;<span class="hljs-type">double</span>&gt;(i, i));<br>            cout &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;c &lt;&lt; endl;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-keyword">delete</span> p[i];<br>        &#125;<br>        Goo::myAlloc.<span class="hljs-built_in">check</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp">➜  mem ./<span class="hljs-function">jj09                 </span><br><span class="hljs-function"><span class="hljs-title">sizeof</span> <span class="hljs-params">(Foo)</span> </span>= <span class="hljs-number">40</span><br><span class="hljs-number">0xaaaaec5062c0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0xaaaaec5062e8</span> <span class="hljs-number">1</span><br><span class="hljs-number">0xaaaaec506310</span> <span class="hljs-number">2</span><br><span class="hljs-number">0xaaaaec506338</span> <span class="hljs-number">3</span><br><span class="hljs-number">0xaaaaec506360</span> <span class="hljs-number">4</span><br><span class="hljs-number">0xaaaaec506390</span> <span class="hljs-number">5</span><br><span class="hljs-number">0xaaaaec5063b8</span> <span class="hljs-number">6</span><br><span class="hljs-number">0xaaaaec5063e0</span> <span class="hljs-number">7</span><br><span class="hljs-number">0xaaaaec506408</span> <span class="hljs-number">8</span><br><span class="hljs-number">0xaaaaec506430</span> <span class="hljs-number">9</span><br><span class="hljs-number">0xaaaaec506460</span> <span class="hljs-number">10</span><br><span class="hljs-number">0xaaaaec506488</span> <span class="hljs-number">11</span><br><span class="hljs-number">0xaaaaec5064b0</span> <span class="hljs-number">12</span><br><span class="hljs-number">0xaaaaec5064d8</span> <span class="hljs-number">13</span><br><span class="hljs-number">0xaaaaec506500</span> <span class="hljs-number">14</span><br><span class="hljs-number">0xaaaaec506530</span> <span class="hljs-number">15</span><br><span class="hljs-number">0xaaaaec506558</span> <span class="hljs-number">16</span><br><span class="hljs-number">0xaaaaec506580</span> <span class="hljs-number">17</span><br><span class="hljs-number">0xaaaaec5065a8</span> <span class="hljs-number">18</span><br><span class="hljs-number">0xaaaaec5065d0</span> <span class="hljs-number">19</span><br><span class="hljs-number">0xaaaaec506600</span> <span class="hljs-number">20</span><br><span class="hljs-number">0xaaaaec506628</span> <span class="hljs-number">21</span><br><span class="hljs-number">0xaaaaec506650</span> <span class="hljs-number">22</span><br><span class="hljs-number">0xaaaaec506678</span> <span class="hljs-number">23</span><br><span class="hljs-number">0xaaaaec5066a0</span> <span class="hljs-number">24</span><br><span class="hljs-number">0xaaaaec5066a0</span><br><span class="hljs-number">0xaaaaec506678</span><br><span class="hljs-number">0xaaaaec506650</span><br><span class="hljs-number">0xaaaaec506628</span><br><span class="hljs-number">0xaaaaec506600</span><br><span class="hljs-number">0xaaaaec5065d0</span><br><span class="hljs-number">0xaaaaec5065a8</span><br><span class="hljs-number">0xaaaaec506580</span><br><span class="hljs-number">0xaaaaec506558</span><br><span class="hljs-number">0xaaaaec506530</span><br><span class="hljs-number">0xaaaaec506500</span><br><span class="hljs-number">0xaaaaec5064d8</span><br><span class="hljs-number">0xaaaaec5064b0</span><br><span class="hljs-number">0xaaaaec506488</span><br><span class="hljs-number">0xaaaaec506460</span><br><span class="hljs-number">0xaaaaec506430</span><br><span class="hljs-number">0xaaaaec506408</span><br><span class="hljs-number">0xaaaaec5063e0</span><br><span class="hljs-number">0xaaaaec5063b8</span><br><span class="hljs-number">0xaaaaec506390</span><br><span class="hljs-number">0xaaaaec506360</span><br><span class="hljs-number">0xaaaaec506338</span><br><span class="hljs-number">0xaaaaec506310</span><br><span class="hljs-number">0xaaaaec5062e8</span><br><span class="hljs-number">0xaaaaec5062c0</span><br><span class="hljs-number">25</span><br>----------------<br><span class="hljs-built_in">sizeof</span>(Goo) = <span class="hljs-number">48</span><br><span class="hljs-number">0xaaaaec5066d0</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-number">0xaaaaec506700</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-number">0xaaaaec506730</span> (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">0xaaaaec506760</span> (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">0xaaaaec506790</span> (<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br><span class="hljs-number">0xaaaaec5067d0</span> (<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)<br><span class="hljs-number">0xaaaaec506800</span> (<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)<br><span class="hljs-number">0xaaaaec506830</span> (<span class="hljs-number">7</span>,<span class="hljs-number">7</span>)<br><span class="hljs-number">0xaaaaec506860</span> (<span class="hljs-number">8</span>,<span class="hljs-number">8</span>)<br><span class="hljs-number">0xaaaaec506890</span> (<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)<br><span class="hljs-number">0xaaaaec506890</span><br><span class="hljs-number">0xaaaaec506860</span><br><span class="hljs-number">0xaaaaec506830</span><br><span class="hljs-number">0xaaaaec506800</span><br><span class="hljs-number">0xaaaaec5067d0</span><br><span class="hljs-number">0xaaaaec506790</span><br><span class="hljs-number">0xaaaaec506760</span><br><span class="hljs-number">0xaaaaec506730</span><br><span class="hljs-number">0xaaaaec506700</span><br><span class="hljs-number">0xaaaaec5066d0</span><br></code></pre></td></tr></table></figure><h1 id="Macro-allocator-版本四"><a href="#Macro-allocator-版本四" class="headerlink" title="Macro allocator 版本四"></a>Macro allocator 版本四</h1><p>既然上述的写法比较通用，我们可以将其抽象为宏，这样才后续的代码撰写中就可以轻松的写出类的分配器。</p><p><img src="/../pictures/20250522/image%2027.png" alt="image.png"></p><p><img src="/../pictures/20250522/image%2028.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//借鏡 MFC macros. </span><br><span class="hljs-comment">// DECLARE_POOL_ALLOC -- used in class definition</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_POOL_ALLOC() \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">    void* operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; \</span><br><span class="hljs-meta">    void operator delete(void* p) &#123; myAlloc.deallocate(p, 0); &#125; \</span><br><span class="hljs-meta">protected: \</span><br><span class="hljs-meta">    static allocator myAlloc; </span><br><br><span class="hljs-comment">// IMPLEMENT_POOL_ALLOC -- used in class implementation file</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span><br><span class="hljs-meta">allocator class_name::myAlloc; </span><br><br><span class="hljs-comment">// in class definition file</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>   <span class="hljs-built_in">DECLARE_POOL_ALLOC</span>()<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">long</span> L;<br>    string str;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">long</span> l) : <span class="hljs-built_in">L</span>(l) &#123;  &#125;   <br>&#125;;<br><span class="hljs-comment">//in class implementation file</span><br><span class="hljs-built_in">IMPLEMENT_POOL_ALLOC</span>(Foo) <br><br><span class="hljs-comment">//  in class definition file</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goo</span> &#123;<br>   <span class="hljs-built_in">DECLARE_POOL_ALLOC</span>()<br><span class="hljs-keyword">public</span>: <br>    complex&lt;<span class="hljs-type">double</span>&gt; c;<br>    string str;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Goo</span>(<span class="hljs-type">const</span> complex&lt;<span class="hljs-type">double</span>&gt;&amp; x) : <span class="hljs-built_in">c</span>(x) &#123;  &#125;   <br>&#125;;<br><span class="hljs-comment">//in class implementation file</span><br><span class="hljs-built_in">IMPLEMENT_POOL_ALLOC</span>(Goo) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>内存管理-侯捷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章：站在对象模型的尖端</title>
    <link href="/posts/2554354592/"/>
    <url>/posts/2554354592/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章：执行期语意学</title>
    <link href="/posts/3122301031/"/>
    <url>/posts/3122301031/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章：构造、析构、拷贝语意学</title>
    <link href="/posts/3301587688/"/>
    <url>/posts/3301587688/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章：Function语意学</title>
    <link href="/posts/2197280911/"/>
    <url>/posts/2197280911/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章：Data语意学</title>
    <link href="/posts/1668188749/"/>
    <url>/posts/1668188749/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章：构造函数语意学</title>
    <link href="/posts/4223977684/"/>
    <url>/posts/4223977684/</url>
    
    <content type="html"><![CDATA[<p>本章内容是挖掘编译器对<strong>对象构造</strong>程的干涉，及其对代码形式以及执行效率的影响…</p><span id="more"></span><h1 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1. 默认构造函数"></a>1. 默认构造函数</h1><p>如果某个 C++ 类未定义任何构造器（有参&#x2F;无参），C++ 编译器会自动为该类合成默认构造函数。譬如以下这个<code>ListNode</code>类，只有成员变量，没有<code>ListNode()</code>的任何形式的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ListNode node1; <span class="hljs-comment">//有没有这句话，汇编语言竟然是一样的，奇怪吧！！！</span><br>    ListNode node2 = <span class="hljs-built_in">ListNode</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说上述情况下编译器合成的默认构造函数是 trivial（没有用的）的。但从实际调试过程发现</p><ol><li><code>node1</code>的成员变量的值是随机的</li><li><code>node2</code>的成员变量<code>node2.val</code>值为 0，<code>node2.next</code>值为 <code>nullptr</code></li></ol><p>对于上面情况的解释如下：</p><ul><li><p>在GNU编译器的情况下，如果定义了但是没有使用且没有初始化，栈上就不会分配空间。如果只定义了<code>ListNode node1;</code> 可见栈上是没有分配内存的。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    1131:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    1136:       5d                      pop    %rbp<br>    1137:       c3   <br></code></pre></td></tr></table></figure></li><li><p>如果有调用默认构造函数，那么在栈上就会分配空间，且将初值设置成0。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    1131:       c7 45 f0 00 00 00 00    movl   <span class="hljs-variable">$0x0</span>,-0x10(%rbp)<br>    1138:       48 c7 45 f8 00 00 00    movq   <span class="hljs-variable">$0x0</span>,-0x8(%rbp)<br>    113f:       00 <br>    1140:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    1145:       5d                      pop    %rbp<br>    1146:       c3                      ret<br></code></pre></td></tr></table></figure></li></ul><p>原因是如果在栈上分配了对象的空间，那么就会把栈上空间清空，如果在堆上分配空间，那么就会是之前的内容。</p><p>让我们从汇编的角度来验证上面的结论,，使用<code>objdump -d bin</code>的形式查看源码，我们看下main函数对应的汇编代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    A obj;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    <span class="hljs-comment"># 重点语句</span><br>    1131:       c7 45 ec 01 00 00 00    movl   <span class="hljs-variable">$0x1</span>,-0x14(%rbp)<br>    1138:       c7 45 f0 02 00 00 00    movl   <span class="hljs-variable">$0x2</span>,-0x10(%rbp)<br>    <br>    113f:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    1144:       5d                      pop    %rbp<br>    1145:       c3                      ret<br></code></pre></td></tr></table></figure><p>震惊不，三句C++ 语言代码竟然只使用两条汇编代码就实现了。只对<code>i,j</code>在栈上分配空间，对<code>obj</code>并没有分配空间。</p><p>如果我们在定义的时候调用了默认构造函数，我们继续看其汇编代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-comment">// 如果显示定义了默认构造函数，那将完全不一样</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    A obj = <span class="hljs-built_in">A</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    1131:       c7 45 f8 01 00 00 00    movl   <span class="hljs-variable">$0x1</span>,-0x8(%rbp) <br>    1138:       c7 45 f4 00 00 00 00    movl   <span class="hljs-variable">$0x0</span>,-0xc(%rbp)<br>    113f:       c7 45 <span class="hljs-built_in">fc</span> 02 00 00 00    movl   <span class="hljs-variable">$0x2</span>,-0x4(%rbp)<br>    1146:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    114b:       5d                      pop    %rbp<br>    114c:       c3                      ret<br></code></pre></td></tr></table></figure><ul><li>把当前栈帧-<code>0x8</code>写入<code>0x1</code>，代表的是<code>-0x8</code>到<code>-0xc</code>是i</li><li>把当前栈帧<code>-0xc</code>写入<code>0</code>，代表的是<code>-0xc</code>到<code>-0xd</code>是<code>obj</code></li><li>把当前栈帧<code>-0x4</code>写入<code>0x2</code>，代表的是<code>-0x4</code>到<code>-0x8</code>是<code>j</code></li></ul><p>书中总结的 C++ 编译器会生成 nontrivial 默认构造函数的四种场景：</p><ul><li><p>成员变量的类显式定义了默认构造函数；</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Member</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Member default constructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Member m; <span class="hljs-comment">// 当 Container 被构造时，Member 的默认构造函数被调用</span><br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br>Container c; <span class="hljs-comment">// 输出: Member default constructor</span><br></code></pre></td></tr></table></figure><p>  其本质会生成一个默认构造函数，在默认构造函数中调用了成员变量的默认构造函数。编译器会以 <code>inline</code> 方式合成默认构造函数。若函数复杂，则生成显式 <code>non-inline static</code> 实体。</p></li><li><p>基类之一显式定义了默认构造函数；</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base default constructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 无显式构造函数</span><br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br>Derived d; <span class="hljs-comment">// 输出: Base default constructor</span><br></code></pre></td></tr></table></figure><p>  派生类会先调用基类的默认构造函数（按声明顺序）。</p></li><li><p>定义了 virtual 函数；</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br>VBase v; <span class="hljs-comment">// 编译器生成虚函数表（vtbl）并初始化 vptr</span><br></code></pre></td></tr></table></figure></li><li><p>虚拟继承一个基类；</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> i; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> j; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">double</span> d; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> k; &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="hljs-number">1024</span>; &#125; <span class="hljs-comment">// 需运行时确定 X::i 的位置</span><br><br><span class="hljs-comment">// 测试</span><br>C c;<br><span class="hljs-built_in">foo</span>(&amp;c); <span class="hljs-comment">// 编译器确保 virtual base class 位置在执行期可确定</span><br></code></pre></td></tr></table></figure></li></ul><p>编译器生成的默认构造函数仅初始化基类和成员类对象，其他非静态成员（如整数、指针等）不会被初始化。这是程序员的责任。</p><ol><li><strong>误解</strong>：任何未定义默认构造函数的类都会被编译器生成一个。<ul><li><strong>事实</strong>：仅当编译器需要时才生成。</li></ul></li><li><strong>误解</strong>：编译器生成的默认构造函数会初始化所有数据成员。<ul><li><strong>事实</strong>：仅初始化基类和成员类对象。</li></ul></li></ol><h1 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2. 拷贝构造函数"></a>2. 拷贝构造函数</h1><h2 id="2-1-拷贝构造函数的使用场景"><a href="#2-1-拷贝构造函数的使用场景" class="headerlink" title="2.1 拷贝构造函数的使用场景"></a>2.1 拷贝构造函数的使用场景</h2><p>复制构造函数在什么情况下会被调用</p><ol><li>用一个对象初始化另一个新对象（注意与赋值运算符的区别）。构造函数都是在定义对象的时候用到了，定义是指申请内存空间</li><li>向函数传递对象参数时（值传递）</li><li>函数返回对象时（通常会被返回值优化RVO&#x2F;NRV优化）</li></ol><p>何时需要自定义复制构造函数</p><ol><li>动态内存分配（指针成员）</li><li>文件句柄等系统资源</li><li>需要<strong>深拷贝</strong>的复杂数据结构</li></ol><p>编译器何时合成复制构造函数</p><ol><li>类没有显式定义复制构造函数</li><li>类不满足”位逐次拷贝”(bitwise copy)条件</li></ol><p>编译器如何扩充复制构造函数</p><ol><li>基类复制构造函数的调用</li><li>成员对象复制构造函数的调用</li><li>虚表指针(vptr)的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Default Constructor\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MyClass obj)</span> </span>&#123;&#125;  <span class="hljs-comment">// 值传递会调用复制构造</span><br><br><span class="hljs-function">MyClass <span class="hljs-title">createObj</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// 可能调用复制构造（取决于优化）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 情况1：显式初始化</span><br>    MyClass obj1;<br>    MyClass obj2 = obj1;  <span class="hljs-comment">// 调用复制构造</span><br>    <br>    <span class="hljs-comment">// 情况2：参数传递</span><br>    <span class="hljs-built_in">func</span>(obj1);  <span class="hljs-comment">// 调用复制构造</span><br>    <br>    <span class="hljs-comment">// 情况3：返回值</span><br>    MyClass obj3 = <span class="hljs-built_in">createObj</span>();  <span class="hljs-comment">// 可能调用复制构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-位逐次拷贝-bitwise-copy"><a href="#2-2-位逐次拷贝-bitwise-copy" class="headerlink" title="2.2 位逐次拷贝(bitwise copy)"></a><strong>2.2 位逐次拷贝(bitwise copy)</strong></h2><ol><li>适用bitwise copy的情况</li></ol><p>对于简单类<code>Point</code>，编译器直接使用内存复制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><br>Point p1;<br>Point p2 = p1;  <span class="hljs-comment">// 直接内存复制</span><br></code></pre></td></tr></table></figure><ol><li>****不适用bitwise copy的四种情况</li></ol><p>不适用bitwise copy的四种情况下，如果没有显示的定义copy构造函数，编译器就会合成copy构造函数，如果显示的定义copy构造函数，编译器还会进行构造函数的填充。</p><ul><li><p>成员有复制构造函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Member</span>(<span class="hljs-type">const</span> Member&amp;) &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br>    Member m;<br>    <span class="hljs-comment">// 编译器合成复制构造时会调用m的复制构造</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>基类有复制构造函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">const</span> Base&amp;) &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-comment">// 编译器合成复制构造时会调用Base的复制构造*</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>类有虚函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WithVirtual</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">// 编译器合成复制构造时会初始化vptr</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>继承虚基类</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualBase</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> VirtualBase &#123;<br>    <span class="hljs-comment">// 编译器合成复制构造时会处理虚基类</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-3-编译器合成的copy构造函数"><a href="#2-3-编译器合成的copy构造函数" class="headerlink" title="2.3 编译器合成的copy构造函数"></a><strong>2.3 编译器合成的copy构造函数</strong></h2><p>编译器合成的复制构造函数分为两类：</p><ol><li><p><strong>trivial（平凡的）</strong> - 直接bitwise copy</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trivial</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;  <span class="hljs-comment">// 编译器使用内存复制*</span><br></code></pre></td></tr></table></figure></li><li><p><strong>nontrivial（非平凡的）</strong> - 需要额外处理</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonTrivial</span> &#123;<br>    std::string str;  <span class="hljs-comment">// string有复制构造函数// 编译器合成复制构造时会调用str的复制构造*</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> 成员变量有默认的构造函数，所以<code>NonTrivial</code>类会调用string的copy构造函数，执行深copy</p></li></ol><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a><strong>2.4 总结</strong></h2><ol><li><p><strong>位逐次拷贝适用条件</strong>：类必须同时满足：</p><ul><li>成员无复制构造函数</li><li>基类无复制构造函数</li><li>无虚函数</li><li>不继承虚基类</li></ul><blockquote><p>此种情况下编译器会合成无用的copy构造函数，本质上是做内存的memset</p></blockquote></li><li><p><strong>必须自定义复制构造函数的场景</strong>：</p><ul><li>管理动态内存（深拷贝需求）</li><li>持有系统资源（文件&#x2F;网络等）</li><li>需要特殊拷贝语义的复杂数据结构</li></ul></li><li><p><strong>编译器扩充规则</strong>：</p><ul><li>保证基类和成员的正确拷贝</li><li>维护虚函数机制</li><li>处理虚继承体系</li></ul></li><li><p><strong>现代C++最佳实践</strong>：</p><ul><li>明确使用<code>=default</code>或<code>=delete</code>表明意图</li><li>资源管理类应遵循Rule of Three&#x2F;Five</li><li>优先使用移动语义(C++11)减少拷贝开销</li></ul></li></ol><h1 id="3-程序转化语义学"><a href="#3-程序转化语义学" class="headerlink" title="3. 程序转化语义学"></a>3. 程序转化语义学</h1><p>程序转化语义学是指编译器在处理<strong>对象初始化</strong>、<strong>参数传递</strong>和<strong>返回值</strong>时，会对代码进行一系列转换。这些转换保证了C++语义的正确实现，同时也为优化提供了空间。如定义所写，本文介绍3方面的程序转化。</p><h2 id="3-1-对象初始化"><a href="#3-1-对象初始化" class="headerlink" title="3.1 对象初始化"></a>3.1 对象初始化</h2><p>对象初始化是指在定义一个对象后，编译器在背后做了哪些事情</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Default Constructor\\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor\\n&quot;</span>; &#125;<br>&#125;;<br><br>X x0;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">X <span class="hljs-title">x1</span><span class="hljs-params">(x0)</span></span>;  <span class="hljs-comment">// 直接初始化</span><br>    X x2 = x0; <span class="hljs-comment">// 拷贝初始化</span><br>    X x3 = <span class="hljs-built_in">X</span>(x0); <span class="hljs-comment">// 显式临时对象</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上文定义了三个对象，然后对其进行3种初始化方式，直接初始化，拷贝初始化，显示临时对象初始化，这3种初始化方式，最终都会调用copy构造函数，其经编译器转换后，相当于执行了下面的代码(伪码)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义被重写，初始化的操作会被剔除</span><br>    X x1;<br>    X x2;<br>    X x3;<br><br>    <span class="hljs-comment">// 编译器插入copy constructor的调用</span><br>    x<span class="hljs-number">1.</span>X::<span class="hljs-built_in">X</span>(x0);  <span class="hljs-comment">// 调用复制构造</span><br>    x<span class="hljs-number">2.</span>X::<span class="hljs-built_in">X</span>(x0);<br>    x<span class="hljs-number">3.</span>X::<span class="hljs-built_in">X</span>(x0);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl;; &#125;<br>&#125;;<br><br>X x0;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside foo_bar():&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-function">X <span class="hljs-title">x1</span><span class="hljs-params">(x0)</span></span>;<br>    X x2 = x0;<br>    X x3 = <span class="hljs-built_in">X</span>(x0);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Calling foo_bar():&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">foo_bar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Default</span> <span class="hljs-keyword">Constructor</span><br><span class="hljs-title function_">Calling</span> <span class="hljs-title function_">foo_bar</span><span class="hljs-params">()</span>:<br>Inside foo_bar():<br><span class="hljs-keyword">Copy</span> <span class="hljs-keyword">Constructor</span><br><span class="hljs-title function_">Copy</span> <span class="hljs-title function_">Constructor</span><br><span class="hljs-title function_">Copy</span> <span class="hljs-title function_">Constructor</span><br></code></pre></td></tr></table></figure><h2 id="3-2-传参初始化转换"><a href="#3-2-传参初始化转换" class="headerlink" title="3.2 传参初始化转换"></a>3.2 传参初始化转换</h2><p>传参初始化是指在向函数进行<strong>值传递</strong>的过程中，编译器在背后做了哪些事情。有两种策略</p><p>策略1：创建临时对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X x0)</span></span>;  <span class="hljs-comment">// 值传递</span><br><br>X xx;<br><span class="hljs-built_in">foo</span>(xx);<br><br><span class="hljs-comment">// 转换后</span><br>X __temp0;<br>__temp<span class="hljs-number">0.</span>X::<span class="hljs-built_in">X</span>(xx);  <span class="hljs-comment">// 调用复制构造</span><br><span class="hljs-built_in">foo</span>(__temp0);<br><br></code></pre></td></tr></table></figure><p>策略2：直接拷贝到栈上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 编译器可能直接在调用栈上构造对象</span><br><span class="hljs-built_in">foo</span>(xx);<br><span class="hljs-comment">// 转换为在栈上直接调用复制构造</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X x0)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside foo() &quot;</span> &lt;&lt; std::endl;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;testing parameter passing:&quot;</span> &lt;&lt; std::endl;<br>    X xx;<br>    <span class="hljs-built_in">foo</span>(xx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">testing parameter passing:<br><span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Inside</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>根据输出结构，先调用copy构造函数，再走到inside foo()，说明在进行值传递的时候，会调用copy构造函数。</p><h2 id="3-3-返回值初始化转换"><a href="#3-3-返回值初始化转换" class="headerlink" title="3.3 返回值初始化转换"></a>3.3 返回值初始化转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br><span class="hljs-comment">// 转换为</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(X&amp; __result)</span> </span>&#123;<br>    X xx;<br>    xx.X::<span class="hljs-built_in">X</span>();      <span class="hljs-comment">// 默认构造</span><br>    __result.X::<span class="hljs-built_in">X</span>(xx);  <span class="hljs-comment">// 复制构造</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接返回某个类的对象，编译器相当于隐私的定义了一个引用形参，然后传递到函数体内，在函数体内进行构造对象。</p><h2 id="3-4-使用者层面的优化"><a href="#3-4-使用者层面的优化" class="headerlink" title="3.4 使用者层面的优化"></a>3.4 使用者层面的优化</h2><p>程序员在编写程序时，应尽量避免先定义临时对象，然后再返回，应该直接进行返回构造。（实际在编程中，很少遇到这种，我们的函数经常返回的是错误码，需要的对象应该是传参或者是线程中的变量）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 原写法：</span><br><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;y, <span class="hljs-type">const</span> T &amp;z)</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-comment">// 用y,z计算xx</span><br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br><span class="hljs-comment">// 优化后：</span><br><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;y, <span class="hljs-type">const</span> T &amp;z)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>(y, z);  <span class="hljs-comment">// 直接构造返回</span><br>&#125;<br><br><span class="hljs-comment">// 编译器转换：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(X &amp;__result, <span class="hljs-type">const</span> T &amp;y, <span class="hljs-type">const</span> T &amp;z)</span> </span>&#123;<br>    __result.X::<span class="hljs-built_in">X</span>(y, z);  <span class="hljs-comment">// 直接构造到结果</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-5-NRV（Named-Return-Value）优化（少使用）"><a href="#3-5-NRV（Named-Return-Value）优化（少使用）" class="headerlink" title="3.5 NRV（Named Return Value）优化（少使用）"></a>3.5 NRV（Named Return Value）优化（少使用）</h2><p>优化原理，借用编译器特性，让编译器进行优化，但是这种方案通常不好。在现代C++中，有更好的替代方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 原函数</span><br><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br><span class="hljs-comment">// NRV优化后</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(X &amp;__result)</span> </span>&#123;<br>    __result.X::<span class="hljs-built_in">X</span>();  <span class="hljs-comment">// 直接在结果上构造</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>NRV优化的争议点</p><ol><li><p><strong>不可预测性</strong>：优化由编译器决定，开发者无法确保是否发生</p><ul><li>解决方案：使用移动语义(C++11)明确优化意图</li></ul></li><li><p><strong>对称性破坏</strong>：跳过copy constructor可能影响程序逻辑</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Resource</span>() &#123; count++; &#125;<br>    <span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> Resource&amp;) &#123; count++; &#125;<br>    ~<span class="hljs-built_in">Resource</span>() &#123; count--; &#125;<br>    <span class="hljs-comment">// NRV优化会破坏计数的一致性</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>复杂函数优化困难</strong>：当函数有多条返回路径时，NRV难以应用</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        X yy;<br>        <span class="hljs-keyword">return</span> yy;  <span class="hljs-comment">// 多返回路径使优化困难</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-6-总结（优先）"><a href="#3-6-总结（优先）" class="headerlink" title="3.6 总结（优先）"></a>3.6 总结（优先）</h2><ol><li><p><strong>优先使用移动语义</strong>（明确优化意图）</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(xx);  <span class="hljs-comment">// 明确请求移动而非拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值优化(RVO)更可靠</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>();  <span class="hljs-comment">// 保证RVO</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免依赖NRV</strong>：编写不依赖特定优化的代码</p></li><li><p><strong>复杂对象使用智能指针</strong>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;X&gt; <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> xx = std::<span class="hljs-built_in">make_unique</span>&lt;X&gt;();<br>    <span class="hljs-keyword">return</span> xx;  <span class="hljs-comment">// 无拷贝开销</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="4-成员初始化列表"><a href="#4-成员初始化列表" class="headerlink" title="4. 成员初始化列表"></a>4. 成员初始化列表</h1><p>成员初始化列表（Member Initialization List）是构造函数中初始化类成员的特殊语法。在某些情况下，使用初始化列表是<strong>必须的</strong>，而不仅仅是风格选择。</p><p>基本语法形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    Type member;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">member</span>(initialValue) &#123;&#125;  <span class="hljs-comment">// 初始化列表</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="4-1-必须使用初始化列表的四种情况"><a href="#4-1-必须使用初始化列表的四种情况" class="headerlink" title="4.1 必须使用初始化列表的四种情况"></a>4.1 必须使用初始化列表的四种情况</h2><ol><li>初始化引用成员（reference member）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefHolder</span> &#123;<br>    <span class="hljs-type">int</span>&amp; ref;  <span class="hljs-comment">// 引用成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RefHolder</span>(<span class="hljs-type">int</span>&amp; value) : <span class="hljs-built_in">ref</span>(value) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表</span><br>    <span class="hljs-comment">// 错误写法：RefHolder(int&amp; value) &#123; ref = value; &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：引用必须在创建时初始化，不能在构造函数体内赋值。</p><ol><li>初始化常量成员（const member）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstHolder</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> value;  <span class="hljs-comment">// 常量成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConstHolder</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表</span><br>    <span class="hljs-comment">// 错误写法：ConstHolder(int v) &#123; value = v; &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：const成员必须在创建时初始化，之后不能修改。</p><ol><li>调用基类有参数的构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> value) &#123;&#125;  <span class="hljs-comment">// 有参构造</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">Base</span>(v) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表调用基类构造</span><br>    <span class="hljs-comment">// 错误写法：Derived(int v) &#123; Base(v); &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：基类必须在派生类构造前初始化。</p><ol start="4"><li>调用成员类有参数的构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Member</span>(<span class="hljs-type">int</span> value) &#123;&#125;  <span class="hljs-comment">// 有参构造</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br>    Member mem;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Container</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">mem</span>(v) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表</span><br>    <span class="hljs-comment">// 错误写法：Container(int v) &#123; mem = Member(v); &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：成员对象必须在容器类构造时初始化。</p><h2 id="4-2-初始化列表的其他重要特性"><a href="#4-2-初始化列表的其他重要特性" class="headerlink" title="4.2 初始化列表的其他重要特性"></a>4.2 初始化列表的其他重要特性</h2><ol><li>初始化顺序与声明顺序一致</li></ol><p>编译器会按照成员<strong>声明顺序</strong>初始化，而非初始化列表中的顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderMatters</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">OrderMatters</span>() : <span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>) &#123;&#125;  <span class="hljs-comment">// 实际初始化顺序：a(2)先于b(1)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>初始化代码插入时机</li></ol><p>编译器将初始化列表的代码插入到构造函数体<strong>之前</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 概念性转换</span><br><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">member</span>(v) &#123; <span class="hljs-comment">/* user code */</span> &#125;<br><span class="hljs-comment">// 转换为：</span><br><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-built_in">member</span>(v);  <span class="hljs-comment">// 初始化列表代码</span><br>    <span class="hljs-comment">/* user code */</span>  <span class="hljs-comment">// 构造函数体</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h2><ol><li><p><strong>必须使用的情况</strong>：遇到上述四种情况时，必须使用初始化列表</p></li><li><p><strong>效率考虑</strong>：对于非POD类型，使用初始化列表比构造函数体内赋值更高效</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 更高效</span><br><span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;hello&quot;</span>) &#123;&#125;<br><br><span class="hljs-comment">// 低效（先默认构造，再赋值）</span><br><span class="hljs-built_in">MyClass</span>() &#123; str = <span class="hljs-string">&quot;hello&quot;</span>; &#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>顺序一致性</strong>：按照成员声明顺序编写初始化列表，避免混淆</p></li><li><p><strong>简单初始化</strong>：对于简单POD类型(int, float等)，初始化列表不是必须的，但推荐使用保持一致性</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章：关于对象</title>
    <link href="/posts/726162626/"/>
    <url>/posts/726162626/</url>
    
    <content type="html"><![CDATA[<p>本章主要以对象为基础观念背景，对C++对象模型进行一个概述~</p><span id="more"></span><p>前情提要，本文示例的编译环境<code>Linux ubuntu-linux-22-04-02-desktop 5.15.0-133-generic #144-Ubuntu SMP Sat Feb 8 14:13:21 UTC 2025 aarch64 aarch64 aarch64 GNU/Linux</code> g++版本<code>g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</code></p><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p>首先是不考虑C++的基本的特性，单纯用C++写C，观察下C++在运行时的一些特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//section1</span><br>    <span class="hljs-type">uint64_t</span> longNo2; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//section2</span><br>    <span class="hljs-type">uint64_t</span> longNo1; <span class="hljs-comment">// 8</span><br>    <span class="hljs-type">uint8_t</span> no1; <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">uint8_t</span> no2; <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">uint8_t</span> no3; <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//section3</span><br>    <span class="hljs-type">uint8_t</span> no4; <span class="hljs-comment">// 1</span><br>&#125;;<br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    cout &lt;&lt; sizeObj &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果<code>sizeObj</code>为 24，调整下不同变量的位置，发现输出结果不同：</p><ul><li>把<code>section2</code>移到<code>section1</code>上方（调整 access sections 的顺序），输出<code>sizeObj</code>为 32；</li><li>把<code>no2</code>移到<code>longNo1</code>上方（调整成员变量的顺序），输出<code>sizeObj</code>为 32；</li></ul><p>为什么会出现这种现象呢？因为有字节对齐！！！</p><p>我们在对上面的程序进行调试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(<span class="hljs-type">int</span>)(&amp;(obj.no2) - (<span class="hljs-type">uint8_t</span>*)(&amp;obj.longNo1))<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><ol><li>首先明确<code>no2</code>和<code>longNo1</code>之间差了9个字节，且<code>longNo1</code>在低地址，<code>no2</code>在高地址</li><li>其次分析上面的debug语句。<code>(int)(&amp;(obj.no2) - (&amp;obj.longNo1))</code>这样写是不行的，因为类型不同的两个变量之间的地址是没办法相减的，报错如下<code>First argument of </code>-‘ is a pointer and second argument is neither an integer nor a pointer of the same type.&#96;</li></ol><aside>💡 发现 C++ 对象的成员变量布局和 C 语言的 struct 布局非常相似，同样需要考虑内存字节对齐问题，同样是按照成员声明的顺序进行布局。</aside><p>接下来对比上述变量就行复制，然后查看内存布局。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>;<br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint8_t</span> no1 = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">uint8_t</span> no3 = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no4 = <span class="hljs-number">14</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    cout &lt;&lt; sizeObj &lt;&lt; endl;<br>    <br>    Object *objPtr = <span class="hljs-keyword">new</span> Object;<br>    <span class="hljs-type">size_t</span> sizeObjPtr = <span class="hljs-built_in">sizeof</span>(objPtr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用GDB的<code>X</code>命令查看对于的内存布局，使用<code>x/32bx &amp;obj</code>打印<code>obj</code>对象的内存，其中<code>b</code>表示以字节划分，32 表示打印 32 个字节的内存空间，<code>x</code>代表的是以16进制打印。打印结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/32bx &amp;obj<br>0xffffffffeed0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br></code></pre></td></tr></table></figure><p>首先内存空间是<code>0xff</code>打头，基本可以断定是栈空间（从高位向地位分配）。其次内存空间中有很多值为<code>0x00</code>的 Padding 字节空间，为了满足内存对齐的需要。注意到前 8 个字节中，低位保存低位，所以当前调试平台是使用小端模式（little-endian）。</p><p>继续查看<code>&amp;sizeObj</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>(gdb) x/32bx &amp;obj<br>0xffffffffeed0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/8bx &amp;sizeObj<br>0xffffffffeec8: 0x20    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br></code></pre></td></tr></table></figure><p>由于栈是从高地址向低地址分配，而<code>&amp;sizeoObj</code> <code>0xffffffffeec8</code> 与<code>&amp;obj</code> <code>0xffffffffeed0</code>刚好差8个字节，是一个<code>size_t</code>的大小。</p><p>从上面的调试过程可见，上面构建的<code>Object</code>对象的内存空间在<strong>栈空间</strong>中。稍微修改一下调试代码，以<code>new</code>方式构建<code>Object</code>对象。编译运行，<code>po objPtr</code>打印<code>objPtr</code>指针（表示<code>objPtr</code>所指向的内存地址），输出结果为 <code>0xaaaaaaac3eb0</code>，此时构建的<code>Object</code>对象存在于内存堆空间中。使用<code>x/32b objPtr</code>查看内存，从数据不难发现它就是个<code>Object</code>对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/32xb objPtr<br>0xaaaaaaac3eb0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xaaaaaaac3eb8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xaaaaaaac3ec0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xaaaaaaac3ec8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/32xbu objPtr<br>0xaaaaaaac3eb0: 1       0       0       0       0       0       0       0<br>0xaaaaaaac3eb8: 12      0       0       0       0       0       0       0<br>0xaaaaaaac3ec0: 2       0       0       0       0       0       0       0<br>0xaaaaaaac3ec8: 11      13      14      0       0       0       0       0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p objPtr <br><span class="hljs-variable">$6</span> = (Object *) 0xaaaaaaac3eb0<br></code></pre></td></tr></table></figure><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><p>上面的类的实现与C语言的struct本质上并没有什么区别，C++相比比C语言而言，最突出的优势是封装，继承，多态。那么在上面的基础情况下，我们再考虑下继承的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>;<br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint8_t</span> no1 = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">uint8_t</span> no3 = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no4 = <span class="hljs-number">14</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject</span> : Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> subLongNo1 = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">uint8_t</span> subNo1 = <span class="hljs-number">16</span>;<br>    <span class="hljs-type">uint8_t</span> subNo2 = <span class="hljs-number">15</span>;<br>    <br>&#125;;<br><br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj;<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    <br>    SubClassObject subobj;<br>    <span class="hljs-type">size_t</span> sizeSubobj = <span class="hljs-built_in">sizeof</span>(SubClassObject);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印<code>sizeSubobj</code>为 48，<code>x/48b &amp;subobj</code>打印内存空间，不难发现，子类成员变量的数据是直接拼接在基类的成员变量内存空间后面。可以看到低32字节是子类的成员变量，高16字节是派生类的成员变量，派生类是直接append到子类的后面的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p sizeSubobj <br><span class="hljs-variable">$1</span> = 48<br>(gdb) x/48bx &amp;subobj<br>0xffffffffeeb8: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec0: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec8: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed0: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x10    0x0f    0x00    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/48bu &amp;subobj<br>0xffffffffeeb8: 1       0       0       0       0       0       0       0<br>0xffffffffeec0: 12      0       0       0       0       0       0       0<br>0xffffffffeec8: 2       0       0       0       0       0       0       0<br>0xffffffffeed0: 11      13      14      0       0       0       0       0<br>0xffffffffeed8: 3       0       0       0       0       0       0       0<br>0xffffffffeee0: 16      15      0       0       0       0       0       0<br></code></pre></td></tr></table></figure><p>在子类定义代码中，交换<code>subNo1</code>和<code>subLongNo1</code>的顺序会导致<code>sizeSubobj</code>变化么？答案是会变化，交换后<code>sizeSubobj</code> 56。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/56xb &amp;subobj<br>0xffffffffeeb0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeeb8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed0: 0x10    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x0f    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/56xu &amp;subobj<br>0xffffffffeeb0: 1       0       0       0       0       0       0       0<br>0xffffffffeeb8: 12      0       0       0       0       0       0       0<br>0xffffffffeec0: 2       0       0       0       0       0       0       0<br>0xffffffffeec8: 11      13      14      0       0       0       0       0<br>0xffffffffeed0: 16      0       0       0       0       0       0       0<br>0xffffffffeed8: 3       0       0       0       0       0       0       0<br>0xffffffffeee0: 15      0       0       0       0       0       0       0<br>(gdb) p sizeSubobj <br><span class="hljs-variable">$2</span> = 56<br></code></pre></td></tr></table></figure><p>同时请注意，在子类是不用用基类的padding空间的。证据如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">2</span>; <span class="hljs-comment">// 8</span><br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-comment">// uint8_t no1 = 11; // 1</span><br>    <span class="hljs-comment">// uint8_t no3 = 13; // 1</span><br><span class="hljs-keyword">public</span>:<br>&#125;;<br><br><span class="hljs-comment">/// 子类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject</span> : Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> subNo1 = <span class="hljs-number">16</span>;<br>    <span class="hljs-type">uint8_t</span> subNo2 = <span class="hljs-number">15</span>;<br>    <span class="hljs-type">uint8_t</span> subNo3 = <span class="hljs-number">17</span>;<br>    <span class="hljs-type">uint8_t</span> subNo4 = <span class="hljs-number">18</span>;<br>    <br>&#125;;<br><br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj;<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    <br>    SubClassObject subobj;<br>    <span class="hljs-type">size_t</span> sizeSubobj = <span class="hljs-built_in">sizeof</span>(SubClassObject);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p sizeSubobj <br><span class="hljs-variable">$1</span> = 32<br>(gdb) x/32bu &amp;subobj<br>0xffffffffeec8: 1       0       0       0       0       0       0       0<br>0xffffffffeed0: 2       0       0       0       0       0       0       0<br>0xffffffffeed8: 12      0       0       0       0       0       0       0<br>0xffffffffeee0: 16      15      17      18      0       0       0       0<br></code></pre></td></tr></table></figure><h1 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h1><p>类的继承链中是否存在虚拟函数会直接影响<strong>类的实例</strong>的大小。总体是这样的规律：若某个类型声明了 <code>virtual</code> 函数，则直接或间接继承了该类型的<strong>所有</strong>衍生类，都需要维护一张 <code>virtual table</code>，用于保存 <code>virtual</code> 函数指针，而此时声明了 <code>virtual</code> 函数的类的实例以及该类的所有衍生类的实例，都需要保证 8 个字节（64 位机）的内存空间用于保存 <code>virtual table</code> 的内存地址，这就是 <code>vptr</code> 指针。代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>;<br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint8_t</span> no1 = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">uint8_t</span> no3 = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no4 = <span class="hljs-number">14</span>;<br>&#125;; <span class="hljs-comment">// 32</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MidObject</span> : Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        <span class="hljs-comment">// Abstract Method</span><br>    &#125;<br>&#125;; <span class="hljs-comment">// 40</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject1</span> : MidObject &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;implement one&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject2</span> : MidObject &#123;<br><br>&#125;;<br><br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(obj) &lt;&lt; endl; <span class="hljs-comment">// 32</span><br>    MidObject midObj = <span class="hljs-built_in">MidObject</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(midObj) &lt;&lt; endl; <span class="hljs-comment">// 40</span><br>    SubClassObject1 subObj1 = <span class="hljs-built_in">SubClassObject1</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(subObj1) &lt;&lt; endl; <span class="hljs-comment">// 40</span><br>    SubClassObject2 subObj2 = <span class="hljs-built_in">SubClassObject2</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(subObj2) &lt;&lt; endl; <span class="hljs-comment">// 40</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>sizeof(Object)</code>为 32，因为继承链上没有 virtual 函数，所以无需保存 vptr 指针；</li><li><code>sizeof(MidObject)</code>为 40，因为自身声明了 virtual 函数，所以需要保存 vptr 指针；</li><li><code>sizeof(SubClassObject1)</code>和<code>sizeof(SubClassObject2)</code>均为 40，因为父类<code>MidObject</code>声明了 virtual 函数，所以需要保存 vptr 指针（不管有没实现 virtual 函数）；</li></ul><p>那么，virtual table 大概保存了什么东西呢？</p><p>同样可以用GDB 的<code>x</code>命令来简单探索一下。分别打印<code>midObj</code>、<code>subObj1</code>、<code>subObj2</code>的内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) x/<span class="hljs-number">32</span>bu &amp;obj<br><span class="hljs-number">0xffffffffee38</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee40</span>: <span class="hljs-number">12</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee48</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee50</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>(gdb) x/<span class="hljs-number">40</span>bu &amp;midObj<br><span class="hljs-number">0xffffffffee58</span>: <span class="hljs-number">200</span>     <span class="hljs-number">28</span>      <span class="hljs-number">171</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee60</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee68</span>: <span class="hljs-number">12</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee70</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee78</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">240</span>     <span class="hljs-number">15</span>      <span class="hljs-number">240</span>     <span class="hljs-number">15</span>      <span class="hljs-number">240</span><br>(gdb) x/<span class="hljs-number">40</span>bu &amp;subObj1<br><span class="hljs-number">0xffffffffee80</span>: <span class="hljs-number">176</span>     <span class="hljs-number">28</span>      <span class="hljs-number">171</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee88</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee90</span>: <span class="hljs-number">12</span>      <span class="hljs-number">240</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee98</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeea0</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>(gdb) x/<span class="hljs-number">40</span>bu &amp;subObj2<br><span class="hljs-number">0xffffffffeea8</span>: <span class="hljs-number">152</span>     <span class="hljs-number">28</span>      <span class="hljs-number">171</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeeb0</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeeb8</span>: <span class="hljs-number">12</span>      <span class="hljs-number">115</span>     <span class="hljs-number">191</span>     <span class="hljs-number">247</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeec0</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeec8</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">247</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>差异在前 8 个字节，也就是说 GNU编译器将 vptr 保存在实例的首 8 个字节。在派生类不太一样，但是这无所谓，因为主题的数据部分是保持一致的。</p><p><code>midObj</code>、<code>subObj1</code>、<code>subObj2</code>的 vptr 也就是 virtual table 的内存地址分别是<code>0xffffffffee58</code>、<code>0xffffffffee80</code>、<code>0xffffffffeea8</code>。用<code>x/g</code>命令分别打印出出上述三个地址为起始的 8 个字节的内存中所保存的内容，比较明显的是三个内存地址从大小上看应该是 text segment 或 data segment 范畴内的内存地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/gx 0xffffffffee58<br>0xffffffffee58: 0x0000aaaaaaab1cc8<br>(gdb) x/gx 0xffffffffee80<br>0xffffffffee80: 0x0000aaaaaaab1cb0<br>(gdb) x/gx 0xffffffffeea8<br>0xffffffffeea8: 0x0000aaaaaaab1c98<br></code></pre></td></tr></table></figure><p>进一步实例的首地址进行分析，发现其确实是执行不同类的虚函数表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p (void(*)(void)) 0x0000aaaaaaab1cc8<br><span class="hljs-variable">$1</span> = (void (*)(void)) 0xaaaaaaab1cc8 &lt;vtable <span class="hljs-keyword">for</span> MidObject+16&gt;<br>(gdb) p (void(*)(void)) 0x0000aaaaaaab1cb0<br><span class="hljs-variable">$2</span> = (void (*)(void)) 0xaaaaaaab1cb0 &lt;vtable <span class="hljs-keyword">for</span> SubClassObject1+16&gt;<br>(gdb) p (void(*)(void)) 0x0000aaaaaaab1c98<br><span class="hljs-variable">$3</span> = (void (*)(void)) 0xaaaaaaab1c98 &lt;vtable <span class="hljs-keyword">for</span> SubClassObject2+16&gt;<br></code></pre></td></tr></table></figure><p>有实现虚函数<code>vfunc</code>的类对象的 virtual table，保存了指向自身实现的<code>vfun</code>的函数指针。而未实现<code>vfun</code>的类对象的 virtual table，则保存了继承链中某个类所实现的<code>vfun</code>的函数指针（这里是指向<code>MidObject</code>实现的<code>vfun</code>）。</p><p>既然虚拟函数有引入 virtual table 的特殊性，那么虚拟继承呢，其会更加复杂，我们再后续的学习中会逐步探索。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章简单调试了 C++ 模型的一些特性，发现其内存布局和 Objective-C 的 Runtime 实现还是有一定的相似之处，例如要求<strong>字节对齐</strong>和<strong>继承触发</strong>的对象尺寸扩展的行为特点。</p><p>C++ 实现面向对象，实际是以 C++ 编译器强干预为前提的。这也是为什么编写 C++ 代码过程中，会更容易遇到类型检查相关的编译 Error 提示，尤其是不按规则的强转，因为 C++ 在编译阶段就需要<strong>确立</strong>很多具体的类型信息，例如成员变量在对象内存空间中的偏移，类的成员函数的具体地址，这些类型信息基本不会推迟到运行时决议（也不需要），所以 C++ 原生是没有反射机制的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    MidObject midObj = <span class="hljs-built_in">MidObject</span>();<br>    SubClassObject1 subObj1 = <span class="hljs-built_in">SubClassObject1</span>();<br>    SubClassObject2 subObj2 = <span class="hljs-built_in">SubClassObject2</span>();<br>    <br>    <span class="hljs-comment">// 调试代码一：非 virtual 机制</span><br>    MidObject *midObjPtr = (MidObject *)&amp;midObj;<br>    Object *baseObjPtr = (Object *)&amp;midObj;<br>    <br>    <span class="hljs-comment">// 调试代码二：virtual 机制</span><br>    SubClassObject1 *subObjPtr1 = &amp;subObj1;<br>    MidObject *midObjPtr12= (MidObject *)subObjPtr1;<br>    midObjPtr-&gt;<span class="hljs-built_in">vfun</span>(); <span class="hljs-comment">//打印结果：implement it</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面调试代码一所示，用 GDB <code>p sizeof(*baseObjPtr)</code>和<code>p sizeof(*midObjPtr)</code>得到的结果分别是 32 和 40，即使<code>baseObjPtr</code>和<code>midObjPtr</code>指向相同的内存地址，但编译阶段实际上已经将其标记为两种类型，所以运行时<code>baseObjPtr</code>和<code>midObjPtr</code>所指向的对象类型就是编译时所声明的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-function">p <span class="hljs-title">sizeof</span><span class="hljs-params">(*baseObjPtr)</span></span><br><span class="hljs-function">$3 </span>= <span class="hljs-number">32</span><br>(gdb) <span class="hljs-function">p <span class="hljs-title">sizeof</span><span class="hljs-params">(*midObjPtr)</span></span><br><span class="hljs-function">$4 </span>= <span class="hljs-number">40</span><br>(gdb) p &amp;midObj<br>$<span class="hljs-number">5</span> = (MidObject *) <span class="hljs-number">0xffffffffe9a0</span><br>(gdb) <span class="hljs-built_in">p</span> (MidObject *) &amp;midObj<br>$<span class="hljs-number">6</span> = (MidObject *) <span class="hljs-number">0xffffffffe9a0</span><br>(gdb) <span class="hljs-built_in">p</span> (Object *) &amp;midObj<br>$<span class="hljs-number">7</span> = (Object *) <span class="hljs-number">0xffffffffe9a8</span> <span class="hljs-comment">// 比Midobject高8个字节，是因为减去了虚函数的指向</span><br>(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">int</span> *) &amp;midObj<br>$<span class="hljs-number">8</span> = (<span class="hljs-type">int</span> *) <span class="hljs-number">0xffffffffe9a0</span><br>(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">void</span> *) &amp;midObj<br>$<span class="hljs-number">9</span> = (<span class="hljs-type">void</span> *) <span class="hljs-number">0xffffffffe9a0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-02</title>
    <link href="/posts/1979324518/"/>
    <url>/posts/1979324518/</url>
    
    <content type="html"><![CDATA[<p>本文是LeetCode刷题记录的第二批</p><span id="more"></span><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-100-liked"><strong>155. 最小栈</strong></a></h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p>解答：此题是模拟题，不难，主要在于思路的打开。想明白成员变量的设计，此题就迎刃而解。</p><p>仍然使用<code>stack</code>作为底层的存储结构，只是成员变量用<code>pari&lt;int, int&gt;</code>，其中<code>first</code>为<code>value</code>， <code>second</code>为目前的最小值。</p><p>如此往栈中新加入数据时，只需要使用<code>geMin()</code>与当前的值取最小值，作为新加入数据的最小值即可。</p><p>在初始化栈时，需要额外<code>(0, INT_MAX)</code>作为初始值，如此在后续添加数据时可以直接使用<code>getMin()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        min_st.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, INT_MAX&#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        min_st.<span class="hljs-built_in">push</span>(&#123;val, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">getMin</span>(), val)&#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        min_st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_st.<span class="hljs-built_in">top</span>().first;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_st.<span class="hljs-built_in">top</span>().second;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; min_st;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此题中用到了make_pair，关于其用法如下：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>示例</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><code>std::make_pair</code></td><td><code>auto p = std::make_pair(1, 2);</code></td><td>最简洁、推荐</td></tr><tr><td>直接构造 <code>pair</code></td><td><code>std::pair&lt;int, int&gt; p(1, 2);</code></td><td>明确创建对象</td></tr><tr><td>列表初始化</td><td><code>std::pair&lt;int, int&gt; p&#123;1, 2&#125;;</code></td><td>C++11特性</td></tr><tr><td>复制构造</td><td><code>auto p = std::pair&lt;int, int&gt;(1, 2);</code></td><td>也可以用，效果一样</td></tr></tbody></table><ul><li>通常建议用 <code>std::make_pair()</code>，因为它可以自动推导类型。</li><li>如果明确类型，直接用构造函数也很好。</li></ul><p>对于<code>pair</code>和<code>make_pair</code>的解析如下：</p><p><code>std::make_pair</code>实际上是一个模板函数，而<code>pair</code>是一个模板类。</p><p>具体来说：</p><p><strong><code>std::pair</code> 是一个模板类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    T1 first;<br>    T2 second;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以用它来定义不同类型的pair，比如：</p><p><code>std::pair&lt;int, int&gt; p1(1, 2);  std::pair&lt;std::string, double&gt; p2(&quot;hello&quot;, 3.14);</code></p><p><code>std::make_pair</code> 是一个模板函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function">std::pair&lt;T1, T2&gt; <span class="hljs-title">make_pair</span><span class="hljs-params">(T1 t, T2 u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pair</span>&lt;T1, T2&gt;(t, u);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模板参数：<code>T1</code> 和 <code>T2</code> <strong>根据传入的参数自动推导</strong>。</li><li>返回值：<code>pair&lt;T1, T2&gt;</code>。</li></ul><h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode.cn/problems/powx-n/description/"><strong>50. Pow(x, n)</strong></a></h1><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p><p>解答：</p><ol><li>使用库函数，直接调用<code>pow(x,n)</code> 显然不合题意</li><li>使用暴力循环，直接循环n次，求得最后结果，显然也不合题意</li><li>使用分治的方法</li></ol><p>为什么采用分治的方法？常规来讲，对<code>n</code>个<code>x</code>求积，可以先求出<code>n/2</code>个<code>x</code>的积，然后再想乘。同理，对于<code>n/2</code>个<code>x</code>的积，可以先求出<code>n/4</code>个<code>x</code>的积，然后再想乘。直到最终<code>n</code>为0时，是已经到达了递归的最深层，此时，梦改醒了。</p><p>在求<code>n</code>个<code>x</code>的积时，由于不知道<code>n</code>的奇偶性，因此开始需要分类讨论。如果是奇数，则需要额外再乘个<code>x</code>，当进入第二层后，就会确定一直是偶数了，不会再走到奇数的分支。</p><ol><li>如果<code>n</code>是负数，需要求其倒数，注意<code>n</code>要<strong>取反</strong></li><li>如果<code>n</code>是奇数，第一步就将其转成偶数</li><li>如果n是偶数，则需要计算 <code>x*x</code> 的 <code>n/2</code>次方</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / <span class="hljs-built_in">pow</span>(x, -n);<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">myPow</span>(x, n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">myPow</span>(x * x , n / <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上是采用递归+分治的方法去做，也可以直接去做，结合位运算，以下是整体思路。</p><ol><li>针对负数做特殊处理</li><li>在循环中获取最后的结果值pow</li><li>如果n是奇数，多乘x，这个在每轮循环中都有可能出现。</li><li>否则直接求得x的平方，n右移两位。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">1</span> / x;<br>            n = -n;<br>        &#125;<br>        <span class="hljs-type">int</span> pow = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>                pow = x * pow;<br>            &#125;<br>            x *= x;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> pow;   <br>    &#125;<br>&#125;；<br></code></pre></td></tr></table></figure><h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked"><strong>128. 最长连续序列</strong></a></h1><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> **的算法解决此问题。</p><ol><li>排序后求解，时间复杂度不合题意</li><li>核心思想，如果在遍历<code>x</code>的时候，发现<code>x-1</code>也在数组里面，那么一定不会以<code>x</code>为起点，至少应该以<code>x-1</code>为起点。</li><li>如果找到了<code>x</code>，其是当前序列最小的，需要循环去遍历<code>x+1</code>是否存在，求得以<code>x</code>开始的序列的长度。</li><li>数组需要去重，因此需要将其放在<code>set</code>里面，然后去**遍历<code>set</code>**求解。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">unordered_set <span class="hljs-title">st</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : st) &#123;<br>            <span class="hljs-comment">// 如果i - 1 存在，则一定不用从i -1 开始遍历</span><br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> tmp = num + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">count</span>(tmp)) &#123;<br>                tmp++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, tmp - num);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另外，其中对于容器的遍历，请用现代C++推荐的<code>based_for</code>形式，无论是关系型容器还是序列性容器，如果只是提取元素，建议<code>for (const auto&amp; val : vec) &#123; /* 访问val */ &#125;</code></p><h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked"><strong>200. 岛屿数量</strong></a></h1><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>对于图的遍历，要求掌握DFS和BFS两种算法，此题由于陆地是连续的，因此要使用DFS遍历。</p><p>使用DFS遍历图时，要注意边界条件，边界条件是递归的出口。</p><p>此题中应该是</p><ol><li>不超过矩阵的范围</li><li>还没有被填充（假设填充时将此块置2）</li></ol><p>所以DFS的算法应该这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>(), col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= row || j &lt; <span class="hljs-number">0</span> || j &gt;=  col || grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j);<br>            <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, j);<br>            <span class="hljs-built_in">dfs</span>(i, j - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">dfs</span>(i, j + <span class="hljs-number">1</span>);<br>        &#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-built_in">dfs</span>(i, j);<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此题的难点主要在于养成图算法的思路，如果遍历整个图？如何写DFS等？</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础能力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板元编程</title>
    <link href="/posts/2756375431/"/>
    <url>/posts/2756375431/</url>
    
    <content type="html"><![CDATA[<h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><p>本节是对B站课程的记录<a href="https://www.bilibili.com/video/BV1FLAAe3E7r/?spm_id_from=333.1387.homepage.video_card.click&vd_source=e0aee50f101b406f0d1414f984f3f5c0">来源</a>，主要是对特化进行介绍~</p><span id="more"></span><p>keywords: 模板，偏特化，全特化，可变参数模板</p><p>练手：实现一个可变参数的日志打印算子，对于不同的参数调用不同的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;General log &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;T*&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T* p_value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Pointer log &quot;</span> &lt;&lt; *p_value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;<span class="hljs-type">double</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; d_value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Double log &quot;</span> &lt;&lt; d_value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;T&amp;&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Reference log &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logone</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>    Logger&lt;T&gt;::<span class="hljs-built_in">log</span>(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAll</span><span class="hljs-params">(<span class="hljs-type">const</span> Args&amp;... args)</span> </span>&#123;<br>    (<span class="hljs-built_in">logone</span>(args),...);<br>&#125;<br><br>---<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-number">10.00</span>;<br>log21::<span class="hljs-built_in">logAll</span>(a, &amp;a, b, &amp;b);<br><br>General log <span class="hljs-number">10</span><br>Pointer log <span class="hljs-number">10</span><br>Double log <span class="hljs-number">10</span><br>Pointer log <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>模板编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见设计类</title>
    <link href="/posts/309135859/"/>
    <url>/posts/309135859/</url>
    
    <content type="html"><![CDATA[<p>本文是对面试题目中常见的手撸算法的总结与汇总…</p><span id="more"></span><h2 id="实现一个string类"><a href="#实现一个string类" class="headerlink" title="实现一个string类"></a>实现一个string类</h2><ul><li>牢记5大件：复制构造函数，移动构造函数，赋值运算符，移动赋值运算符，析构函数。</li><li>成员变量： <code>char *</code> 指针， <code>int len</code> ,要注意申请空间时+1，因为有个默认的换行符</li><li>移动构造函数&amp;移动赋值运算符可以加上 <code>noexpect</code> ，因为移动构造函数不会出现异常</li><li>在移动**函数中，把源对象的指针置空。</li><li>在赋值运算符和赋值构造函数中，const不能去掉，因为const T&amp;即可以接受左值又可以接受右值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mystring</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mystring</span>() : <span class="hljs-built_in">m_arr</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">m_len</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Mystring</span>(<span class="hljs-type">const</span> Mystring&amp; str) : <span class="hljs-built_in">m_len</span>(str.m_len) &#123;<br>        <span class="hljs-keyword">if</span> (m_len != <span class="hljs-number">0</span>) &#123;<br>            m_arr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_len + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">memcpy</span>(m_arr, str.m_arr, m_len + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m_arr = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">Mystring</span>(Mystring&amp;&amp; str) <span class="hljs-keyword">noexcept</span>: <span class="hljs-built_in">m_arr</span>(str.m_arr), <span class="hljs-built_in">m_len</span>(str.m_len)&#123;<br>        str.m_arr = <span class="hljs-literal">nullptr</span>;<br>        str.m_len = <span class="hljs-number">0</span>;<br>    &#125;<br>    Mystring&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Mystring&amp; str) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span>* new_arr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_len + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">memcpy</span>(new_arr, str.m_arr, str.m_len + <span class="hljs-number">1</span>);<br>            m_arr = new_arr;<br>            m_len = str.m_len;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    Mystring&amp; <span class="hljs-keyword">operator</span>=(Mystring&amp;&amp; str) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">delete</span>[] m_arr;<br>            m_arr = str.m_arr;<br>            m_len = str.m_len;<br>            str.m_arr = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Mystring</span>() &#123;<br>        <span class="hljs-keyword">if</span> (m_arr) &#123;<br>            <span class="hljs-keyword">delete</span>[] m_arr;<br>            m_len = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_arr;<br>    <span class="hljs-type">size_t</span> m_len;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h2><p>LRU算法关键在于数据结构的设计。1)链表用<code>list&lt;pair(int ,int)&gt;</code>来记录 2)为方便快速查找，可以用map&lt;int, <code>list&lt;pair(int, int)&gt;::iterator</code>&gt;来记录</p><ol><li><p>当队列满的时候，清楚完需要添加新的元素进行，注意不用用到了<strong>旧key</strong></p></li><li><p>然后尽量用<code>make_pair(key, value)</code>来构造数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">m_capacity</span>(capacity) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_mp.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> iter = m_mp[key]; <span class="hljs-comment">// 值拷贝替代引用</span><br>            <span class="hljs-type">int</span> value = iter-&gt;second;<br>            m_list.<span class="hljs-built_in">erase</span>(iter);<br>            m_list.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>            m_mp[key] = m_list.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_mp.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> iter = m_mp[key]; <span class="hljs-comment">// 值拷贝替代引用</span><br>            m_list.<span class="hljs-built_in">erase</span>(iter);<br>            m_list.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>            m_mp[key] = m_list.<span class="hljs-built_in">begin</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (m_mp.<span class="hljs-built_in">size</span>() &gt;= m_capacity) &#123;<br>                <span class="hljs-type">int</span> old_key = m_list.<span class="hljs-built_in">back</span>().first; <span class="hljs-comment">// 修复键覆盖问题</span><br>                m_list.<span class="hljs-built_in">pop_back</span>();<br>                m_mp.<span class="hljs-built_in">erase</span>(old_key);<br>            &#125;<br>            m_list.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>            m_mp[key] = m_list.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_capacity;<br>    std::list&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; m_list;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::list&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; m_mp;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重要</strong></p></li><li><p>对于关联式容器，尽量不要使用引用，因为引用很有可能导致引用悬挂的风险和迭代器失效的我问题(比如当底层若其扩容时)</p></li><li><p>对于C++11提供了初始化列表的语法，所以对于make_pair(key, value)可以简单的写成{key,value}。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-01</title>
    <link href="/posts/3975367132/"/>
    <url>/posts/3975367132/</url>
    
    <content type="html"><![CDATA[<p>本文是LeetCode刷题记录的第一批</p><span id="more"></span><h1 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode.cn/problems/range-sum-query-immutable/"><strong>303. 区域和检索 - 数组不可变</strong></a></h1><p>题目描述：给个数组，给个区间，求<code>[left, right]</code>的和。</p><p>解题思路：</p><p>用前缀和，前缀和定义为<code>s[i] = num[0] + …… + num[i - 1]，s[j] = num[0] + …… + num[i - 1] + num[i] + …… + num[j - 1]</code>。那么从<code>i→j</code>的和是<code>num[i] + …… + num[j] = s[j + 1] - s[i]</code></p><p>在上述背景下，s[0] &#x3D; 0，为什么这么定义呢？</p><ol><li>考虑边界条件，如果left为0，直接-s[0]就可以了，否则还需要考虑left&#x3D;0的情况。</li><li>假设定义<code>s[i] = num[0] + …… + num[i]</code>, <code>s[j] = num[0] + …… + num[i] + num[i + 1] + …… num[j]</code>，那么[i,j] &#x3D; s[j] - s[i-1]。 此时要求<code>i &gt;= 1</code>，对于i为0的情况，需要单独考虑。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        m_sum.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        m_sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            m_sum[i] += m_sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_sum[right + <span class="hljs-number">1</span>] - m_sum[left];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; m_sum; <br>&#125;;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>对于前缀和，要考虑<code>s[0]</code>的情况，一般设置<code>s[0]=0</code>，那么<code>[i-j]</code>的和可以写成<code>s[i + 1] - s[j]</code>。</li></ol><h1 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="560. 和为k的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/?envType=study-plan-v2&envId=top-100-liked"><strong>560. 和为k的子数组</strong></a></h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 *该数组中和为 <code>k</code> 的子数组的个数。</p><p>子数组是数组中元素的连续非空序列。</p><p>此题适合用前缀和的方式去解答，首先前缀和的基本思路是定义<code>s[0] = 0</code>, <code>sum[i] = sum[i - 1] + nums[i - 1]</code></p><p>计算和为k的连续子数组，计算方法是只要数组中任意两个数之间的差值是k，就是满足题意的。</p><p>前缀和得出后如何求数组中和为<code>k</code>的子数组的个数呢？</p><p>从左到右遍历前缀和数组，如果右边的某位-左边的某位&#x3D;k，则满足题意。但是如果直接按照这种方式模拟，又是暴力求解。</p><p>所以此时用一个hash表去记录，从左到右查找，直接加上目标元素的<code>value</code>值。然后把当前的元素值放在map表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            sum[i + <span class="hljs-number">1</span>] = sum[i] + nums[i];<br>        &#125;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; sum_cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> value : sum) &#123;<br>            <span class="hljs-keyword">if</span> (sum_cnt.<span class="hljs-built_in">count</span>(value - k) != <span class="hljs-number">0</span>) &#123;<br>                res += sum_cnt[value - k];<br>            &#125;<br>            sum_cnt[value]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&envId=top-100-liked"><strong>239. 滑动窗口最大值</strong></a></h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> **的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><hr><p>此题在难度为hard，并没有思路。题解描述为使用双端队列来做，队列是单调的，队首对应的元素一直是组大的。然后队列的大小没必要是滑动窗口的大小。因为要保证队列元素有序，所以双端队列的大小是小于滑动窗口的大小的。</p><p>有一个比较有意思的记忆方法：公司的人数有k，数组的下标对应的是员工的年龄，数组的值对应的是员工的能力。</p><ol><li>如果当前员工比公司最差的员工的还差，则不让他进公司</li><li>如果当前员工进入了公司，就要把最差的踢出去。</li><li>团队最厉害的人到了年纪，也必须要踢出去。</li></ol><p>由于进公司有一定的标准，所以其是个单调栈，所以一定会保证栈中元素顺序。</p><p>其中，单调栈是指双端队列中的数据是有序的，到底是&lt;还是≤是无所谓的，因为决定滑动窗口大小的是i和队首的大小。</p><p>为什么最后一个循环一定是满足题意的，考虑一下最后的结果，就是从刚开始第一个窗口处开始，每次加一个元素，都会有一个结果加入的res中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 滑动窗口，求窗口内的最大值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">reserve</span>(nums.<span class="hljs-built_in">size</span>());<br>        deque&lt;<span class="hljs-type">int</span>&gt; qu;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">// 维护单调栈，此处是&lt;还是&lt;=</span><br>            <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[qu.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>                qu.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            qu.<span class="hljs-built_in">push_back</span>(i);<br><br>            <span class="hljs-keyword">if</span> (i - qu.<span class="hljs-built_in">front</span>() &gt;= k) &#123;<br>                qu.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-comment">// 每次走到这，一定是满足题意了，除了第一次还没形成过一个窗口</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(nums[qu.<span class="hljs-built_in">front</span>()]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked"><strong>54. 螺旋矩阵</strong></a></h1><blockquote><p>本题是个模拟题，还是有难度的，因为相对来说比较绕</p></blockquote><p>螺旋矩阵用肉眼观察是比较好得出结论，但是用程序模拟还是需要费点功夫。</p><p>方法: 定义上下左右的边界，都是闭区间的。然后上下，或者左右边界不符合条件时，就要跳出循环</p><ol><li><p>————-&gt; 遍历条件是从最左边到最右边，遍历完后，这一行就没了，所以upper要+1,加1完之后要判断和down的关系决定是否要推出</p></li><li><p>遍历条件是从upper-&gt;down，在最右边，遍历完后，–right,减一之后还要判断和left的关系，决定是否要推出循环。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br>V<br></code></pre></td></tr></table></figure></li><li><p>遍历条件是从right到left<code>&lt;------------</code>，遍历完之后，down要减一，减一之后要和upper进行比对，判断。</p></li><li><p>遍历条件是从down到upper，遍历完之后，left要+1。加1之后再进行比对判断。</p></li></ol><h1 id="48-旋转矩阵"><a href="#48-旋转矩阵" class="headerlink" title="48. 旋转矩阵"></a><a href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=top-100-liked"><strong>48. 旋转矩阵</strong></a></h1><blockquote><p>矩阵的题目对我来说都有点难度，因为对模拟的要求比较高</p></blockquote><p>此题还算比较简单,因为只涉及到了两次交换,第一次是对称交换,对称交开始也没有写对，第二次循环应该是基于第一层循环来做。<br><code>for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; i; ++j)&#125;</code>,在循环体内要，j&lt;i 才是对的。 </p><h1 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked"><strong>240. 搜索二维矩阵 II</strong></a></h1><p>在一个排列有序的二维矩阵中搜索想要的字符是需要点技术的，不能从最小开始搜索，也不能从最大开始搜索。原因是如果从最小开始搜索<br>不符合条件有两个去处，那么此时就得再进行判断。也不能从最大开始搜索，原因是从最大开始搜索后，不满足题意也要从两个方向开始改动</p><p>因此需要找个不大不小的，所有要么是左上角，要么是右小角：</p><p>左上角：<br>相等则返回， 大于则排除一行，小于则排除一列，逐步往里缩小</p><p>右小角：<br>相等则返回，大于则排序一列，小于则排序最下面一行，逐步往里缩小</p><h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked"><strong>215. 数组中的第K个最大元素</strong></a></h1><p>[题目描述]：数组无序，有可能重复，求排序完后第K大的元素。要求：时间复杂度O(n)</p><p>解答：</p><ol><li>排序完后获取第K大的元素，时间复杂度不符合要求。</li><li>用优先队列，时间复杂度为<code>O(NlogK)</code>，不合题意</li><li>使用快排，时间复杂度平均情况下是<code>O(N)</code>,最坏的情况下可能达<code>O(N^2)</code></li></ol><p>因此此处采用快排的方式求解。快排是一个递归的过程，每次都要找到当前元素应该在的位置，即该位置左边的元素都大于等于此元素，右边的元素都小于等与此元素。至于该元素左边和右边的元素整体的顺序不做要求，比如有元素[4,10,3,4,5,6]，在经历了一次快排后，要求第一个元素4需要在其应该在的位置上。</p><p>一次快排的具体步骤：</p><ol><li>随机选取一个位置，也可以选择第一个，要求结束此次快排时，目标元素在其应该在的位置。</li><li>开始找目标元素的位置。<ol><li>从第二个元素到最后一个元素之间寻找</li><li>如果left所指向的元素大于等于目标元素，则不应该动left所指向的元素，我们最后的目标就是大于等于目标元素的元素在左边。</li><li>如果left所指向的元素小于等于目标元素，则也不应该动right所指向的元素，理由同上。</li><li>最终left所指的元素是第一个小于目标元素的元素，或者是数组的最后一个位置，此时left的位置是无效的。</li><li>最终right所指的元素是第一个大于目标元素的元素，或者是指向第一个元素，此时right的位置是有效的。</li></ol></li><li>当跳出循环时，一定是l &gt; r，因为这是循环终止的条件，由于right是第一个大于目标元素的位置，所以目标元素可以与right进行交换，可以保证左变的元素都大于等于目标元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = left;<br>    <span class="hljs-type">int</span> l = left + <span class="hljs-number">1</span>, r = right;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[l] &gt;= nums[pivot]) l++;<br>        <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[r] &lt;= nums[pivot]) r--; <br>        <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[l], nums[r]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums[pivot], nums[r]);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>把所有过程串联起来</p><ol><li>首选需要不断的寻找，直到找到最后正确的位置。</li><li>如果位置比目标位置小，说明需要向右边找</li><li>如果位置比目标位置大，说明需要向左边找</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">Partition</span>(nums, l, r);<br>        <span class="hljs-keyword">if</span> (pos == k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[pos];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pos &lt; k - <span class="hljs-number">1</span>) l = pos + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = pos - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked"><strong>394. 字符串解码</strong></a></h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p>思路：</p><p>本题的本质是将字符串用分配率展开，比如如<code>3[a2[c]b]</code> 使用一次分配律-&gt; <code>3[accb]</code> 再使用一次分配律-&gt;<code>accbaccbaccb</code> </p><p>需要使用<strong>双栈结构</strong>来处理<strong>嵌套字符串</strong>重复模式。有<strong>字符串栈</strong>和<strong>数字栈</strong>两个</p><ul><li>数字栈用来存储每个 <strong><code>k[encoded_string]</code></strong> 结构中的重复次数 <strong><code>k</code></strong></li><li>字符串栈用来存储每个 <strong><code>k[encoded_string]</code></strong> 结构<strong>之前</strong>已经解码的字符串部分</li></ul><p>整个算法过程类似一个状态机的转换，根据不同的情况做不同的操作</p><p>遍历字符串，总共有以下几种可能：</p><ol><li>数字<ol><li>用num记录当前数字，因为有可能是十位数或者百位数，所以为 <code>num = num * 10 + (s[i] - &#39;0&#39;);</code></li></ol></li><li>字符<ol><li>用res记录当前的字符状态，如果是字符则拼接在后面。</li></ol></li><li>左括号<ol><li>碰到左括号时，前面一定会有数字和已经解码的字符串，如果左括号前就是数字，则默认解码的字符串为空</li><li>此时的数字代表着下一次要重复的字符串的次数，字符串代表的<code>pre_str</code>，后续要<code>pre_str +</code> </li><li>碰到左括号时，状态机要置空，接下来是单独的一层，<code>res</code>和<code>num</code>都置空</li></ol></li><li>右括号<ol><li>碰到右括号，说明需要展开了</li><li>把当前的字符串 *数字栈顶元素，这个是[]里面的处理逻辑，<code>res</code>代表的内层字符串，<code>str_top()</code>代表的外层字符串</li><li>字符串栈顶 + b的结果</li><li>记录当前字符串的情况</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; nums_st;<br>        stack&lt;string&gt; str_st;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        string res&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp;  s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>                res += s[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                nums_st.<span class="hljs-built_in">push</span>(num);<br>                str_st.<span class="hljs-built_in">push</span>(res);<br>                num = <span class="hljs-number">0</span>;<br>                res = <span class="hljs-string">&quot;&quot;</span>; <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> time = nums_st.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; time; ++i) &#123;<br>                    str_st.<span class="hljs-built_in">top</span>() += res;<br>                &#125;<br>                res = str_st.<span class="hljs-built_in">top</span>();<br>                nums_st.<span class="hljs-built_in">pop</span>();<br>                str_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/"><strong>347. 前 K 个高频元素</strong></a></h1><p>常规模拟题</p><ol><li>会自定义大顶堆（默认less），小顶堆（great）的比较函数</li><li>priority_queue不能使用迭代器，只能通过pop的循环方法不断循环跳出。</li><li>自定义的lambda比较函数不能做为类的成员函数，由于是自定义的比较函数，因此可以出现在任何地方。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; key_cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : nums) &#123;<br>            key_cnt[num]++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; rhs) &#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        &#125;;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; key_val : key_cnt) &#123;<br>            <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &lt; k) &#123;<br>                pq.<span class="hljs-built_in">push</span>(key_val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">auto</span>&amp; tmp = pq.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span> (tmp.second &lt; key_val.second) &#123;<br>                    pq.<span class="hljs-built_in">pop</span>();<br>                    pq.<span class="hljs-built_in">push</span>(key_val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">reserve</span>(k);<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/"><strong>42. 接雨水</strong></a></h1><p>方法一：单调栈</p><p>想想不是接雨水，而是填水泥。水泥会把坑填平，当水泥把坑填平时，高度就不变了。</p><p>需要<strong>左（栈顶元素的下一个元素）右（当前元素）</strong>以及<strong>中间柱子（栈顶元素）</strong>的高度才能计算得到最终的结果。</p><p><img src="/../pictures/729image.png" alt="image.png"><br>思路：</p><ol><li>从左到右遍历数组</li><li>如果栈不为空，并且栈顶元素大于等于当前元素，则可以接水了，栈顶元素就是中间的柱子。如果当前元素小于栈顶元素，则需要继续遍历</li><li>将中间的柱子pop出栈，如果此时栈为空，则break</li><li>否则则再次取栈顶元素，此时只用栈顶元素，求栈顶元素与当前元素的位置之差作为宽，高是两边柱子的较小值减去中间元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt;= height[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-type">int</span> bottom_h = height[st.<span class="hljs-built_in">top</span>()];<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) <br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> lens = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> hei = (<span class="hljs-built_in">min</span>(height[i], height[st.<span class="hljs-built_in">top</span>()]) - bottom_h);<br>                res += lens * hei;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/description/"><strong>739. 每日温度</strong></a></h1><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>参考<a href="https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=e0aee50f101b406f0d1414f984f3f5c0">灵神</a>的解答</p><p>方法一：右往左遍历</p><p><img src="/./pictures/729image.png" alt="image.png"></p><p>当遍历到5时，由于2比5小，所以2排除，3比5小，3也排除，6比5大，所以应该是6的下标减去5的下标得到目标答案。</p><p>既然在遍历到5时，把2和3排除掉了，那么2和3还有可能是5左边的元素的目标答案，显然不可能，由于5的存在，5左边的元素不会选择2和3作为比其大的天气的温度。</p><ul><li>栈中顺序有序</li><li>满足先近后出</li></ul><p>因此是此题用单调栈。</p><p>栈中元素保证严格递减，栈中存放的是下一个更大的数。</p><p>在此题中，栈中存储的应该是数组的下标，存储数组下标的好处一是可以直接用下标相减得到目标答案。二也可以通过下标的比较获得元素的大小。</p><ol><li>从右向左遍历</li><li>当栈顶元素<strong>小于等于</strong>当前当前元素时，需要将元素pop出来，最后跳出循环时，栈顶元素一定是大于当前元素的。</li><li>由于栈顶元素是大于当前元素的，所以将当前元素压榨是可以保证栈的单调性的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = temperatures.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[st.<span class="hljs-built_in">top</span>()] &lt;= temperatures[i]) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                res[i] = st.<span class="hljs-built_in">top</span>() - i;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二：从左到右遍历</p><p>从左到右遍历，栈中存储的元素是<strong>还没找到第一个大于它的元素</strong>，如果找到了，就将其pop出来。</p><ol><li>如果当前元素大于栈顶元素了，则需要更新栈顶元素的结果值。这里需要不断循环，直到栈顶元素小于等于当前元素，</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                res[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><aside>💡<p>及时去除无用数据</p><p>保证栈中数据有序</p></aside>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础能力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/posts/4049607742/"/>
    <url>/posts/4049607742/</url>
    
    <content type="html"><![CDATA[<p>单例模式是指整个程序（<strong>进程</strong>）中只有一个实例，这可以为程序提供一个<strong>唯一的全局控制点</strong></p><span id="more"></span><p>其目的主要在于控制实例的数量，提供全局唯一控制点，以及延迟实例化等。</p><p>在第一版中，只提供了简单的实现形式，还有指针，只能指针，递归奇异模式，将会在后续的版本中讲述。</p><p>通常用于如日志记录器或者线程池等类似的全局只需要有一个实例的场景下。其通常有饿汉式和懒汉式两种，这两种最本质的区别在于实例是什么时候创建的。即在<code>GetInstance</code>时是否已经创建了</p><ol><li>饿汉式是在程序开始时就创建，而不管后续在程序的运行过程中是否使用它。</li><li>懒汉式只在程序必须要创建的时候才创建，通常在调用 <code>GetInstance</code> 时才会创建。</li></ol><p>其优缺点到此显而易见，一个是资源利用效率，明显懒汉式要高，那懒汉式的缺点在于程序可能存在并发的问题（在C++11）中也解决了，C++11中保证了<code>static</code>变量的线程安全。</p><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><p>懒汉式的核心在于真正调用的时候才去创建这个实例。所以只需要在GetInstance中声明一个，并返回就可以。</p><p>需要主要的是，为防止实例被拷贝和赋值，应该将其赋值运算符和拷贝构造函数都声明为<code>delete</code>，然后默认构造函数要么由编译器提供，要么是由程序员自己提供。</p><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton1</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton1</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton1</span>(<span class="hljs-type">const</span> Singleton1&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton1&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton1&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Singleton1</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Singleton1 destructed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton1&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 在getInstance内创建的，属于懒汉式</span><br>        <span class="hljs-type">static</span> Singleton1 obj;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        Singleton1::getInstance();</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;singleton1 add is &quot;</span> &lt;&lt; &amp;Singleton1::getInstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        Singleton1::getInstance();</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;singleton2 add is &quot;</span> &lt;&lt; &amp;Singleton1::getInstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 输出</span><br>singleton2 add is <span class="hljs-number">0x5587e7cf6151</span><br>singleton1 add is <span class="hljs-number">0x5587e7cf6151</span><br>Singleton1 destructed<br></code></pre></td></tr></table></figure><p>以上用<code>static</code>实现的懒汉式的单例模式，在多线程下是线程安全的，因为C++11保证了<code>static</code>的变量在多线程访问下的线程安全性。</p><hr><p>以上是最经典，也是最简单的写法。可以将其变成指针的形式，指针的形式是非线程安全的，需要</p><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><p>饿汉式和懒汉式的区别在于变量的初始化时间，如果是在getInstance里初始化和声明的，则一定是懒汉式，如果不在，则一定是饿汉式，饿汉式一定是线程安全的，因为其初始化是在程序开始之前，这时候还没有加载其他的线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton2</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton2</span>(<span class="hljs-type">const</span> Singleton2&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton2&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton2&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">static</span> Singleton2 instance;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Singleton2</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Singleton2 destructed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton2&amp; <span class="hljs-title">getinstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Singleton2 Singleton2::instance;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;singleton2 add is &quot;</span> &lt;&lt; &amp;Singleton2::getinstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t4</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;singletion add is &quot;</span> &lt;&lt; &amp;Singleton2::getinstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br>t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br>t<span class="hljs-number">4.</span><span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">singleton2 add is <span class="hljs-number">0x55b795618151</span>singletion add is <br><span class="hljs-number">0x55b795618151</span><br>Singleton2 destructed<br></code></pre></td></tr></table></figure><p>虽然输出结果是乱序的，但是也能说明两个线程是打印的是一个实例，说明其是线程安全的。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何像高手一样阅读源码</title>
    <link href="/posts/2390246322/"/>
    <url>/posts/2390246322/</url>
    
    <content type="html"><![CDATA[<p>今天看了<a href="https://www.bilibili.com/video/BV1xgAteDE9d/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=e0aee50f101b406f0d1414f984f3f5c0">B站上的课程</a>讲如何阅读源码，觉得挺适合现在的我。</p><span id="more"></span><p>视频中从三个方面讲述如何阅读一个大型的代码库，分别是<strong>心理</strong>,<strong>哲学</strong>,<strong>技术</strong>三个方面</p><h1 id="心理"><a href="#心理" class="headerlink" title="心理"></a>心理</h1><ol><li><p>要勇敢，不要害怕去读代码</p></li><li><p>疑惑没有关系，要愿意去疑惑，如果有疑惑的话可以先跳过去。</p></li><li><p>要从多方面去考虑一个事情呢</p></li><li><p>要知道你明白了什么，不明白什么，要诚实。</p></li></ol><h1 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h1><ol><li><p>知道大脑运作的方式，知道脑科学的</p></li><li><p>你要明白你想看啥，而不是一故脑的的去看代码，不明确要懂啥东西。</p></li><li><p>你在实操上熟悉比你真正理解要重要的多</p></li></ol><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ol><li><p>知道数据结构和算法， 比如深度优先遍历等。</p></li><li><p>知道编程语言和编程技巧</p></li><li><p>在心里要有个思路如何去一一的探索代码。</p></li><li><p>在阅读代码的时候，要聚焦于程序员所写的东西，而不是程序运行时的顺序。</p></li></ol><hr><p>因此在后续阅读代码中</p><p>不要畏难，要大胆看，遇到不懂的也没关系，可以先跳过，不用拘谨于细节。读代码的时候，没必要从main函数开始看，因为这个时候很多都是程序加载所需要的东西，比如配置文件之类的，或者是根据不同的参数去走不同的通路，亦或者是根据平台的不同选择不同的方式，这些都不重要。</p><p>开始读之前一定要有个清晰的目标，我要看什么？比如我要看统排或者是扶持，亦或者是LSM tree中的某个细节，就针对细节去看。</p><p>其次就是coding，你真正的理解，真不如写上的熟悉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法笔记</title>
    <link href="/posts/2063046854/"/>
    <url>/posts/2063046854/</url>
    
    <content type="html"><![CDATA[<p>本文是在学习数据结构与算法的记录于思考，包括但不限于LeetCode，算法笔记，算法思想的记录……</p><span id="more"></span><h1 id="数据结构与算法之美"><a href="#数据结构与算法之美" class="headerlink" title="数据结构与算法之美"></a>数据结构与算法之美</h1><h2 id="递归-分治"><a href="#递归-分治" class="headerlink" title="递归&amp;分治"></a>递归&amp;分治</h2><p>递归：</p><p>递归的本质就是循环，只是与我们传统理解的<code>for</code>，<code>while</code>不同，其是用函数来进行循环。递归的实现和盗梦空间里的场景非常类似，可以在梦里再进入梦境，但是总归有梦醒的时候。所以之前的故事，从前有座山，山里有座庙，庙里有个和尚讲故事……，这是个死递归，因为没有递归返回的时候。</p><p>因此我们在编写递归程序的时候，一定要避免这种情况，一定要有递归跳出的时候。所以递归的模板总结如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  level 表示当前进入了递归的哪一层</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recuresion</span>(<span class="hljs-params">level, param1, param2, ...</span>)<br>    <span class="hljs-keyword">if</span> level &gt; MAX_LEVEL<br>        print_result()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-comment"># 当前层处理逻辑</span><br>    process_data(level, data...)<br>    <span class="hljs-comment"># 进入下一层</span><br>    <span class="hljs-variable language_">self</span>.recuresion(level + <span class="hljs-number">1</span>, p1, ...)<br><br>    <span class="hljs-comment"># 当前层如果需要一下后置处理</span><br>    reverse_state(level)<br></code></pre></td></tr></table></figure><p>分治：</p><p>分治需要将大问题分割成小问题，然后依次处理各个小问题，最后合并。思想比较简单，但是实现起来就没那么简单了，算法模板如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide_conquer</span>(<span class="hljs-params">problem, param1, param2, ...</span>)<br>    <span class="hljs-keyword">if</span> problem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        print_result()<br>        <span class="hljs-keyword">return</span><br>    <br>    data = process_data(problem)<br>    subproblems = spilt_problem(problem, data)<br><br>    subresult1 = <span class="hljs-variable language_">self</span>.divide_conquer(subproblems[<span class="hljs-number">0</span>], p1, p2, ...)<br>    subresult2 = <span class="hljs-variable language_">self</span>.divide_conquer(subproblems[<span class="hljs-number">1</span>], p1, p2, ...)<br>    subresult3 = <span class="hljs-variable language_">self</span>.divide_conquer(subproblems[<span class="hljs-number">2</span>], p1, p2, ...)<br>    <span class="hljs-comment"># ...</span><br><br>    result = process_result(subresult1, subresult2, subresult3, ...)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
