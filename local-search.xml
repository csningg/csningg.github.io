<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一个C++后端工程师的思考</title>
    <link href="/posts/1736571982/"/>
    <url>/posts/1736571982/</url>
    
    <content type="html"><![CDATA[<h2 id="大模型时代下的突围一名c后端工程师的未来5年技术进阶之路"><strong>大模型时代下的突围：一名C++后端工程师的未来5年技术进阶之路</strong></h2><p>在生成式AI（AIGC）席卷全球的今天，作为一名身处互联网核心业务线的C++开发工程师，我常常思考：代码生成的效率越来越高，传统的后端开发护城河在哪里？本文记录了我在负责大规模向量召回（ANN）工程中的思考，并制定了从“后台开发”向“AI Infra（人工智能基础设施）”转型的五年职业规划。 <span id="more"></span></p><h3 id="一-现状站在流量与算力的十字路口">一、 现状：站在流量与算力的十字路口</h3><p>目前，我身处国内一线互联网大厂的核心商业化部门，主要负责<strong>搜推系统中的召回（Recall）环节</strong>，特别是基于<strong>ANN（近似最近邻搜索）</strong>的工程落地。</p><p>简单来说，我的工作是在毫秒级的时间限制内，从亿级海量数据中快速“捞”出最匹配用户意图的内容。这看似是一个常规的后端工作，但其实它正处于两个时代的交汇点： 1. <strong>传统高并发时代</strong>：我们需要极致的C++性能优化，处理极高的QPS（每秒查询率），对内存管理、锁竞争、指令集优化有着苛刻的要求。 2. <strong>AI大模型时代</strong>：随着Embedding技术的普及和大模型的落地，向量检索成为了连接海量数据与大模型的“神经突触”。</p><p>虽然目前的工作稳定且处于核心链路，但我深知：<strong>单纯写业务逻辑的C++代码，在未来5年内极易被AI替代或被更低成本的人力取代。</strong> 唯有向下深挖底层算力，向上拥抱AI架构，才能建立真正的不可替代性。</p><h3 id="二-思考为什么选择ai-infra作为方向">二、 思考：为什么选择“AI Infra”作为方向？</h3><p>在恐慌“被大模型取代”之前，我意识到一个事实：<strong>淘金热中，卖铲子的人永远不会失业。</strong></p><p>大模型（LLM）虽然强大，但它有三个致命弱点：<strong>贵、慢、记性差</strong>。 * <strong>贵与慢</strong>：推理成本高，不可能对所有数据进行全量推理。 * <strong>记性差</strong>：模型有Token限制，且无法实时更新知识。</p><p>解决这些问题的核心方案是 <strong>RAG（检索增强生成）</strong>，而RAG的核心引擎就是<strong>向量数据库（Vector Database）</strong>。</p><p>我目前所从事的ANN工程，正是向量数据库的雏形。因此，我的职业护城河不在于“写C++”，而在于 <strong>“如何构建让大模型跑得更快、更便宜、更准的基础设施”</strong>。这就是<strong>AI Infra</strong>。</p><h3 id="三-规划切实可行的五年进阶路径">三、 规划：切实可行的五年进阶路径</h3><p>为了实现从“C++功能开发”到“AI系统架构师”的转型，我将未来5年划分为三个阶段：</p><h4 id="第一阶段第1-2年极致性能优化hpc-筑基">第一阶段（第1-2年）：极致性能优化（HPC）—— 筑基</h4><p>这一阶段的目标是成为团队内的“性能压舱石”。不仅仅是会用Faiss或HNSWlib，而是要具备手写核心算子的能力。</p><ul><li><strong>行动方案：</strong><ul><li><strong>深耕SIMD指令集</strong>：熟练掌握AVX2/AVX-512指令集，在向量距离计算（L2/IP/Cosine）中榨干CPU的每一个时钟周期。</li><li><strong>内存友好的编程</strong>：深入理解CPU Cache Line、False Sharing和NUMA架构。在召回场景中，Cache Miss是最大的性能杀手，我要做的就是让数据在CPU缓存中“流淌”起来。</li><li><strong>无锁编程</strong>：在高并发场景下，精通C++ Memory Order，减少上下文切换带来的开销。</li></ul></li></ul><h4 id="第二阶段第2-4年拥抱异构计算与存储-破圈">第二阶段（第2-4年）：拥抱异构计算与存储 —— 破圈</h4><p>随着向量维度的膨胀（大模型Embedding通常在1024维以上），纯CPU计算已成瓶颈。这一阶段的关键是<strong>跨越CPU与GPU的鸿沟</strong>。</p><ul><li><strong>行动方案：</strong><ul><li><strong>掌握CUDA编程</strong>：这是我职业生涯最关键的转型。学习如何利用GPU的大规模并行能力加速向量检索（如RAPIDS RAFT）。</li><li><strong>探索存算分离</strong>：研究DiskANN等技术，利用NVMe SSD替代昂贵的内存来存储索引。在降本增效的大背景下，谁能帮公司节省50%的服务器成本，谁就是核心人才。</li><li><strong>理解量化技术</strong>：深入研究PQ（乘积量化）、SQ甚至Binary Quantization。如何把浮点向量压缩成int8甚至二进制位而不损失精度，是工程与算法结合的黄金领域。</li></ul></li></ul><h4 id="第三阶段第5年及以后ai架构师与云原生-统筹">第三阶段（第5年及以后）：AI架构师与云原生 —— 统筹</h4><p>此时，我的目标不再是单一模块的优化，而是设计能够支撑千亿级数据、服务于大模型的通用检索架构。</p><ul><li><strong>行动方案：</strong><ul><li><strong>构建RAG基础设施</strong>：设计支持混合检索（关键词+向量）的系统，解决大模型落地的“最后一公里”问题。</li><li><strong>分布式系统深造</strong>：深入Raft/Paxos协议，解决大规模分布式向量库的一致性与高可用问题。</li><li><strong>开源影响力</strong>：尝试向Milvus、Faiss等开源社区贡献代码，建立行业影响力。</li></ul></li></ul><h3 id="四-结语做技术的长期主义者">四、 结语：做技术的长期主义者</h3><p>互联网行业充满了不确定性，裁员的阴云也时常笼罩。但技术发展的底层逻辑是不变的：<strong>对算力的渴求无止境，对效率的追求无止境。</strong></p><p>在未来的五年里，我不会把自己定义为一个“写C++广告后台的人”，而是一个<strong>“专注高性能计算与异构系统的AI Infra工程师”</strong>。</p><p>大模型不是我们的敌人，它是我们施展拳脚的舞台。只要掌握了驾驭算力和数据的底层能力，无论技术风口如何变幻，我们都能在时代的洪流中站稳脚跟。 <strong>路虽远，行则将至。</strong></p><h2 id="具体学习路线">具体学习路线</h2><p>这是一个非常硬核的转型路线，市面上普通的“C++速成班”或者“AI应用开发课”已经没有意义了。你需要的是<strong>计算机科学殿堂级的底层课程</strong>。</p><p>为了让你在广告召回（Ad Recall）和ANN工程方向达到“不可替代”的级别，以下精选了全球顶尖大学的计算机系（CS）公开课。请按照以下四个模块进行系统学习：</p><hr /><h3 id="模块一内功心法计算机体系结构与极致性能">模块一：内功心法——计算机体系结构与极致性能</h3><p><strong>目标</strong>：理解代码如何在硬件上运行，榨干CPU的每一个时钟周期。这是做高性能召回引擎的基石。</p><ol type="1"><li><strong>CMU 15-213: Introduction to Computer Systems (CSAPP)</strong><ul><li><strong>学校</strong>：卡内基梅隆大学 (CMU)</li><li><strong>教材</strong>：《Computer Systems: A Programmer’s Perspective》（深入理解计算机系统）</li><li><strong>为什么学</strong>：这是所有高性能开发者的“圣经”。它会教你理解内存层次结构（Memory Hierarchy）、缓存（Cache）、链接、异常控制流。</li><li><strong>针对你工作的应用</strong>：你会明白为什么你的ANN索引在内存里布局不同，查询延迟会差10倍（Cache Miss）。</li></ul></li><li><strong>MIT 6.172: Performance Engineering of Software Systems</strong><ul><li><strong>学校</strong>：麻省理工学院 (MIT)</li><li><strong>教授</strong>：Charles Leiserson (算法大神)</li><li><strong>为什么学</strong>：这门课专门教你怎么把C/C++代码优化到极致。涉及向量化（SIMD/AVX）、并行编程、内存优化、分支预测。</li><li><strong>针对你工作的应用</strong>：广告召回对延迟极度敏感，这门课教你的技术能直接用于优化距离计算函数（L2/IP Distance）。</li></ul></li></ol><hr /><h3 id="模块二核心武器异构计算与cuda编程">模块二：核心武器——异构计算与CUDA编程</h3><p><strong>目标</strong>：跨越CPU到GPU的鸿沟。这是你未来5年最大的涨薪点和护城河。</p><ol type="1"><li><strong>UIUC ECE 408 / CS 483: Applied Parallel Programming</strong><ul><li><strong>学校</strong>：伊利诺伊大学厄巴纳-香槟分校 (UIUC)</li><li><strong>教材</strong>：《Programming Massively Parallel Processors》（大规模并行处理器编程实战）——作者是大神 David Kirk (NVIDIA) 和 Wen-mei Hwu。</li><li><strong>为什么学</strong>：这是CUDA编程的入门与进阶经典。它不是教你调包，而是教你GPU的内存模型（Global/Shared/Constant Memory）、线程束（Warp）调度。</li><li><strong>针对你工作的应用</strong>：当你需要把Faiss的CPU索引迁移到GPU，或者优化GPU版本的Brute-force搜索时，这门课是必修的。</li></ul></li><li><strong>NVIDIA 官方文档与博客 (CUDA C++ Best Practices Guide)</strong><ul><li><strong>来源</strong>：NVIDIA Developer Zone</li><li><strong>为什么学</strong>：没有任何课程比官方文档更新。你需要关注最新的架构（如Hopper/Blackwell）特性。</li></ul></li></ol><hr /><h3 id="模块三系统架构数据库与分布式系统">模块三：系统架构——数据库与分布式系统</h3><p><strong>目标</strong>：从“写算法”升级为“造数据库”。现在的向量检索本质上就是数据库技术。</p><ol type="1"><li><strong>CMU 15-445/645: Database Systems</strong><ul><li><strong>学校</strong>：CMU</li><li><strong>教授</strong>：Andy Pavlo (数据库领域的网红教授，讲课极好)</li><li><strong>为什么学</strong>：不要以为这是讲SQL的。它讲的是<strong>存储引擎</strong>：Buffer Pool Management（缓冲池管理）、Index Structrues（索引结构）、Concurrency Control（并发控制）。</li><li><strong>针对你工作的应用</strong>：当你研究<strong>DiskANN</strong>（把向量索引存SSD）时，你会发现这其实就是数据库的Buffer Pool技术。这门课能让你看懂Milvus或Elasticsearch的底层源码。</li></ul></li><li><strong>MIT 6.824: Distributed Systems</strong><ul><li><strong>学校</strong>：MIT</li><li><strong>教授</strong>：Robert Morris</li><li><strong>为什么学</strong>：分布式系统的巅峰之作。深入讲解MapReduce, Raft, Paxos, Spanner等。</li><li><strong>针对你工作的应用</strong>：百度的广告库是亿级别的，单机存不下。如何做分布式的向量检索引擎？如何保证多副本一致性？这门课给你答案。</li></ul></li></ol><hr /><h3 id="模块四领域专精ann与大模型">模块四：领域专精——ANN与大模型</h3><p><strong>目标</strong>：理解你的业务和你的“客户”（算法组）。</p><ol type="1"><li><strong>Paper Reading (无特定课程，需自学)</strong><ul><li><strong>必读论文</strong>：<ul><li><strong>HNSW</strong>: <em>Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs</em> (当前工业界主流)</li><li><strong>DiskANN</strong>: <em>DiskANN: Fast Accurate Billion-point Nearest Neighbor Search on a Single Node</em> (微软出的，降本增效核心)</li><li><strong>SPANN</strong>: <em>SPANN: Highly-efficient Billion-scale Approximate Nearest Neighbor Search</em> (阿里出的)</li></ul></li><li><strong>为什么学</strong>：这是你工作的直接理论依据。</li></ul></li><li><strong>Stanford CS224n: Natural Language Processing with Deep Learning</strong><ul><li><strong>学校</strong>：斯坦福</li><li><strong>为什么学</strong>：了解Embedding是怎么来的，了解Transformer架构。</li><li><strong>针对你工作的应用</strong>：你不需要会训练模型，但你需要知道模型输出的向量有什么特性（分布是否均匀？是否稀疏？），这决定了你该选什么索引算法。</li></ul></li></ol><hr /><h3 id="学习路线图建议边工作边学">学习路线图建议（边工作边学）</h3><p>这是一场马拉松，建议按以下顺序攻克：</p><ul><li><strong>第1-6个月（夯实基础）</strong>：<ul><li>重点攻克 <strong>CMU 15-213 (CSAPP)</strong>。买书看，做Lab（尤其是Malloc Lab和Cache Lab）。</li><li>工作中结合 <strong>MIT 6.172</strong> 的知识点，尝试分析现有代码的Cache Miss率。</li></ul></li><li><strong>第6-12个月（突击GPU）</strong>：<ul><li>开始看 <strong>《Programming Massively Parallel Processors》</strong>。</li><li>申请一台带GPU的开发机，手写一个简单的向量加法和矩阵乘法Kernel，对比cuBLAS的性能。</li></ul></li><li><strong>第2年（架构升级）</strong>：<ul><li>刷 <strong>CMU 15-445</strong>。</li><li>开始阅读 <strong>Faiss</strong> 和 <strong>HNSWlib</strong> 的源码，尝试把学到的数据库知识（如内存管理）映射进去。</li></ul></li></ul><p><strong>切记：</strong> 这一行，<strong>源码面前，了无秘密</strong>。课程是指路灯，最后还是要回到GitHub上去啃优秀的开源项目（Faiss, Milvus, Velox）。加油！</p>]]></content>
    
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSAG框架概述</title>
    <link href="/posts/3838167042/"/>
    <url>/posts/3838167042/</url>
    
    <content type="html"><![CDATA[<h1 id="vsag-an-optimized-search-framework-for-graph-based-approximate-nearest-neighbor-search">VSAG: An Optimized Search Framework for Graph-based Approximate Nearest Neighbor Search</h1><p>VSAG 是对现有图算法（Graph-based ANNS）的一套<strong>全方位工业级优化方案</strong>。本文是对这篇论文的解读与思考！ <span id="more"></span></p><p><a href="https://www.vldb.org/pvldb/vol18/p5017-cheng.pdf">论文</a>介绍了一个名为 <strong>VSAG (Vector Search Algorithm Graph)</strong> 的开源框架，由蚂蚁集团（Ant Group）开发 。核心目标是解决当前主流的基于图的近似最近邻搜索（ANNS）算法（如 HNSW）在<strong>生产环境</strong>中面临的性能瓶颈。尽管 HNSW 等基于图的算法在召回率和性能上表现优异，但在大规模生产环境中存在三大痛点：</p><ol type="1"><li><strong>随机内存访问导致的高延迟：</strong> 图遍历需要在内存中随机跳转，导致 CPU 的 L3 缓存未命中率（Cache Miss Rate）极高，严重拖慢速度。</li><li><strong>距离计算开销大：</strong> 高维向量的距离计算非常消耗 CPU 资源。</li><li><strong>调参成本过高：</strong> 图索引对参数（如最大度数、候选集大小）非常敏感。传统调参需要反复重建索引，耗时极长（可能需要数天），导致很多系统只能使用次优参数。</li></ol><p>针对以上三个问题，论文依次提出了解决方案。</p><h2 id="三大设计优化">三大设计优化</h2><h3 id="内存访问优化">内存访问优化</h3><p>这是 VSAG 最底层的创新，旨在让“随机”的图搜索变得对 CPU 缓存更友好，实现方式是两点：</p><ul><li><p><strong>确定性访问贪婪搜索 (Deterministic Access Greedy Search)：</strong> 传统的贪婪搜索是串行的（计算一个-&gt;取下一个）。VSAG 将其改为<strong>批量处理</strong>，对邻居节点进行分组，并利用软件预取（Software Prefetching）技术，在计算当前节点距离时，提前将下一个节点的数据加载到缓存中。</p></li><li><p><strong>部分冗余存储 (PRS - Partial Redundant Storage)：</strong> VSAG 设计了一种特殊的存储结构。它不仅存储节点本身，还将该节点的<strong>压缩后的邻居向量</strong>直接冗余存储在节点旁边。</p><ul><li><strong>作用：</strong> 这样一来，访问某个节点的邻居时，内存访问就从“随机跳转”变成了“顺序读取”。这激活了 CPU 的 <strong>硬件预取（Hardware Prefetching）</strong> 机制，极大降低了缓存未命中率。</li><li><strong>平衡：</strong> 引入了参数 <span class="math inline"><em>δ</em></span>（冗余比率）来平衡内存占用和 CPU 效率。<span class="math inline"><em>δ</em> = 1</span>时全冗余（速度最快，费内存），<span class="math inline"><em>δ</em> = 0</span> 时无冗余（省内存）</li></ul></li></ul><h3 id="自动参数调优">自动参数调优</h3><p>VSAG 不需要用户手动痛苦地调参，也不需要为了调参反复重建索引。</p><ul><li><strong>基于“掩码/标签”的索引压缩技术：</strong> VSAG 先用较宽松的参数构建一个“大索引”，并在每条边上打上标签（Label），标记这条边在不同参数下是否应该存在。</li><li><strong>免重建调优：</strong> 在调优或搜索时，只需根据标签过滤边，就能模拟出不同参数构建的索引效果。这使得<strong>索引级参数（Index-level Parameters）</strong> 的调优时间从“数天”缩短为“几乎即时” 。</li><li><strong>查询级自适应：</strong> 使用决策树模型判断查询的难易程度，动态调整搜索时的候选集大小（<span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span>）。简单的查询少搜点，复杂的查询多搜点。</li></ul><h3 id="距离计算加速">距离计算加速</h3><ul><li><strong>标量量化 (Scalar Quantization, SQ) + SIMD：</strong> 将浮点向量压缩（如 SQ4/SQ8），利用 AVX-512 指令集并行计算，大幅减少计算量。</li><li><strong>距离分解 (Distance Decomposition)：</strong> 预先计算向量的模长（Norm）并缓存，将欧氏距离计算简化为内积运算，减少实时计算指令。</li><li><strong>选择性重排序 (Selective Re-rank)：</strong> 先用低精度（量化后）向量快速筛选出一批候选者，再对其中极少部分进行高精度重算，兼顾了速度和准确率。</li></ul><h2 id="整体流程">整体流程</h2><p><img src="/pictures/20250523/11.25/image.png" /> $$ Figure 1 展示了 <strong>VSAG（Vector Search Algorithm Graph）</strong> 的整个搜索框架流程。它将整个搜索过程分为了三个主要阶段：<strong>存储（Partial Redundant Storage）</strong>、<strong>搜索执行（Deterministic Access Greedy Search）</strong> 和 <strong>结果优化（Selective Re-rank）</strong>，同时贯穿了自动参数调优。</p><p>以下是对这张图的<strong>分步详细解释</strong>：</p><p><strong>第一步：部分冗余存储</strong></p><p>这是 VSAG 的数据存储基础，旨在优化内存访问效率。</p><ul><li><strong>混合存储结构 (Redundant vs. Flat):</strong> 图中展示了两种存储状态。<ul><li><strong>Original Vector (蓝色):</strong> 存储原始的高精度向量数据。</li><li><strong>Redundant Neighbors (绿色):</strong> 这是核心设计。VSAG 将某个节点的<strong>邻居向量</strong>（压缩后的）直接冗余存储在该节点旁边。</li><li><strong><span class="math inline"><em>δ</em> = 0.5</span> (Redundancy Ratio):</strong> 这是一个调节参数。图中 <span class="math inline"><em>δ</em> = 0.5</span>表示只有 50% 的数据采用了冗余存储（Redundant Storage），剩下的 50% 采用普通存储（Flat Storage)。这是一种在“内存占用”和“计算速度”之间取得平衡的机制。</li></ul></li><li><strong>Code Layout (数据布局):</strong> 放大镜展示了邻居节点具体存了什么：<ul><li><strong>Quantized Code:</strong> 量化后的低精度向量代码（例如 4-bit 量化），用于快速计算。</li><li><strong>Id:</strong> 邻居的 ID。</li><li><strong>Norm:</strong> 预先计算好的向量模长，用于加速距离计算（距离分解技术）。</li><li><strong>Metric Transform:</strong> 距离变换逻辑。</li></ul></li></ul><p><strong>第二步：确定性访问贪婪搜索</strong></p><p>这是搜索执行的核心阶段，主要解决图搜索中“内存随机访问”导致的 Cache Miss 问题。</p><ul><li><strong>Async Prefetch During Computing (计算时异步预取):</strong> 顶部的框图展示了流水线工作模式。当 CPU 正在计算当前向量的量化代码（Q Code Computing）时，利用空闲带宽同时<strong>预取（Prefetching）</strong> 下一批需要的数据到缓存中。</li><li><strong>Only Prefetch Valid Neighbors (只预取有效邻居):</strong> 中间的 <span class="math inline"><em>x</em><sub>1</sub></span>到 <span class="math inline"><em>x</em><sub>10</sub></span> 序列展示了过滤逻辑。算法会先剔除掉那些已经访问过的或者被剪枝的邻居（图中 <span class="math inline"><em>x</em><sub>2</sub>, <em>x</em><sub>3</sub></span>被跳过），只对有效的邻居进行预取和计算。</li><li><strong>Stride Prefetch (步长预取):</strong> 底部的箭头（例如从 <span class="math inline"><em>x</em><sub>1</sub></span>指向 <span class="math inline"><em>x</em><sub>6</sub></span>）展示了步长预取策略。为了防止数据还没加载进缓存 CPU 就要用，VSAG 会“看得很远”。例如，在计算 <span class="math inline"><em>x</em><sub>1</sub></span> 的距离时，它发出的指令是预取 <span class="math inline"><em>x</em><sub>6</sub></span> 的数据（步长为 5），从而掩盖内存延迟。</li></ul><p><strong>第三步：选择性重排序</strong></p><p>这一步是为了弥补第二步中使用“低精度量化向量”带来的精度损失。</p><ul><li><strong>Result Push Heap (结果入堆):</strong> 第二步计算出的邻居节点会被推入一个结果堆中。</li><li><strong>Low vs. High Precision:</strong><ul><li>在搜索过程中使用低精度（Quantized Code）快速筛选。</li><li>只有通过筛选的少量优质候选项，才会回读原始向量（Original Vector）进行高精度距离计算（即 Re-rank），确保最终结果准确。</li></ul></li><li><strong>Pop Heap and Visit:</strong> 底部蓝色的长箭头表示循环。从堆中弹出当前最近的节点，回到左侧 PRS 读取它的邻居，开始下一轮搜索 。</li></ul><p><strong>第四步：自动参数调优</strong></p><p>在整个框架运行过程中，有一个自动调优器在持续工作。</p><ul><li><strong>三层参数 (Environment/Query/Index):</strong> 图例展示了 VSAG 针对三个层级的参数进行自动化管理<ul><li><strong>Index-level:</strong> 如图的最大度数，通过“掩码”技术在不重建索引的情况下动态调整。</li><li><strong>Query-level:</strong> 如搜索时的候选集大小 (<span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span>)，根据查询难度动态调整。</li><li><strong>Environment-level:</strong> 如预取步长 (<span class="math inline"><em>ω</em></span>)，根据硬件环境自动调整。</li></ul></li></ul><p>VSAG 不是一种全新的图算法结构，而是一个针对图算法的“生产级加速器”。它保留了图算法（如 HNSW）的高召回率特性，但通过魔改内存布局（PRS）解决了“缓存未命中”这一最大的性能杀手，并通过标签化索引解决了“调参难”的运维痛点。对于需要大规模部署向量数据库的企业来说，VSAG 是比原生 HNSWlib 更高效、更可控的选择。</p><h2 id="优化细节">优化细节</h2><h3 id="内存优化">内存优化</h3><p>基于图的向量搜索由于存在随机内存访问模式，导致cache miss的概率较大。内存方案优化是解决cache miss问题，提出3点优化。</p><ul><li>利用<strong>软件预取</strong>提高缓存命中率（传统的图搜索模式也存在软件预取技术，VASG通过工程手段强化了软件预取技术）</li><li>优化<strong>搜索模式</strong>用于增强软件预取技术</li><li>优化索引的<strong>内存布局</strong>以高效利用软件预取</li></ul><p><strong>预取技术</strong></p><p><img src="/pictures/20250523/11.25/image%201.png" /></p><p>Figure 2 直观地展示了 VSAG 如何利用 <strong>软件预取</strong>（Software-based Prefetch)技术，将传统的“串行等待”内存访问模式优化为“并行流水线”模式，从而显著减少 CPU 的空转等待时间。</p><p>以下是详细的分步解释：</p><p><strong>图例说明</strong></p><ul><li><strong>橙色方块 (Fetch - Sync Operation):</strong> 代表<strong>同步的内存读取</strong>。在基准算法中，当 CPU 需要某个向量数据但缓存中没有时（Cache Miss），必须停下来等待数据从内存加载完毕，这会阻塞后续操作 。</li><li><strong>蓝色方块 (<span class="math inline"><em>τ</em>(<em>x</em>, <em>x</em><sub><em>q</em></sub>)</span> - Sync Operation):</strong> 代表<strong>同步的计算操作</strong>。这里指计算向量 <span class="math inline"><em>x</em></span>与查询向量 <span class="math inline"><em>x</em><sub><em>q</em></sub></span> 之间的距离（如欧氏距离)。</li><li><strong>绿色方块 (Prefetch - Async Operation):</strong> 代表<strong>异步的预取指令</strong>。这是 VSAG 引入的关键优化。它是一条告诉 CPU “提前把数据从内存拉到缓存”的指令，它在后台运行，<strong>不会阻塞</strong>当前的计算任务。</li></ul><p><strong>1. Baselines</strong></p><p>这是现有普通图搜索算法（如未优化的 HNSW）的执行流程：</p><ul><li><strong>模式：</strong> Fetch <span class="math inline">→</span> Compute <span class="math inline">→</span> Fetch <span class="math inline">→</span> Compute。</li><li><strong>过程：</strong><ol type="1"><li>先花时间取 <span class="math inline"><em>x</em><sub>1</sub></span> 的数据（橙色 Fetch）。</li><li>数据到了才能算 <span class="math inline"><em>x</em><sub>1</sub></span>的距离（蓝色 <span class="math inline"><em>τ</em></span>）。</li><li>算完后，再去花时间取 <span class="math inline"><em>x</em><sub>2</sub></span> 的数据（橙色 Fetch）。</li><li>数据到了再算 <span class="math inline"><em>x</em><sub>2</sub></span> 的距离…</li></ol></li><li><strong>缺陷：</strong> 这种串行模式导致 CPU 频繁陷入等待。每当处理一个新邻居节点，CPU 都要停下来等内存数据（即图中橙色方块占用的时间），导致了大量的时间浪费。</li></ul><p><strong>2. VSAG 的优化方案</strong></p><p>这是 VSAG 采用软件预取后的执行流程，核心在于<strong>将“取数据”的时间重叠在“算数据”的时间里</strong>：</p><ul><li><strong><span class="math inline"><em>t</em><sub>1</sub></span> (初始加载):</strong> 处理第一个节点 <span class="math inline"><em>x</em><sub>1</sub></span> 时，不可避免地需要先从内存获取数据（Fetch）。</li><li><strong><span class="math inline"><em>t</em><sub>2</sub></span> (并行流水线 - 关键点):</strong><ul><li>CPU 开始计算 <span class="math inline"><em>x</em><sub>1</sub></span> 的距离（蓝色块）。</li><li><strong>与此同时</strong>，VSAG 发出了一条异步指令 <code>Prefetch x2</code>（绿色块），让内存控制器在后台去加载下一个节点 <span class="math inline"><em>x</em><sub>2</sub></span> 的数据 。</li><li>因为预取是异步的，它没有打断 <span class="math inline"><em>x</em><sub>1</sub></span> 的计算，两者并行发生。</li></ul></li><li><strong><span class="math inline"><em>t</em><sub>3</sub></span> (无缝衔接):</strong><ul><li>当 CPU 准备处理 <span class="math inline"><em>x</em><sub>2</sub></span> 时，由于在 <span class="math inline"><em>t</em><sub>2</sub></span> 阶段已经提前发出了预取请求，<span class="math inline"><em>x</em><sub>2</sub></span> 的数据此时已经加载到了 L3 缓存中 。</li><li>因此，CPU <strong>不需要</strong>像 Baseline 那样执行橙色的 <code>Fetch</code> 等待，而是直接开始计算 x_2 的距离。</li><li>同时，利用计算 <span class="math inline"><em>x</em><sub>2</sub></span> 的这段时间，再次预取下一个节点 <span class="math inline"><em>x</em><sub>3</sub></span>。</li></ul></li><li><strong><span class="math inline"><em>t</em><sub>4</sub></span>:</strong> 同样，<span class="math inline"><em>x</em><sub>3</sub></span> 的数据也已就绪，直接进行计算。</li></ul><p><strong>结论:</strong></p><p>通过这种“吃着碗里的（计算当前），看着锅里的（预取下一个）”的策略，VSAG 成功消除了 <span class="math inline"><em>x</em><sub>2</sub></span> 和 <span class="math inline"><em>x</em><sub>3</sub></span> 的内存读取等待时间。</p><ul><li><strong>效果：</strong> 如右下角所示，原本 Baseline 需要 6 个时间片（<span class="math inline"><em>t</em><sub>1</sub></span> 到 <span class="math inline"><em>t</em><sub>6</sub></span>）才能完成的任务，VSAG 仅用了 4 个时间片（<span class="math inline"><em>t</em><sub>1</sub></span> 到 <span class="math inline"><em>t</em><sub>4</sub></span>）就完成了，节省了 <span class="math inline"><em>t</em><sub>5</sub></span> 和 <span class="math inline"><em>t</em><sub>6</sub></span> 。</li><li>这解释了为什么 VSAG 能大幅降低 L3 Cache Miss Rate 并提升 QPS。</li></ul><h3 id="确定性贪婪访问">确定性贪婪访问</h3><p><img src="/pictures/20250523/11.25/image%202.png" /></p><p>软件预取有一定的局限性，比如在图 3(a) 中，<span class="math inline"><em>x</em><sub>2</sub></span> 和 <span class="math inline"><em>x</em><sub>3</sub></span> 已经被访问过，不需要重新计算距离。这使得对这些向量的预取变得无效。此外，在计算 <span class="math inline"><em>x</em><sub>4</sub></span> 时，由于预取间隔太短，预取也可能会失败。</p><h4 id="确定性访问">确定性访问</h4><p>VSAG 只预取那些尚未被访问过的边。该机制首先批量处理所有邻居节点以确定它们的访问状态。随后，未被访问的邻居被逻辑分组，并进行<strong>集体预取</strong>。这种战略性方法确保了每个预取的内存地址仅对应于计算必需的数据，从而提高了预取效率，并最大程度地减少了冗余内存操作。</p><h4 id="步长预取">步长预取</h4><p>批量处理确保了每次预取的数据都供未来使用。然而，由于预取的异步性质以及缺乏确认预取完成的回调机制，预取的有效性各不相同。最佳性能发生在所需数据正好在计算流要求时驻留在缓存中。过早预取有被缓存驱逐的风险，而延迟预取则会抵消性能增益。这需要平衡预取时机和计算持续时间。为了解决这个问题，步长预取动态地将硬件计算吞吐量与软件预取速率对齐，从而最大化预取效用。关键参数，预取步长 <span class="math inline"><em>ω</em></span>，决定了在每次预取前发生多少个计算步骤。调整 <span class="math inline"><em>ω</em></span> 至关重要，在后续，我们提出了一个自动选择其最优值的策略。</p><p>如图 3(b) 所示，调整后的模式表明在批量处理期间，确定性访问策略消除了访问 <span class="math inline"><em>x</em><sub>2</sub></span> 和 <span class="math inline"><em>x</em><sub>3</sub></span> 的需要。因此，搜索逻辑从 <span class="math inline"><em>x</em><sub>1</sub></span> 直接推进到 <span class="math inline"><em>x</em><sub>4</sub></span>。这种序列修改使得预取机制能够在计算 <span class="math inline"><em>x</em><sub>1</sub></span> 时瞄准 <span class="math inline"><em>x</em><sub>4</sub></span>。图 3(c) 进一步揭示了异步预取的时间特性：数据加载过程需要两个向量计算周期才能填充缓存行。当 <span class="math inline"><em>x</em><sub>1</sub></span> 的计算开始时，只能预取 <span class="math inline"><em>x</em><sub>4</sub></span> 向量。在 <span class="math inline"><em>x</em><sub>1</sub></span> 和 <span class="math inline"><em>x</em><sub>4</sub></span> 的计算之后，步长预取策略确保了 <span class="math inline"><em>x</em><sub>6</sub></span> 数据的及时缓存填充，这些数据可立即用于后续计算。</p><h3 id="确定性贪婪访问伪码">确定性贪婪访问伪码</h3><p><img src="/pictures/20250523/11.25/image%203.png" /></p><p>从表面上看，这段代码与标准的基于图的近似最近邻搜索（如 HNSW）中的贪婪搜索逻辑非常相似。<strong>然而，VSAG 的全部性能提升和设计优势，都隐藏在算法中关键操作的底层实现细节中。</strong></p><p><strong>1. 算法概述与标准流程</strong> 该算法描述了在 VSAG 构建的图索引 (<span class="math inline"><em>G</em></span>) 上，从一个入口点开始搜索，最终找到最接近查询向量 (<span class="math inline"><em>q</em></span>) 的 L 个候选者（即 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span>）的过程。</p><ul><li><strong>初始化（Lines 1-3）：</strong> 从预先确定的入口点 <span class="math inline"><em>e</em></span> 开始搜索。将 <span class="math inline"><em>e</em></span> 加入到两个优先级队列：<ul><li><span class="math inline"><em>C</em></span> (Candidate Pool)：最终候选集，大小限制为 L。</li><li><span class="math inline"><em>W</em></span> (Working Queue)：待探索节点集合，用于驱动搜索。</li></ul></li><li><strong>主循环（Lines 4-14）：</strong> 只要 <span class="math inline"><em>W</em></span> 中还有未探索的节点，就继续循环。</li><li><strong>探索（Line 5）：</strong> 从 <span class="math inline"><em>W</em></span> 中取出当前离查询向量 <span class="math inline"><em>q</em></span> 最近的节点 <span class="math inline"><em>x</em><sub><em>c</em></sub></span>。</li></ul><p><strong>VSAG 核心优化实现（三层加速）</strong> VSAG 的三大优化（内存、计算、调参）都被嵌入在主循环内部（Lines 6-14）的操作中：</p><p><strong>优化 A：内存访问加速 (Deterministic Access &amp; PRS)</strong></p><p>VSAG 针对图搜索的随机内存访问模式进行了改造，尽管伪代码是线性循环，但底层实现是并行的。</p><ul><li><strong>邻居获取（Line 6）：</strong> 获取 <span class="math inline"><em>x</em><sub><em>c</em></sub></span> 的所有邻居 <span class="math inline"><em>N</em>(<em>x</em><sub><em>c</em></sub>)</span>。<ul><li><strong>PRS 机制：</strong> 在实际实现中，由于 <strong>PRS（部分冗余存储）</strong> 的内存布局，当程序访问 <span class="math inline"><em>x</em><sub><em>c</em></sub></span> 的数据时，其部分邻居的压缩向量（<span class="math inline"><em>Q</em><sub><em>x</em><sub><em>i</em></sub></sub></span>）已经被 <strong>硬件预取器</strong> 自动加载到 Cache 中了。</li></ul></li><li><strong>批量处理与预取（Lines 7-14 的实际实现）：</strong><ul><li>在执行循环前，VSAG 会先将所有<strong>有效</strong>邻居（未访问且未被剪枝）收集成一个批次。</li><li>在计算 <span class="math inline"><em>x</em><sub><em>j</em></sub></span> 的距离时，底层实现会利用 <strong>软件预取（Stride Prefetch）</strong> 指令，同时异步加载下一个批次中 <span class="math inline"><em>x</em><sub><em>j</em> + <em>ω</em></sub></span> 的数据。这实现了计算与内存 I/O 的重叠（如图 Figure 2 所示）。</li></ul></li></ul><p><strong>优化 B：计算加速 (Low-Precision Distance)</strong></p><p>距离计算是高维搜索中的 CPU 瓶颈。VSAG 在 <strong>Line 10</strong> 的距离计算 <span class="math inline"><em>d</em><sub><em>c</em>, <em>j</em></sub></span> 中应用了加速技术：</p><ul><li><strong>低精度计算：</strong> 这里的距离计算使用的不是原始的高精度（Float32）向量，而是 <strong>PRS 中存储的低精度量化代码（Quantized Code）</strong>。这极大减少了计算量。</li><li><strong>距离分解与 SIMD：</strong> 实际的距离函数还使用了<strong>距离分解</strong>（预先计算 <span class="math inline">||<em>y</em>||<sup>2</sup></span>）来简化欧氏距离的计算，并利用 <strong>SIMD</strong> 指令（如 AVX-512）进行高度并行计算，进一步提高 <span class="math inline"><em>d</em><sub><em>c</em>, <em>j</em></sub></span> 的计算速度。</li></ul><p><strong>优化 C：自动参数调优 (Self-Tuned Parameters)</strong> 算法中的两个关键参数和判断条件都受到了 VSAG 自动调优机制的动态影响：</p><ul><li><strong>动态 L（Line 13）：</strong><ul><li>L 是最终候选集 C 的大小限制（对应于 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span> 参数）。在传统算法中这是固定的。</li><li>在 VSAG 中，这个参数由 <strong>查询级参数调优 (QLP)</strong> 机制控制。QLP 使用一个 GBDT 决策树模型，根据查询 <span class="math inline"><em>q</em></span> 的难度<strong>动态调整 <span class="math inline"><em>L</em></span> 的值</strong>。简单的查询会设置较小的 <span class="math inline"><em>L</em></span>，困难的查询会设置较大的 L，以平衡召回率和速度。</li></ul></li><li><strong>动态剪枝条件（Line 8）：</strong><ul><li><span class="math inline">IsPruned(<em>x</em><sub><em>j</em></sub>)</span> 判断邻居 <span class="math inline"><em>x</em><sub><em>j</em></sub></span> 是否应该被剪枝。</li><li>这个判断结合了 <strong>索引级参数调优 (ILP)</strong> 机制。VSAG 在建图时给每条边打了标签，<strong><span class="math inline">IsPruned</span> 函数在运行时根据标签动态过滤边</strong>，模拟不同的索引结构，避免了耗时的索引重建。</li></ul></li></ul><p><strong>总结</strong> 尽管算法 1 的骨架是经典的贪婪搜索，但 VSAG 赋予了其中关键操作全新的、高效的实现：</p><table><thead><tr class="header"><th><strong>伪代码行数</strong></th><th><strong>对应操作</strong></th><th><strong>VSAG 的底层优化</strong></th><th><strong>目的</strong></th></tr></thead><tbody><tr class="odd"><td>Line 6</td><td>获取邻居列表</td><td><strong>PRS 内存布局</strong></td><td>触发硬件预取，减少 Cache Miss</td></tr><tr class="even"><td>Line 8</td><td>检查是否剪枝</td><td><strong>ILP (索引标签过滤)</strong></td><td>动态调优索引参数，无需重建</td></tr><tr class="odd"><td>Line 10</td><td>计算距离 <span class="math inline"><em>d</em><sub><em>c</em>, <em>j</em></sub></span></td><td><strong>量化计算、距离分解、SIMD</strong></td><td>降低 CPU 消耗，提速</td></tr><tr class="even"><td>Line 13</td><td>限制候选集大小 L</td><td><strong>QLP (动态 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span> 模型)</strong></td><td>根据查询难度自适应，平衡性能和精度</td></tr></tbody></table><p>VSAG 的性能优势正是来源于这种<strong>系统工程级</strong>的集成优化，将内存访问、计算加速和参数自适应完美地嵌入到了这个基本的图遍历流程中。</p><h2 id="部分冗余存储">部分冗余存储</h2><p>虽然将精心设计的预取模式整合到搜索过程中理论上可以提高性能，但基于软件的预取的固有局限性阻止了对所有所需向量的内存可用性提供保证。这种现象归因于多个基本限制： - 预取指令仍然是建议性操作而非强制性命令。即使实施了最佳预取模式，它们的实际执行也无法保证。</p><ul><li>缓存行争用是另一个严峻挑战。在多进程环境中，激进的预取策略可能通过过早的数据加载导致 L3 缓存污染。</li><li>预取机制之间固有的成本差异进一步加剧了这些问题。与硬件实现的替代方案相比，基于软件的预取操作成本更高，效率也更低。</li></ul><p>即<strong>软件预取</strong> 存在三大不足：1. 不可靠（非强制性）。2. 可能导致 缓存污染。3. 效率低于硬件预取。针对这三个问题，我们提出了以下优化</p><h3 id="基于硬件的预取">基于硬件的预取</h3><p>基于硬件的预取依赖于硬件机制，这些机制自适应地从缓存未命中事件中学习，以预测内存访问模式。系统采用一个训练缓冲区，动态识别重复的数据访问序列，自动将预期数据预取到缓存层次结构中。与软件控制的预取相比，这种硬件方法表现出更好的运行时效率，同时在架构层面透明运行。训练机制对于顺序内存访问模式尤其有效，它可以快速检测和利用顺序内存访问特性。这种优化对于空间分区索引结构，如基于倒排文件（IVF）的索引结构特别有益，因为属于同一分区的向量保持连续的存储分配。相反，基于图的索引架构表现出不规则的访问模式，空间局部性差，导致随机内存访问效率低下。访问序列固有的随机性阻止了训练缓冲区建立有效的模式识别模型。</p><h4 id="redundantly-storing-vectors冗余存储向量">Redundantly Storing Vectors（冗余存储向量）</h4><p>VSAG 通过冗余向量存储将空间分区索引的优势整合到基于图的索引算法中。通过在每个节点的数据结构中将邻居列表与其对应的向量共同定位，实现了顺序内存访问。这种设计确保了邻居检索操作只需要在连续内存区域内进行顺序访问，从而充分利用了硬件预取能力。</p><p>如图 1 所示，考虑 10 个连续存储在内存中的向量。即使在访问 <span class="math inline"><em>x</em><sub>1</sub></span> 到 <span class="math inline"><em>x</em><sub>5</sub></span> 且 <span class="math inline"><em>x</em><sub>2</sub></span> 和 <span class="math inline"><em>x</em><sub>3</sub></span> 不是立即需要的情况下，硬件预取器仍然可以主动将 <span class="math inline"><em>x</em><sub>4</sub></span> 加载到缓存中。这种行为源于将相邻向量（<span class="math inline"><em>x</em><sub>1</sub></span> 到 <span class="math inline"><em>x</em><sub>5</sub></span>）存储在连续内存地址中所创建的内存局部性。一致的内存布局和可预测的访问模式通过硬件优化，有效地弥补了基于软件的预取效率低下的问题。</p><h4 id="balance-of-computational-efficiency-and-memory-utilization计算效率与内存利用的平衡">Balance of Computational Efficiency and Memory Utilization（计算效率与内存利用的平衡）</h4><p>为了解决工业应用中固定实例规格（例如 4 核 16G，2 核 8G）导致的计算-内存资源不平衡，我们提出了 PRS，以利用硬件预取来减少 CPU 空闲时间。一个可动态调整的冗余比率 <span class="math inline"><em>δ</em></span> 控制了图中冗余存储的邻居向量的比例，平衡了预取效率和 CPU 利用率。当 <span class="math inline"><em>δ</em> = 1</span> 时，完全冗余最大化硬件预取效益，以更高的内存消耗为代价实现峰值 CPU 利用率。相反，当 <span class="math inline"><em>δ</em> = 0</span> 时，消除冗余以最小化内存使用，但牺牲了预取效率。这种灵活性实现了对工作负载感知的资源优化。 <img src="/pictures/20250523/11.25/image4.png" /></p><p>对于高吞吐量/高召回率场景（图 4 (a)），将 <span class="math inline"><em>δ</em></span> 增加到 1 优先考虑 CPU 效率，以更少的计算资源满足苛刻的目标。在内存受限、吞吐量要求适中的环境（图 4 (b)）中，将 <span class="math inline"><em>δ</em></span> 减少到 0 减轻了内存压力，同时允许实例降配（例如 4 核 16G 降至 2 核 8G），通过受控的计算扩展来保持服务质量并降低基础设施成本。</p><p>PRS (Partial Redundant Storage) 是 VSAG 解决内存访问瓶颈的终极策略，它利用 <strong>硬件预取</strong> 的高效率来弥补软件预取的不足。</p><p>方法： 通过在每个节点的数据结构中冗余存储邻居的压缩向量（共同定位），在物理内存中创造出顺序访问模式。效益： 这种顺序模式激活了 CPU 的硬件预取器，实现自动、高效地将邻居数据加载到缓存，彻底解决了基于图的 ANNS 算法中随机内存访问效率低下的问题。灵活性： 引入了可动态调整的冗余比率 <span class="math inline"><em>δ</em></span>，允许用户根据实际的硬件配置和业务需求（如高吞吐 vs 内存受限）来灵活平衡内存消耗和计算效率。</p><h2 id="距离加速计算">距离加速计算</h2><p>最近的研究表明，精确距离计算占据了基于图的 ANNS 算法的大部分时间成本。近似距离技术，例如标量量化（Scalar Quantization），可以加速这一过程，但代价是搜索准确性降低。VSAG 采用两阶段方法：首先执行近似距离搜索，然后进行精确距离重排序（re-ranking）。节分析了距离计算方案，后续章节详细介绍了 VSAG 组件的优化策略。</p><h3 id="distance-computation-cost-analysis距离计算成本分析">Distance Computation Cost Analysis（距离计算成本分析）</h3><p>VSAG 在图遍历操作期间使用低精度向量，同时将精确距离计算专门保留给最终结果的重排序。这种双精度架构通过精度感知的层次化处理，有效地最小化了距离计算操作（DCO）的开销，同时保持了搜索准确性。</p><p>如果我们只考虑距离计算产生的成本，总距离计算成本可以表示为：<br /><span class="math display">总成本 = 低精度成本 + 高精度成本 = 低精度计算次数 ⋅ 单次低精度成本 + 高精度计算次数 ⋅ 单次高精度成本</span><br /></p><p><span class="math inline"><em>n</em><sub><em>l</em><em>p</em></sub></span>（低精度计算次数）的优化与具体的算法工作流程密切相关，而 <span class="math inline"><em>t</em><sub><em>h</em><em>p</em></sub></span>（单次高精度成本）主要由 <span class="math inline">FLOAT32</span> 向量操作的计算成本决定——这两者都相对恒定。</p><p>因此，VSAG 框架主要侧重于优化参数 <span class="math inline"><strong>t</strong><sub><strong>l</strong><strong>p</strong></sub></span>（单次低精度成本）和 <span class="math inline"><strong>n</strong><sub><strong>h</strong><strong>p</strong></sub></span>（高精度计算次数）。</p><p>VSAG 通过三种方式优化总成本： - （优化 <span class="math inline"><strong>t</strong><sub><strong>l</strong><strong>p</strong></sub></span>） 量化技术、硬件指令集 SIMD 和内存高效存储的结合实现了单次低精度距离计算的指数级降低。</p><ul><li>（优化 <span class="math inline"><strong>n</strong><sub><strong>l</strong><strong>p</strong></sub></span>） 通过参数优化增强量化精度，减轻了精度损失导致的候选集膨胀，实现了所需低精度计算的次线性增长。</li><li>（优化 <span class="math inline"><strong>n</strong><sub><strong>h</strong><strong>p</strong></sub></span>） 具有动态阈值的选择性重排序建立了准确性和效率的平衡，将高精度验证限制在对数级规模的候选子集。</li></ul><h3 id="最小化低精度计算开销">最小化低精度计算开销</h3><p>现代 CPU 采用 SIMD 指令集（SSE/AVX/AVX512）通过向量化操作来加速距离计算。这些指令并行处理 128 位、256 位或 512 位数据块，结合向量压缩技术可以同时处理多个向量。例如，AVX512 每条指令可以计算一个 16 维 <span class="math inline">FLOAT32</span> 向量的距离，但当将向量压缩到 128 位时，它通过并行处理四个向量对实现 4 倍加速</p><p>乘积量化 (PQ) 通过 SIMD 加载的查找表，为批量处理实现了高压缩比。虽然 PQ-Fast Scan 在基于分区的搜索中通过块式计算表现出色，但由于图基搜索中随机的向量存储模式和无法过滤已访问节点，导致其有效性降低，造成 SIMD 带宽浪费。相比之下，标量量化 (SQ) 通过直接压缩向量维度（例如 <span class="math inline">FLOAT32</span> 降至 <span class="math inline">INT8/INT4</span>）且不需要查找表，被证明更适合图算法。正如 VSAG 所示，SQ 在压缩比和精度保持之间实现了最佳平衡，同时充分利用了 SIMD 加速能力，使其对于内存受限的图遍历尤其有效。</p><p><strong>Distance Decomposition（距离分解）</strong></p><p>VSAG 通过解耦静态和动态分量来优化欧氏距离计算。系统在数据库索引期间预先计算和缓存不变的向量范数 (<span class="math inline">∥<strong>x</strong><sub><strong>b</strong></sub>∥<sup>2</sup></span>)，然后在查询期间将它们与实时的点积计算结合。这种分解减少了操作复杂性，同时保留了数学上的等价性，如重构的欧氏距离公式所示： <br /><span class="math display">∥<strong>x</strong><sub><strong>b</strong></sub> − <strong>x</strong><sub><strong>q</strong></sub>∥<sup>2</sup> = ∥<strong>x</strong><sub><strong>b</strong></sub>∥<sup>2</sup> + ∥<strong>x</strong><sub><strong>q</strong></sub>∥<sup>2</sup> − 2<strong>x</strong><sub><strong>b</strong></sub> ⋅ <strong>x</strong><sub><strong>q</strong></sub></span><br /></p><p>计算优化策略可总结为：在搜索操作期间，只有内积项 <span class="math inline"><strong>x</strong><sub><strong>b</strong></sub> ⋅ <strong>x</strong><sub><strong>q</strong></sub></span> 需要实时计算，而平方查询范数 <span class="math inline">∥<strong>x</strong><sub><strong>q</strong></sub>∥<sup>2</sup></span> 可以在启动搜索过程之前离线预计算。通过为每个数据库向量 <span class="math inline"><strong>x</strong><sub><strong>b</strong></sub></span> 仅存储一个额外的 <span class="math inline">FLOAT32</span> 值（即预计算的 <span class="math inline">∥<strong>x</strong><sub><strong>b</strong></sub>∥<sup>2</sup></span>），我们可以有效地将计算成本高昂的欧氏距离计算转化为等效的内积操作。这种时空权衡减少了距离计算中的减法 CPU 指令，节省了一个 CPU 时钟周期。</p><h3 id="selective-re-rank选择性重排序">Selective Re-rank（选择性重排序）</h3><p>量化方法可以显著提高检索效率，但量化误差可能导致召回率大幅下降。虽然使用全精度向量进行重排序可以减轻这种性能损失，但对所有候选者进行详尽的重排序效率低下。VSAG 框架通过选择性重排序来应对这一挑战，在不牺牲系统性能的情况下有效地补偿了距离计算中的近似误差。 一种简单的方法是仅选择那些低精度距离较小的候选者进行重排序。然而，需要重排序的最佳候选者数量会根据查询特性、量化误差分布和搜索要求 <span class="math inline"><em>k</em></span> 发生显著变化。为了解决这种动态需求，VSAG 实现了 DDC 方案，该方案可以基于误差-距离相关性分析自动调整重排序范围。</p><h3 id="小结">小结</h3><p>VSAG 通过 双精度架构 和 三项核心优化 来加速距离计算，目标是最小化 单次低精度成本 (<span class="math inline"><strong>t</strong><sub><strong>l</strong><strong>p</strong></sub></span>) 和 高精度重算次数 (<span class="math inline"><strong>n</strong><sub><strong>h</strong><strong>p</strong></sub></span>)。</p><ul><li><p>最小化 <span class="math inline"><strong>t</strong><sub><strong>l</strong><strong>p</strong></sub></span> (单次低精度成本)：量化选择： 采用标量量化 (SQ)，因其无查找表的特性，比 PQ 更适合于基于图的随机访问模式。</p></li><li><p>硬件加速： 充分利用 SIMD（如 AVX512）指令集的向量化能力，对压缩后的数据进行并行计算。</p></li><li><p>距离分解： 将欧氏距离公式重构为 <span class="math inline"><strong>∥</strong><strong>x</strong><sub><strong>b</strong></sub><strong>∥</strong><sup><strong>2</strong></sup> <strong>+</strong> <strong>∥</strong><strong>x</strong><sub><strong>q</strong></sub><strong>∥</strong><sup><strong>2</strong></sup> <strong>−</strong> <strong>2</strong><strong>x</strong><sub><strong>b</strong></sub> <strong>⋅</strong> <strong>x</strong><sub><strong>q</strong></sub></span>。通过预计算 <span class="math inline"><strong>∥</strong><strong>x</strong><sub><strong>b</strong></sub><strong>∥</strong><sup><strong>2</strong></sup></span> 和 <span class="math inline"><strong>∥</strong><strong>x</strong><sub><strong>q</strong></sub><strong>∥</strong><sup><strong>2</strong></sup></span>，将昂贵的欧氏距离计算转化为高效的内积操作，节省 CPU 时钟周期。</p></li><li><p>最小化 <span class="math inline"><strong>n</strong><sub><strong>h</strong><strong>p</strong></sub></span> (高精度重算次数)：选择性重排序： 实现了 DDC 方案，根据查询的动态特性和量化误差分布，自动确定需要进行高精度验证的候选集大小。</p></li></ul><p>这确保了只对最有可能影响最终召回率的少量候选集使用昂贵的高精度计算，从而在精度和效率之间取得最佳平衡。</p><h2 id="参数自动寻优">参数自动寻优</h2><p>VSAG 的调优策略是分层的，针对不同类型的参数使用了不同的方法，其中一个核心部分就是基于模型的<strong>查询级参数调优（QLP）</strong>。</p><p>以下是 VSAG 三层参数调优的详细解释，重点介绍集成的模型：</p><h3 id="查询级参数调优-qlp集成了-gbdt-决策树模型">1. 查询级参数调优 (QLP)：集成了 GBDT 决策树模型</h3><p>查询级参数（Query-level Parameters, QLP）主要指的是搜索时的<strong>候选集大小 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span></strong>（在伪代码中是 <span class="math inline"><em>L</em></span>）。这个参数对查询速度和召回率的影响最大。</p><ul><li><strong>问题：</strong> 不同的查询向量（Query Vector）搜索难度差异巨大。对简单的查询使用很大的 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span> 会浪费时间；对困难的查询使用很小的 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span> 会牺牲召回率。</li><li><strong>VSAG 的解决方案：</strong> <strong>训练一个轻量级的分类器，实时判断查询的难度，动态调整 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span>。</strong></li></ul><p><strong>模型细节：</strong></p><ol type="1"><li><strong>使用的模型：</strong> <strong>GBDT (Gradient Boosting Decision Tree，梯度提升决策树)。</strong> 论文选择 GBDT 是因为它计算速度快、模型小巧，适合在低延迟的搜索路径中实时推理。</li><li><strong>训练目标：</strong> 模型的目标是预测一个查询是“简单”还是“困难”，或者更细致地分为 <span class="math inline"><em>k</em></span> 个难度等级。</li><li><strong>特征工程：</strong> 模型使用在搜索初期阶段（前几跳）就能获取到的<strong>局部特征</strong>作为输入，例如：<ul><li><strong>当前候选集的距离分布：</strong> 候选者之间的距离方差、最大最小值。</li><li><strong>距离变化率：</strong> 上一轮和本轮最远距离的变化。</li><li><strong>节点连通度：</strong> 当前探索的节点的度数等。</li></ul></li><li><strong>动态调整：</strong><ul><li>当模型预测当前查询属于“简单”类别时，系统会动态地将 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span> 设置为一个较小的值 (<span class="math inline"><em>L</em><sub><em>m</em><em>i</em><em>n</em></sub></span>)，提前结束不必要的探索。</li><li>当模型预测为“困难”类别时，系统会增大 <span class="math inline"><em>e</em><em>f</em><sub><em>s</em></sub></span> (<span class="math inline"><em>L</em><sub><em>m</em><em>a</em><em>x</em></sub></span>)，允许算法探索更多的邻居，以确保高召回率。</li></ul></li></ol><h3 id="索引级参数调优-ilp基于标签的免重建技术非模型">2. 索引级参数调优 (ILP)：基于“标签”的免重建技术（非模型）</h3><p>索引级参数（Index-level Parameters, ILP）如最大度数 <span class="math inline"><em>M</em></span>、建图时的候选集大小 <span class="math inline"><em>e</em><em>f</em><sub><em>c</em><em>o</em><em>n</em><em>s</em><em>t</em><em>r</em><em>u</em><em>c</em><em>t</em><em>i</em><em>o</em><em>n</em></sub></span> 等。调整这些参数传统上需要<strong>重建整个图索引</strong>。</p><ul><li><strong>问题：</strong> 重建索引非常耗时（如 GIST1M 需要数十小时）。</li><li><strong>VSAG 的解决方案：</strong> <strong>基于“标签”的虚拟索引技术，实现参数调优的“免重建”。</strong></li></ul><p><strong>技术细节：</strong></p><ol type="1"><li><strong>一次性构建：</strong> VSAG 只用一套<strong>最宽松</strong>的参数（例如最大的 <span class="math inline"><em>M</em></span>）构建一次索引。</li><li><strong>边标签（Edge Labeling）：</strong> 在构建过程中，VSAG 不会物理删除那些被剪枝的边。相反，它会给每条边打上一个<strong>标签（Label）</strong>，记录这条边在多严格的剪枝条件下会被保留。</li><li><strong>动态过滤：</strong> 在搜索阶段，用户可以动态设置一个<strong>虚拟参数</strong>。系统会根据这个虚拟参数，实时地在图遍历时<strong>过滤掉</strong>那些标签不满足要求的边。</li><li><strong>结论：</strong> 这是一种<strong>工程优化</strong>而非机器学习模型，它将原本需要大量时间进行 I/O 操作（重建索引）的调优过程，转化为了极快的<strong>内存内数据过滤</strong>操作。</li></ol><h3 id="环境级参数调优-elp基于网格搜索非模型">3. 环境级参数调优 (ELP)：基于网格搜索（非模型）</h3><p>环境级参数（Environment-level Parameters, ELP）主要与底层硬件和运行环境相关，例如 <strong>软件预取步长 <span class="math inline"><em>ω</em></span></strong>。</p><ul><li><strong>问题：</strong> 不同的 CPU 架构、缓存大小、内存带宽，其最优的预取步长 <span class="math inline"><em>ω</em></span> 是不同的。</li><li><strong>VSAG 的解决方案：</strong> <strong>离线网格搜索（Grid Search）。</strong></li></ul><p><strong>技术细节：</strong></p><ol type="1"><li><strong>测试：</strong> 在索引构建完毕后，VSAG 在一个预定义的参数网格中，运行少量的测试查询，系统性地尝试 <span class="math inline"><em>ω</em></span> 的不同取值。</li><li><strong>评估：</strong> 评估哪个 <span class="math inline"><em>ω</em></span> 值能带来最高的 QPS（即最低的 L3 Cache Miss Rate）。</li><li><strong>锁定：</strong> 一旦找到最优的 <span class="math inline"><em>ω</em></span> 值，就将其锁定为当前运行环境的配置参数。</li></ol><p>这同样是一种<strong>系统配置自动化</strong>的方法，不依赖复杂的机器学习模型，但能确保底层硬件的效率得到最大化。</p><h2 id="vsag-测试性能">VSAG 测试性能</h2><p>相比于目前工业界标准的 <strong>HNSWlib</strong> 和 Facebook 的 <strong>Faiss</strong>，VSAG 的优势主要体现在以下几个方面：</p><p><strong>显著的性能提升 (高达 4 倍 QPS)</strong></p><p>在相同的召回率（Recall）下，VSAG 的吞吐量（QPS）显著高于 HNSWlib。</p><ul><li><strong>数据：</strong> 在 GIST1M 数据集上，同等精度下 VSAG 比 HNSWlib 快 <strong>4倍</strong> 。</li><li><strong>原因：</strong> HNSWlib 的 L3 Cache Miss 率通常高达 90% 以上，而 VSAG 通过 PRS 和预取技术将其降低到了 <strong>39%</strong> 左右。</li></ul><p><strong>“免重建”的参数自适应</strong></p><ul><li><strong>存量痛点：</strong> 在 HNSWlib 中，如果你想调整图的连通度（M）来优化性能，你必须重新插入所有数据重建索引。</li><li><strong>VSAG 优势：</strong> VSAG 可以在不重建索引的情况下，通过“边过滤”动态调整索引结构参数。对于拥有十亿级向量的生产系统，这节省了数小时甚至数天的运维时间。</li></ul><p><strong>更好的资源利用率平衡</strong></p><ul><li><strong>存量痛点：</strong> 传统算法通常受限于机器规格（例如 4核16G），经常出现 CPU 跑满但内存空闲，或者内存满了 CPU 却在空转。</li><li><strong>VSAG 优势：</strong> 通过 PRS 的冗余比率 <span class="math inline"><em>δ</em></span>，VSAG 可以根据机器的实际硬件（计算型 vs 内存型实例）灵活调整。如果是计算型机器，增加冗余以换取速度；如果是内存受限机器，减少冗余以节省空间。</li></ul><p><strong>对高维数据的处理更优</strong></p><ul><li><strong>VSAG 优势：</strong> 针对 OpenAI 等大模型生成的 1536 维 embedding，VSAG 的量化和距离优化表现尤为突出。实验显示在 OpenAI 数据集上，VSAG 提供了比 HNSWlib 高约 400% 的 QPS 16。</li></ul>]]></content>
    
    
    <categories>
      
      <category>向量数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>向量检索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准库的常用算法</title>
    <link href="/posts/2498300446/"/>
    <url>/posts/2498300446/</url>
    
    <content type="html"><![CDATA[<p>本文记录在阅读代码中遇到的std中常用的算法，在此做个总结记录 <span id="more"></span> # C++ 常用算法函数详解</p><h2 id="目录">目录</h2><ol type="1"><li><a href="#stdany_of">std::any_of</a></li><li><a href="#stdfill">std::fill</a></li><li><a href="#stdreverse">std::reverse</a></li><li><a href="#stdrotate">std::rotate</a></li><li><a href="#综合示例">综合示例</a></li></ol><h2 id="stdany_of">std::any_of</h2><h3 id="功能">功能</h3><p>检查范围内是否至少有一个元素满足谓词条件，注意此处的谓词一般可以用lambda表达式表示，（初次使用时在lc中检查某行元素是否含有0）</p><h3 id="原型">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> InputIt, <span class="hljs-keyword">class</span> UnaryPredicate &gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">any_of</span><span class="hljs-params">( InputIt first, InputIt last, UnaryPredicate p )</span></span>;<br></code></pre></td></tr></table></figure><h3 id="示例">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>    <br>    <span class="hljs-comment">// 检查是否存在偶数</span><br>    <span class="hljs-type">bool</span> hasEven = std::<span class="hljs-built_in">any_of</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(),<br>                              [](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Contains even number: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; hasEven &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 检查是否存在大于10的数</span><br>    <span class="hljs-type">bool</span> hasLarge = std::<span class="hljs-built_in">any_of</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(),<br>                               [](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">10</span>; &#125;);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Contains number &gt; 10: &quot;</span> &lt;&lt; hasLarge &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stdfill">std::fill</h2><h3 id="功能-1">功能</h3><p>将指定范围内的所有元素设置为给定值，这个第3个参数是T类型的值，初次使用时在lc中将某行元素全部置0</p><h3 id="原型-1">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><h3 id="示例-1">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">numbers</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建包含5个元素的vector</span><br>    <br>    <span class="hljs-comment">// 将所有元素填充为42</span><br>    std::<span class="hljs-built_in">fill</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), <span class="hljs-number">42</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After fill: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : numbers) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 填充部分范围</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partial</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    std::<span class="hljs-built_in">fill</span>(partial.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>, partial.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">7</span>, <span class="hljs-number">99</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Partial fill: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : partial) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stdreverse">std::reverse</h2><h3 id="功能-2">功能</h3><p>反转指定范围内的元素顺序</p><h3 id="原型-2">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> BidirIt &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">( BidirIt first, BidirIt last )</span></span>;<br></code></pre></td></tr></table></figure><h3 id="示例-2">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 反转整数数组</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::<span class="hljs-built_in">reverse</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reversed numbers: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : numbers) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 反转字符串</span><br>    std::string text = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    std::<span class="hljs-built_in">reverse</span>(text.<span class="hljs-built_in">begin</span>(), text.<span class="hljs-built_in">end</span>());<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reversed string: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 反转部分范围</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; partial = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    std::<span class="hljs-built_in">reverse</span>(partial.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>, partial.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">6</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Partially reversed: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : partial) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stdrotate">std::rotate</h2><h3 id="功能-3">功能</h3><p>对范围内的元素进行循环<strong>左移</strong>操作,第二个参数是旋转后应该出现在起始原始位置的元素。具体功能可以背住</p><h3 id="原型-3">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt &gt;</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">rotate</span><span class="hljs-params">( ForwardIt first, ForwardIt n_first, ForwardIt last )</span></span>;<br></code></pre></td></tr></table></figure><h3 id="参数说明">参数说明</h3><ul><li><code>first</code>: 范围的起始位置</li><li><code>n_first</code>: 应该出现在旋转后范围起始位置的元素</li><li><code>last</code>: 范围的结束位置</li></ul><h3 id="示例-3">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    <br>    <span class="hljs-comment">// 将前3个元素移到末尾</span><br>    std::<span class="hljs-built_in">rotate</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, numbers.<span class="hljs-built_in">end</span>());<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After rotating left by 3: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : numbers) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 重置并演示右旋转（通过左旋转实现）</span><br>    numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    std::<span class="hljs-built_in">rotate</span>(numbers.<span class="hljs-built_in">rbegin</span>(), numbers.<span class="hljs-built_in">rbegin</span>() + <span class="hljs-number">3</span>, numbers.<span class="hljs-built_in">rend</span>());<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After rotating right by 3: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : numbers) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 使用rotate进行循环移位</span><br>    numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    <span class="hljs-keyword">auto</span> middle = numbers.<span class="hljs-built_in">begin</span>() + numbers.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>;<br>    std::<span class="hljs-built_in">rotate</span>(numbers.<span class="hljs-built_in">begin</span>(), middle, numbers.<span class="hljs-built_in">end</span>());<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Rotated around middle: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : numbers) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="综合示例">综合示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">bool</span> isStudent;<br>    <br>    <span class="hljs-built_in">Person</span>(std::string n, <span class="hljs-type">int</span> a, <span class="hljs-type">bool</span> s) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a), <span class="hljs-built_in">isStudent</span>(s) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Person&gt; people = &#123;<br>        <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-literal">true</span>),<br>        <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-literal">true</span>),<br>        <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Diana&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Eve&quot;</span>, <span class="hljs-number">17</span>, <span class="hljs-literal">true</span>)<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 使用any_of检查是否有未成年人</span><br>    <span class="hljs-type">bool</span> hasMinor = std::<span class="hljs-built_in">any_of</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(),<br>                               [](<span class="hljs-type">const</span> Person&amp; p) &#123; <span class="hljs-keyword">return</span> p.age &lt; <span class="hljs-number">18</span>; &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Has minors: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; hasMinor &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 使用fill重置所有年龄为0</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ages</span><span class="hljs-params">(people.size())</span></span>;<br>    std::<span class="hljs-built_in">transform</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), ages.<span class="hljs-built_in">begin</span>(),<br>                  [](<span class="hljs-type">const</span> Person&amp; p) &#123; <span class="hljs-keyword">return</span> p.age; &#125;);<br>    <br>    std::<span class="hljs-built_in">fill</span>(ages.<span class="hljs-built_in">begin</span>(), ages.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Ages after fill: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> age : ages) std::cout &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 使用reverse反转人员顺序</span><br>    std::<span class="hljs-built_in">reverse</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>());<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reversed order: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p : people) std::cout &lt;&lt; p.name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 使用rotate将学生移到前面</span><br>    <span class="hljs-keyword">auto</span> studentStart = std::<span class="hljs-built_in">stable_partition</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(),<br>                                            [](<span class="hljs-type">const</span> Person&amp; p) &#123; <span class="hljs-keyword">return</span> p.isStudent; &#125;);<br>    std::<span class="hljs-built_in">rotate</span>(people.<span class="hljs-built_in">begin</span>(), studentStart, people.<span class="hljs-built_in">end</span>());<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Students first: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; p : people) &#123;<br>        std::cout &lt;&lt; p.name &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; (p.isStudent ? <span class="hljs-string">&quot;student&quot;</span> : <span class="hljs-string">&quot;adult&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;) &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结表">总结表</h2><table><thead><tr class="header"><th>算法</th><th>功能</th><th>时间复杂度</th><th>适用容器</th></tr></thead><tbody><tr class="odd"><td><code>std::any_of</code></td><td>检查是否存在满足条件的元素</td><td>O(n)</td><td>所有序列容器</td></tr><tr class="even"><td><code>std::fill</code></td><td>填充范围内的元素</td><td>O(n)</td><td>所有序列容器</td></tr><tr class="odd"><td><code>std::reverse</code></td><td>反转元素顺序</td><td>O(n)</td><td>双向迭代器容器</td></tr><tr class="even"><td><code>std::rotate</code></td><td>循环移动元素</td><td>O(n)</td><td>前向迭代器容器</td></tr></tbody></table><h2 id="注意事项">注意事项</h2><ol type="1"><li><strong>迭代器有效性</strong>: 确保使用的迭代器范围有效</li><li><strong>谓词函数</strong>: 不应该修改元素（对于any_of等查询算法）</li><li><strong>性能</strong>: 所有算法都有线性时间复杂度</li><li><strong>容器要求</strong>: 不同算法对迭代器类型有不同要求<ul><li><code>any_of</code>: 输入迭代器</li><li><code>fill</code>: 前向迭代器</li><li><code>reverse</code>: 双向迭代器</li><li><code>rotate</code>: 前向迭代器</li></ul></li></ol><p>除此之外，在询问完GPT后，还有很多算法需要我们提前了解，在此mark下。 # C++ 常用算法函数大全</p><h2 id="目录-1">目录</h2><ol type="1"><li><a href="#非修改序列操作">非修改序列操作</a></li><li><a href="#修改序列操作">修改序列操作</a></li><li><a href="#划分操作">划分操作</a></li><li><a href="#排序操作">排序操作</a></li><li><a href="#二分搜索操作">二分搜索操作</a></li><li><a href="#集合操作">集合操作</a></li><li><a href="#堆操作">堆操作</a></li><li><a href="#最小最大操作">最小/最大操作</a></li><li><a href="#比较操作">比较操作</a></li><li><a href="#排列操作">排列操作</a></li><li><a href="#数值操作">数值操作</a></li></ol><h2 id="非修改序列操作">非修改序列操作</h2><h3 id="stdall_of">std::all_of</h3><p>检查是否所有元素都满足条件 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">bool</span> allEven = std::<span class="hljs-built_in">all_of</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p><h3 id="stdnone_of">std::none_of</h3><p>检查是否没有元素满足条件 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">bool</span> noneEven = std::<span class="hljs-built_in">none_of</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p><h3 id="stdfor_each">std::for_each</h3><p>对每个元素执行操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span>&amp; x) &#123; x *= <span class="hljs-number">2</span>; &#125;);<br><span class="hljs-comment">// v becomes &#123;2, 4, 6, 8&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdcount-stdcount_if">std::count / std::count_if</h3><p>计数满足条件的元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> count2 = std::<span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-type">int</span> countEven = std::<span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure></p><h3 id="stdfind-stdfind_if-stdfind_if_not">std::find / std::find_if / std::find_if_not</h3><p>查找元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>); <span class="hljs-comment">// 指向5的迭代器</span><br><span class="hljs-keyword">auto</span> evenIt = std::<span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;); <span class="hljs-comment">// v.end()</span><br></code></pre></td></tr></table></figure></p><h3 id="stdmismatch">std::mismatch</h3><p>查找两个序列中第一个不匹配的位置 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> mismatch = std::<span class="hljs-built_in">mismatch</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">// mismatch.first指向3，mismatch.second指向4</span><br></code></pre></td></tr></table></figure></p><h3 id="stdequal">std::equal</h3><p>检查两个序列是否相等 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">bool</span> equal = std::<span class="hljs-built_in">equal</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p><h3 id="stdsearch">std::search</h3><p>在序列中搜索子序列 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; pattern = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), pattern.<span class="hljs-built_in">begin</span>(), pattern.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// 指向第一个1的迭代器</span><br></code></pre></td></tr></table></figure></p><h2 id="修改序列操作">修改序列操作</h2><h3 id="stdcopy-stdcopy_if">std::copy / std::copy_if</h3><p>复制元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; src = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dst</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>std::<span class="hljs-built_in">copy</span>(src.<span class="hljs-built_in">begin</span>(), src.<span class="hljs-built_in">end</span>(), dst.<span class="hljs-built_in">begin</span>());<br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; evenNumbers;<br>std::<span class="hljs-built_in">copy_if</span>(src.<span class="hljs-built_in">begin</span>(), src.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(evenNumbers),<br>             [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><span class="hljs-comment">// evenNumbers = &#123;2, 4&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdmove">std::move</h3><p>移动元素（C++11） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::string&gt; src = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">dst</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>std::<span class="hljs-built_in">move</span>(src.<span class="hljs-built_in">begin</span>(), src.<span class="hljs-built_in">end</span>(), dst.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">// src中的字符串被移动到dst</span><br></code></pre></td></tr></table></figure></p><h3 id="stdtransform">std::transform</h3><p>对元素进行转换 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; squared;<br>std::<span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">back_inserter</span>(squared),<br>               [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;);<br><span class="hljs-comment">// squared = &#123;1, 4, 9, 16&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdgenerate">std::generate</h3><p>用生成函数填充序列 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>std::<span class="hljs-built_in">generate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [&amp;n]() &#123; <span class="hljs-keyword">return</span> n++; &#125;);<br><span class="hljs-comment">// v = &#123;0, 1, 2, 3, 4&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdremove-stdremove_if">std::remove / std::remove_if</h3><p>移除满足条件的元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">auto</span> newEnd = std::<span class="hljs-built_in">remove_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br>v.<span class="hljs-built_in">erase</span>(newEnd, v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// v = &#123;1, 3, 5&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdreplace-stdreplace_if">std::replace / std::replace_if</h3><p>替换元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">99</span>);<br><span class="hljs-comment">// v = &#123;1, 99, 3, 99, 5&#125;</span><br><br>std::<span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">3</span>; &#125;, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// v = &#123;1, 0, 3, 0, 0&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdswap_ranges">std::swap_ranges</h3><p>交换两个范围的元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>std::<span class="hljs-built_in">swap_ranges</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">// v1 = &#123;4, 5, 6&#125;, v2 = &#123;1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure></p><h2 id="划分操作">划分操作</h2><h3 id="stdpartition">std::partition</h3><p>将满足条件的元素划分到前面 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">partition</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><span class="hljs-comment">// 偶数在前，奇数在后</span><br></code></pre></td></tr></table></figure></p><h3 id="stdstable_partition">std::stable_partition</h3><p>保持相对顺序的划分 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">stable_partition</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><span class="hljs-comment">// 偶数在前（保持顺序），奇数在后（保持顺序）</span><br></code></pre></td></tr></table></figure></p><h3 id="stdpartition_point">std::partition_point</h3><p>查找划分点 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">partition_point</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><span class="hljs-comment">// 指向第一个奇数的迭代器</span><br></code></pre></td></tr></table></figure></p><h2 id="排序操作">排序操作</h2><h3 id="stdsort">std::sort</h3><p>排序 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// v = &#123;1, 2, 3, 4, 5&#125;</span><br><br><span class="hljs-comment">// 自定义比较</span><br>std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">// v = &#123;5, 4, 3, 2, 1&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdstable_sort">std::stable_sort</h3><p>稳定排序（保持相等元素的相对顺序） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; v = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>std::<span class="hljs-built_in">stable_sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure></p><h3 id="stdpartial_sort">std::partial_sort</h3><p>部分排序 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;;<br>std::<span class="hljs-built_in">partial_sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// 前3个是最小的，按顺序排列：&#123;1, 2, 3, ...&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdnth_element">std::nth_element</h3><p>将第n小的元素放在正确位置 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;;<br>std::<span class="hljs-built_in">nth_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>, v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// v[2]是第三小的元素，前面的元素都&lt;=它，后面的都&gt;=它</span><br></code></pre></td></tr></table></figure></p><h2 id="二分搜索操作">二分搜索操作</h2><h3 id="stdlower_bound">std::lower_bound</h3><p>查找第一个不小于给定值的元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><span class="hljs-comment">// 指向第一个4的迭代器</span><br></code></pre></td></tr></table></figure></p><h3 id="stdupper_bound">std::upper_bound</h3><p>查找第一个大于给定值的元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">upper_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><span class="hljs-comment">// 指向5的迭代器</span><br></code></pre></td></tr></table></figure></p><h3 id="stdequal_range">std::equal_range</h3><p>查找等于给定值的范围 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">auto</span> range = std::<span class="hljs-built_in">equal_range</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><span class="hljs-comment">// range.first指向第一个4，range.second指向5</span><br></code></pre></td></tr></table></figure></p><h3 id="stdbinary_search">std::binary_search</h3><p>检查值是否存在于已排序序列中 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">bool</span> found = std::<span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p><h2 id="集合操作">集合操作</h2><h3 id="stdmerge">std::merge</h3><p>合并两个已排序序列 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<br>std::<span class="hljs-built_in">merge</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">// result = &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdset_union-stdset_intersection-stdset_difference">std::set_union / std::set_intersection / std::set_difference</h3><p>集合操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; unionResult, intersectionResult, differenceResult;<br><br>std::<span class="hljs-built_in">set_union</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <br>               std::<span class="hljs-built_in">back_inserter</span>(unionResult));<br><span class="hljs-comment">// unionResult = &#123;1, 2, 3, 4, 5, 6&#125;</span><br><br>std::<span class="hljs-built_in">set_intersection</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(),<br>                     std::<span class="hljs-built_in">back_inserter</span>(intersectionResult));<br><span class="hljs-comment">// intersectionResult = &#123;3, 4&#125;</span><br><br>std::<span class="hljs-built_in">set_difference</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(),<br>                   std::<span class="hljs-built_in">back_inserter</span>(differenceResult));<br><span class="hljs-comment">// differenceResult = &#123;1, 2&#125;</span><br></code></pre></td></tr></table></figure></p><h2 id="堆操作">堆操作</h2><h3 id="stdmake_heap-stdpush_heap-stdpop_heap">std::make_heap / std::push_heap / std::pop_heap</h3><p>堆操作 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;<br>std::<span class="hljs-built_in">make_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 构建最大堆</span><br><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">6</span>);<br>std::<span class="hljs-built_in">push_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 维护堆性质</span><br><br>std::<span class="hljs-built_in">pop_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将最大元素移到末尾</span><br>v.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 移除最大元素</span><br></code></pre></td></tr></table></figure></p><h2 id="最小最大操作">最小/最大操作</h2><h3 id="stdmin_element-stdmax_element-stdminmax_element">std::min_element / std::max_element / std::minmax_element</h3><p>查找最小/最大元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">auto</span> minIt = std::<span class="hljs-built_in">min_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 指向1</span><br><span class="hljs-keyword">auto</span> maxIt = std::<span class="hljs-built_in">max_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 指向9</span><br><span class="hljs-keyword">auto</span> minmax = std::<span class="hljs-built_in">minmax_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// minmax.first指向1，minmax.second指向9</span><br></code></pre></td></tr></table></figure></p><h2 id="比较操作">比较操作</h2><h3 id="stdlexicographical_compare">std::lexicographical_compare</h3><p>字典序比较 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">bool</span> less = std::<span class="hljs-built_in">lexicographical_compare</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), <br>                                        v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p><h2 id="排列操作">排列操作</h2><h3 id="stdnext_permutation-stdprev_permutation">std::next_permutation / std::prev_permutation</h3><p>生成排列 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 处理排列</span><br>&#125; <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">next_permutation</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()));<br></code></pre></td></tr></table></figure></p><h2 id="数值操作">数值操作</h2><h3 id="stdaccumulate">std::accumulate</h3><p>累加 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 15</span><br><span class="hljs-type">int</span> product = std::<span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>, std::<span class="hljs-built_in">multiplies</span>&lt;<span class="hljs-type">int</span>&gt;()); <span class="hljs-comment">// 120</span><br></code></pre></td></tr></table></figure></p><h3 id="stdinner_product">std::inner_product</h3><p>内积 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span> result = std::<span class="hljs-built_in">inner_product</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 32 (1*4 + 2*5 + 3*6)</span><br></code></pre></td></tr></table></figure></p><h3 id="stdpartial_sum">std::partial_sum</h3><p>部分和 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>std::<span class="hljs-built_in">partial_sum</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">// result = &#123;1, 3, 6, 10, 15&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdadjacent_difference">std::adjacent_difference</h3><p>相邻差 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>std::<span class="hljs-built_in">adjacent_difference</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>());<br><span class="hljs-comment">// result = &#123;1, 1, 2, 3, 4&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stdiota">std::iota</h3><p>填充递增序列（C++11） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>std::<span class="hljs-built_in">iota</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">10</span>);<br><span class="hljs-comment">// v = &#123;10, 11, 12, 13, 14&#125;</span><br></code></pre></td></tr></table></figure></p><h2 id="总结">总结</h2><p>C++标准库提供了丰富的算法函数，涵盖了各种常见操作。这些算法具有以下优点：</p><ol type="1"><li><strong>通用性</strong>: 适用于各种容器类型</li><li><strong>效率</strong>: 经过高度优化</li><li><strong>安全性</strong>: 减少手动循环的错误</li><li><strong>可读性</strong>: 代码意图更明确</li></ol><p>熟练掌握这些算法可以大大提高C++编程的效率和代码质量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-03</title>
    <link href="/posts/50145520/"/>
    <url>/posts/50145520/</url>
    
    <content type="html"><![CDATA[<p>本文记录LeetCode刷题中矩阵相关的题目 <span id="more"></span> # <a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>73. 矩阵置零</strong></a> 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 ## 解法一： 常规思路是用一个m维和n维的vector记录记录当前行或者当前列是否有0，若有，则标记该位置，待循环完整个矩阵后，再根据记录的数据将matrix对应的行或者列置0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>(), col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">row_record</span><span class="hljs-params">(row, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">col_record</span><span class="hljs-params">(col, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    row_record[i] = <span class="hljs-number">1</span>;<br>                    col_record[j] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (row_record[i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (col_record[j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二">解法二：</h2><p>解法二是在解法一的基础上，解法一是用了两个外置的数组来记录每一行每一列的情况，进阶的解法是在一的基础上，用第一行第一列来代替外置的数组。另外第一行第一列的情况首先需要用一个变量记录，后续根据此变量决定第一行第一列是否要置0。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">bool</span> row_has_zero = std::<span class="hljs-built_in">any_of</span>(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span>;&#125;);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-type">bool</span> col_has_zero = std::<span class="hljs-built_in">any_of</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; row) &#123;<span class="hljs-keyword">return</span> row[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>;&#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>                std::<span class="hljs-built_in">fill</span>(matrix[i].<span class="hljs-built_in">begin</span>(), matrix[i].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; row : matrix) &#123;<br>                    row[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (row_has_zero) &#123;<br>            std::<span class="hljs-built_in">fill</span>(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col_has_zero) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; row : matrix) &#123;<br>                row[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure> 踩坑记录： 1. 不知道std::any_of和std::fill的用法 2. 用第一行和第一列记录之后，遍历矩阵应该从[1，1]的位置开始遍历，需要把第一行和第一列去除掉，因为第一行第一列已经用其他的变量的表示了。</p><h1 id="螺旋矩阵"><a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>54. 螺旋矩阵</strong></a></h1><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>根据题意，从左上角出发，按照【右下左上】的顺序遍历： 1. 右:到边界，右转90°，向下 2. 下:到边界，右转90°，向左 3. 左:到边界，右转90°，向上 4. 上:会遇到访问过的数字，然后右转90°，再向右 5. 重复上述过程，直到答案的长度为mn</p><h2 id="方法一标记法">方法一：标记法</h2><ol type="1"><li>对于已经访问过的数字，将其标记为空，避免二次访问</li><li>用一个长度为4的方向数组<code>DIRS[(0,1),(1,0),(0,-1)(-1,0)]</code>表示右下左上四个方向（为什么是这4个数组，可以用笔画下点的走向），同时用一个下标di表示当前的方向，初始值为0</li><li>每次移动时，相当于把行号增加<code>DIRS[di][0]</code>，把列号增加<code>DIRS[di][1]</code></li><li>向右转90°，相当于把di增加1，但是<code>di=3</code>时要回到<code>di=0</code>，所以di为<code>(di + 1) mod 4</code> &gt; 说明：di为0的时候表示向右，为1向下，为2向左，为3向上，接下来要继续为0 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> DIRS[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> m  = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, dir = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m * n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; m * n; ++k) &#123;<br>            ans[k] = (matrix[i][j]);<br>            matrix[i][j] = INT_MAX;<br>            <span class="hljs-type">int</span> x = i + DIRS[dir][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y = j + DIRS[dir][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= m | y &lt; <span class="hljs-number">0</span> || y &gt;= n || matrix[x][y] == INT_MAX) &#123;<br>                dir = (dir + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            &#125;<br>            i += DIRS[dir][<span class="hljs-number">0</span>];<br>            j += DIRS[dir][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>踩坑记录： 1. 对于vector：用完reserve之后，可以用emplace_back,如果直接指定了大小，只能通过下标访问。 2. 需要先求出来接下的一步的预想值，然后再根据是否越界判断接下来的一步。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中字符串的表现形式</title>
    <link href="/posts/559950850/"/>
    <url>/posts/559950850/</url>
    
    <content type="html"><![CDATA[<p>在C++中，字符串的常用表示形式有3中，分别是<code>string</code>，<code>const char*</code> ，<code>char*</code>，这三者在<strong>内存管理</strong>，<strong>可变形</strong>，以及<strong>接口兼容性</strong>中有显著的差别，需要注意区分。 <span id="more"></span></p><h1 id="基本区别">基本区别</h1><table><thead><tr class="header"><th><strong>类型</strong></th><th><strong>说明</strong></th><th><strong>可变性</strong></th><th><strong>内存管理</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr class="odd"><td><strong><code>std::string</code></strong></td><td>C++ 标准库字符串类，封装了动态字符数组</td><td>可变</td><td>自动管理内存（RAII）</td><td>通用字符串操作</td></tr><tr class="even"><td><strong><code>char*</code></strong></td><td>指向可变字符数组的指针（C 风格字符串）</td><td>可变</td><td>需手动管理内存（<code>new</code>/<code>delete</code>）</td><td>与 C 接口交互</td></tr><tr class="odd"><td><strong><code>const char*</code></strong></td><td>指向<strong>不可变</strong>字符数组的指针（C 风格字符串字面量）</td><td>不可变</td><td>通常是静态存储（如 <code>"hello"</code>）</td><td>字符串常量、只读访问</td></tr></tbody></table><h1 id="在模板编程中的差异">在模板编程中的差异</h1><p>在模板编程时，<code>string</code>、<code>char*</code> 和 <code>const char*</code> 的行为可能不同，主要涉及：</p><ol type="1"><li><strong>类型推导</strong>（<code>auto</code>、<code>decltype</code>）</li><li><strong>函数重载</strong>（<code>T</code> vs <code>const T&amp;</code>）</li><li><strong>字符串操作</strong>（<code>size()</code>、<code>c_str()</code> 等）</li><li><strong>内存管理</strong>（是否需要 <code>delete</code>）</li></ol><h2 id="类型推导">类型推导</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T str)</span> </span>&#123;<br>    std::cout &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>);       <span class="hljs-comment">// T = const char[6]（数组退化到 const char*）</span><br>    <span class="hljs-built_in">print</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;world&quot;</span>));  <span class="hljs-comment">// T = std::string</span><br>    <span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-built_in">print</span>(arr);           <span class="hljs-comment">// T = char[4]（数组退化到 char*）</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>"hello"</code> 是 <code>const char[6]</code>，但会退化为 <code>const char*</code>。</li><li><code>std::string</code> 保持原类型。</li><li><code>char[]</code> 会退化为 <code>char*</code></li></ul><h2 id="函数重载">函数重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T str)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;T, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;C-string: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;std::string: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(<span class="hljs-string">&quot;hello&quot;</span>);       <span class="hljs-comment">// 匹配 const char*</span><br>    <span class="hljs-built_in">process</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;world&quot;</span>));  <span class="hljs-comment">// 匹配 std::string</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以用 <code>if constexpr</code> 或 <strong>SFINAE</strong> 区分不同类型。</li></ul><h2 id="字符串操作">字符串操作</h2><p><code>std::string</code> 提供 <code>size()</code>、<code>substr()</code> 等方法，但 <code>char*</code> 和 <code>const char*</code> 没有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLength</span><span class="hljs-params">(T str)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;T, std::string&gt;)</span> </span>&#123;<br>        std::cout &lt;&lt; str.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; std::<span class="hljs-built_in">strlen</span>(str) &lt;&lt; std::endl;  <span class="hljs-comment">// 需要 #include &lt;cstring&gt;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printLength</span>(<span class="hljs-string">&quot;hello&quot;</span>);       <span class="hljs-comment">// 调用 strlen</span><br>    <span class="hljs-built_in">printLength</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;world&quot;</span>));  <span class="hljs-comment">// 调用 size()</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>char*</code> 和 <code>const char*</code></strong> 需要用 <code>strlen()</code> 计算长度。</li><li><strong><code>std::string</code></strong> 可以直接用 <code>size()</code>。</li></ul><h2 id="内存管理">内存管理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">(T str)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;T, <span class="hljs-type">char</span>*&gt;)</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span>[] str;  <span class="hljs-comment">// 假设 str 是动态分配的</span><br>    &#125;<br>    <span class="hljs-comment">// std::string 和 const char* 不需要手动释放</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span>* dynamicStr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">strcpy</span>(dynamicStr, <span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-built_in">cleanup</span>(dynamicStr);  <span class="hljs-comment">// 需要 delete[]</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* literal = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">cleanup</span>(literal);  <span class="hljs-comment">// 无操作</span><br><br>    std::string s = <span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-built_in">cleanup</span>(s);  <span class="hljs-comment">// 无操作</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>char*</code></strong> 可能需要手动 <code>delete[]</code>（如果动态分配）。</li><li><strong><code>const char*</code></strong> 通常是字面量，不能 <code>delete</code>。</li><li><strong><code>std::string</code></strong> 自动管理内存。</li></ul><h2 id="最佳实践">最佳实践</h2><p> <strong>统一接口（使用 <code>std::string_view</code>，C++17+）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T str)</span> </span>&#123;<br>    <span class="hljs-function">std::string_view <span class="hljs-title">sv</span><span class="hljs-params">(str)</span></span>;  <span class="hljs-comment">// 兼容 std::string, char*, const char*</span><br>    std::cout &lt;&lt; sv &lt;&lt; <span class="hljs-string">&quot; (length: &quot;</span> &lt;&lt; sv.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>);       <span class="hljs-comment">// const char*</span><br>    <span class="hljs-built_in">print</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;world&quot;</span>));  <span class="hljs-comment">// std::string</span><br>    <span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-built_in">print</span>(arr);           <span class="hljs-comment">// char*</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong><code>std::string_view</code></strong> 可以统一处理所有字符串类型，避免拷贝。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HNSW:一种高效的图向量检索算法</title>
    <link href="/posts/2615319865/"/>
    <url>/posts/2615319865/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><strong>背景</strong></h1><p>HNSW(<strong>Hierarchical Navigable Small World</strong>)是一种向量检索算法，向量检索算法包含基于<strong>树</strong>，<strong>图</strong>，<strong>哈希</strong>以及<strong>量化</strong>的各种算法，HNSW是<strong>基于图</strong>的一种高效ANN(<strong>Approximate Nearest Neighbors</strong>)检索算法，其在查询性能和召回率上表现十分优异，广泛应用在工业界中。</p><p><img src="/pictures/20250523/hnsw/image.png" /></p><p>HNSW的中文名称是<strong>分层可导航的最小网络世界</strong>，其是基于跳表(<strong>Skip List</strong>)和可导航的最小网络世界(<strong>NSW</strong>)两种数据结构构建的，因此我们先介绍这两个基础的概念。</p><h1 id="hnsw基础">HNSW基础</h1><h2 id="跳表">跳表</h2><p>熟悉Redis的同学对于跳表的原理比较熟悉。跳表的出现主要是解决链表在随机插入，删除，查找的时间复杂度为O(n)的问题，跳表是一种典型的以<strong>空间换时间</strong>的数据结构，通过引入额外层的方法，使得链表的随机访问的时间复杂度为O(logN)。跳表的结构如下，其最上层连接的节点数最少，随着层数向相下，连接的节点越来越多。最后一层，是所有节点相连。</p><p><img src="/pictures/20250523/hnsw/image%201.png" /></p><p><strong>查找过程：</strong></p><p>假如我们目标是查找元素i，从最高成开始，一旦找到了链表元素的值<strong>大于i</strong>或者是到了最后一个节点(认为是正无穷)，随即回退到上一个节点，并且移动到下一层，重复上面的过程，直到找到为止。比如要查找元素11，从最高层layer3开始，到最后一个节点(正无穷)，然后回退上一个节点5，到下一层layer2，第二个节点19已经大于11，回退到上一个节点5，然后到下一层layer1，5的下一个节点就是11。到此，返回结果，查到目标元素。</p><p><strong>插入过程：</strong></p><p>如果要插入一个元素，首先要查找到其应该在的位置，这个可应用上述的查找过程。将其插入到<strong>最底层</strong>(layer0)后，是否需要建立layer1层的来连接是通过抛硬币的方式(1/2的概率)决定的，如果在layer1层建立连接，那是否要在layer2层建立连接也是通过抛硬币的方式决定的，依次类推……此方法在数据量级较大的时候，可以保证layer0层节点* 1/2 ≈ layer1层节点， layer1层节点 * 1/2 ≈ layer2层 ……，因此其可以保存插入，查找，删除的时间复杂度为O(logN)。</p><h2 id="sw">SW</h2><p>SW是单层的小世界图，在介绍SW之前，需要先了解图论中的一些基本概念。 正则图：正则图是指每个顶点都有相同数目邻居的图，即每个顶点的度相同。若每个顶点的度均为 k，称为 k-正则图。</p><p><img src="/pictures/20250523/hnsw/image%202.png" /></p><p>随机图：随机图是指在随机过程的生成的图，也就是节点和节点之间的连接是随机建立的。</p><p><img src="/pictures/20250523/hnsw/image%203.png" /></p><p>六度空间理论：</p><blockquote><p>在1967年Stanley Milgram从Kansas和Nebraska两个州招募了一批志愿者， 请他们分别将一封信转寄给一个住在Cambridge神学院学生的妻子和一个住在Boston郊区的股票经纪人。 他给志愿者们这样的要求：</p><ol type="1"><li>虽然有寄信目标的相关信息，如果不是私人关系，不能把信直接寄给TA.</li><li>每次只能把信寄给最有可能知道这个人的熟人。</li><li>原始信封里有15张追踪卡片，每次转寄都要回寄一张给实验者，其他的放在信封里寄给下一个人，这样研究员可以随时追踪这些信函的路径。</li></ol><p>在到达的信函中，Stanley Milgram计算信函平均到达的节点为5个，也就是我们和一个陌生人建立连接只需要6步</p></blockquote><p>Stanley Milgram基于他的实验提出了著名的<strong>六度分离理论</strong>，这个理论指出:</p><ol type="1"><li>现实世界中的短路径是普遍存在的。</li><li>人们可以有效地找到并且利用这些短路径。</li></ol><p>在小世界网络中，可以把点与点之间的关系可以分为两种：</p><ul><li><strong>同质性</strong>: 同质性也就是相似的点会聚集到一起，相互连接具有邻接边。</li><li><strong>弱连接</strong>: 弱连接是指从每一个节点上，会有一些随机的边随机连接到网络中的节点上，这些节点是随机均匀的。</li></ul><p><strong>正则图 vs 小世界图 vs 随机图</strong></p><p><img src="/pictures/20250523/hnsw/image%204.png" /></p><p>小世界图在局部同类节点的连接呈现出规则，从全局来看不同类节点的连接呈现出随机性。 这两种性质也就是上面我们所说的<strong>同质性</strong>和<strong>弱连接</strong>。</p><h2 id="nsw"><strong>NSW</strong></h2><p>在向量召回的场景下，以二维向量的召回为例，假设所有的embedding向量都是二维的，如下图所。黑色箭头是构建全量的embedding向量库，红色向量代表的是用户请求向量，即Query Emdedding，向量检索的目标就是在黑色的向量中挑选top K个和红色向量最接近的候选向量。</p><p><img src="/pictures/20250523/hnsw/image%205.png" /></p><p>接下来就是构建NSW，NSW由于具有<strong>同质性</strong>和<strong>弱连接性</strong>，可以具备很好的表现性能，在较快的时间内查找到目标向量。构建好的NSW图如下所示。</p><p><img src="/pictures/20250523/hnsw/image%206.png" /></p><p>其中我们认为红色的边具备<strong>弱连接性</strong>，黑色的边具备<strong>同质性</strong>。红色的称为Long-Range Edge，其可以让两个距离较远的边直接连接起来，不需要经过多个阶段的转发，使得整个图具备高速公路机制。黑色的边，就是Short-Range Edge，用于连接连个节点的点。</p><p><strong>构图过程：</strong></p><p>NSW的构图过程比较简单，对于每插入一个点，找到距离它最近的M个点，跟这M个点建立建立即可。假如我们要构建一张图，M=3，如下图表示了构图的过程，黑色的点代表已有的点，红色的点代表新插入的点。<strong>红点会和距离其最近的M个黑点</strong>建立连接。</p><p><img src="/pictures/20250523/hnsw/image%207.png" /></p><p>那么高速公路机制是如何建立起来的呢？在构图的早期，由于节点的个数比较少，即使两点距离的很远，但还是有可能建立连接的。比如在第四步中的左下和右上两个节点，即使他们俩距离的很远，但是连接还是被建立起来了。而在构图的后期，图中的节点已经很多了，新插入一个节点时，更有可能找到距离它最近的M个节点。因此高速公路在构图的早期已经被建立起来了，在构图后期，不太有可能有高速公路建立起来。</p><p><strong>搜索过程：</strong></p><p>NSW的搜索过程是找到距离候选点最近的M个点，搜索方法是从图中的任意一个点作为起始点出发，使用<strong>贪心</strong>的方法，依次去查找距离target最近的M个点。整个过程需要维护两个优先队列，分别是候选点集candidate(<strong>小顶堆</strong>)，结果集result(<strong>大顶堆</strong>)。比较函数是距离target的远近。以下图为例阐述整个搜索过程。</p><p><img src="/pictures/20250523/hnsw/image%208.png" /></p><p>candidate代表的是候选结果集，队列大小为3，result是结果集，队列大小为3，visited是已经访问过的节点集。(a): 以点A作为起点开始查找，此时结果集，候选集，访问队列都为A(b): 从点A可以得到点G,B，将G,B加入到小顶堆candidate中，顺序为G,B,A。同时将G,B加入到大顶堆result中，顺序为A,B,G(c): 将小顶堆candidate中队首元素pop出来，即G,以G为起点进行广度优先搜索，得到F,E。将E,F假如到candidate中，得到F,E,B。将F假如到result中，得到B,G,F。再将E加入到result中，得到G,E,F(d): 将小顶堆candidate中队首元素pop出来，即F,以F为起点进行广度优先搜索，得到D,将D加入到小顶堆candidate中，得到小顶堆D,E,B。同时将D加入到大顶堆result中，得到大顶堆E,D,F(e): 将小顶堆candidate中队首原生pop出来，即D,以D为起点进行广度优先搜索，得到C,将C加入到小顶堆candidate中，得到E,C,B。同时将C加入到大顶堆中，得到大顶堆E,D,F</p><p><strong>此时candidate中距离target最近距离已经大于等于result中距离target最远距离，搜索结束。</strong></p><p><strong>SEACHER-LAYER:</strong></p><p>在指定层查找K个最近邻节点。</p><p><img src="/pictures/20250523/hnsw/image%209.png" /></p><p><strong>传入参数：</strong></p><p>q:表示需要查找的节点，ep: 固定的起始节点，如果Layer是最顶层，有固定的入口节点。如果不是最顶层则是上一层查询到的最近邻。ef: 查找的邻居节点数目lc: 查询的层数</p><p><strong>输出:</strong></p><p>q元素最近邻的ef个节点。</p><p><strong>功能:</strong></p><p>SEARCH LAYER算法的功能是在给定一个节点q和起始查询节点eq、查询的层lc的情况下，查找出节点q在层lc下的ef个最近邻。</p><p><strong>算法步骤：</strong></p><ol type="1"><li>首先根据ep初始化visited set V, candidate set C, 以及动态最近邻W</li><li>当 candidate set 不为空的时候执行:</li></ol><ul><li>从candidate set C中选取离q最近的点c,</li><li>从动态最近邻中选取最远的点f,</li><li>比较distance(c,q)和distance(f,q)</li><li>如果distance(c,q) &gt; distance(f,q)则返回，否则继续执行 下一步</li><li>对在lc层中c节点的每个邻居e。如果e在visited中，重新执行步骤2,否则继续执行下一步</li><li>将e节点加入visited set</li><li>从W中获取最远的节点f</li><li>如果distance(e,q) &lt; distance(f,q) 或者 |W| &lt; ef 将 e分别加入 candidate set C和动态最近邻W</li><li>如果 |W| &gt; ef 移除最大元素。</li></ul><ol type="1"><li>返回集合W</li></ol><h1 id="hnsw"><strong>HNSW</strong></h1><p>HNSW就是将跳表结构应用到图中，其总体思想如下：</p><ol type="1"><li>在Layer = 0 层中，包含了连通图中所有的点。</li><li>随着层数的增加，每一层的点数逐渐减少并且遵循指数衰减定律</li><li>图节点的最大层数，由随机指数概率衰减函数决定。</li><li>从某个点所在的最高层往下的所有层中均存在该节点。</li><li>在对HNSW进行查询的时候，从最高层开始检索。</li></ol><p><a href="https://rte.weiyun.baidu.com/wiki/attach/image/api/imageDownloadAddress?attachId=2e28b19917cb478c9541a99d6f41c3c4&amp;docGuid=nYrT2-8Peq81st"></a></p><p>跳表的每一层，都是一个小世界网络。其中最底层(Layer=0)是一个完整的NSW，其它层存储的则是指向图节点的指针索引。使用跳表的原因是<strong>为了少做无用功耽误时间</strong>。在一个上亿量级的小世界网络中进行检索，尽管有高速公路机制的存在，量级大了耗时还是教高。因为NSW的检索时间复杂度是多重对数的。</p><p><em>原因是</em></p><p><em>距离计算次数等于 “检索要经过的节点数量” 乘以 “每个节点的度”。“检索要经过的节点数量” 以及 “每个节点的度”随着图规模的增大，都是对数增长的。两个对数复杂度相乘，是多重对数复杂度了。</em></p><p><strong>解决方案就是分层：</strong></p><p>只要把“每个节点的度”控制住，如果节点的度太高了，就把它们分散到不同层级。这样可以保证，“检索要经过的节点数量”依旧对数增长，而节点的度是常量，那么整个检索过程就是对数增长而不是多重对数增长了。</p><h2 id="插入过程">插入过程:</h2><p>一个新的节点，在哪一层开始插入，是随机的。随机是带权的，随机到下层的概率较高。如果随机到l层，那么从l-0层都要插入此点。</p><p><img src="/pictures/20250523/hnsw/image%2010.png" /></p><p>在图中新插入一个节点，首先通过随机函数确定该节点的最大层l，例如l = 2, max layer = 5。整个新增流程主要分为两部分，第一步先从最上层开始，使用BFS寻找最近的节点。找到的节点随后被用作下一层的入口点，并继续进行搜索。一旦到达第l层，插入过程将进入第二步。 从第l层开始，算法在当前层插入新节点。然后，它在步骤1中的操作与之前相同，但不再只寻找一个最近邻，而是贪婪地搜索efConstruction个最近邻。接着，从efConstruction个邻近节点中选择M个，并建立从插入节点到这些节点的边。之后，算法下降到下一层，每个找到的efConstruction个节点都作为入口点。当新节点及其边被插入到最底层0后，算法终止。</p><p><img src="/pictures/20250523/hnsw/image%2011.png" /></p><p>entry_point 是图的入口节点，是在建库(插入数据)时确定的，为当前最大层的第一个节点。</p><p><img src="/pictures/20250523/hnsw/image%2012.png" /></p><p><strong>启发式裁剪：</strong></p><p>伪代码的第9，10行，可以看到在每一层搜索与插入点最邻近的M个节点的时候，它是先召回了efConstruction个，然后再select了M个(efConstruction &gt;= M)。关于启发式裁剪，论文中给出了一种bad case。在图构建的过程当中，会出现形成了两个cluster的场景，如下图所示，假设新插入的节点都离cluster1很近，根据knn搜索，会导致cluster1和cluster2之间，一直没有连接建立，那么从cluster1到cluster2的搜索跳转就会很麻烦，会兜一大圈。</p><p><img src="/pictures/20250523/hnsw/image%2013.png" /></p><p>启发式算法可以防止节点数据过于集中，保证图的连通性。例如下图所示结构的图表。一共有三个区域，其中两个区域（位于左侧和顶部）并未相互连接。因此，例如从点A到点B需要穿过另一个区域，路径较长。为了更好地导航，将这两个区域以某种方式连接起来是合乎逻辑的。</p><p><img src="/pictures/20250523/hnsw/image%2014.png" /></p><p>例如节点X被插入到图中, 并且需要连接 M=2 个其他节点,在这种情况下, 尽管X和B、C是真正的最近邻, 但是这并不能解决上述提到的问题, 启发式方法不仅考虑节点之间的最近距离, 还考虑图中不同区域的连通性.</p><p><img src="/pictures/20250523/hnsw/image%2015.png" /></p><p>启发式裁剪的叙述如下：红色点Q就是新插入的点，ABCD四个黑色点就是本次召回的点。那么第一个我们铁定选择A，因为A是距离Q最近的。但是第二步，按照最邻近，我们应该选择B，因为B距离Q是第二近的。但是，此时gap就形成了，ABQ成了一派，CD成了一派。启发式裁剪的做法是，此时AQ已经建立了，进行下一轮建立时，最近的是B，但是AB的距离比BQ要小，因此放弃B转而查看下一个最近的点C；CA的距离比CQ要来的大，那么Q就跟C建立连接。附上论文中启发式裁剪的伪代码。</p><p><img src="/pictures/20250523/hnsw/image%2016.png" /></p><h2 id="查找过程">查找过程：</h2><p>检索从最高层开始，每次在层节点中贪婪地找到局部最近邻后，便向下搜索一层。最终，在最低层找到的最近邻即为查询的结果。</p><p><img src="/pictures/20250523/hnsw/image%2017.png" /></p><p>主要包含以下4几个算法。</p><ul><li>SEACHER-LAYER: 在指定层查询K个最近邻节点。</li><li>SELECT-NEIGHBORS-SIMPLE: 简单的查找某一层最近的邻居节点。（构图时使用）</li><li>SELECT-NEIGHBORS-HEURISTIC: 探索式查找某一层最近的邻居节点。（构图时使用）</li><li>K-NN-SEARCH: 从所有候选结果中找出K个最近邻结果。</li></ul><p><strong>SELECT-NEIGHBORS：</strong></p><p>在<strong>SELECT-NEIGHBORS</strong>主要分为两个部分由SELECT-NEIGHBORS-SIMPLE以及SELECT-NEIGHBORS-HEURISTIC两个算法组成。</p><p><strong>SELECT-NEIGHBORS-SIMPLE和SELECT-NEIGHBORS-HEURISTIC两个算法都是用在图构建的过程中，而不用在KNN的近邻检索，与SIMPLE不同的是HEURISTIC方法添加了更多的随机性，从而同一层节点之间的连接随机性更强。</strong></p><p><img src="/pictures/20250523/hnsw/image%2018.png" /></p><p><strong>参数输入：</strong></p><p>q:表示需要查询的节点。C:表示查询的候选节点集合。M:表示返回最近邻居的个数。</p><p><strong>输出：</strong></p><p>q在C中的M个最近邻居</p><p><strong>功能：</strong></p><p>选取出节点q在候选集C中的M个最近邻居。</p><p><img src="/pictures/20250523/hnsw/image%2019.png" /></p><p><strong>参数输入：</strong></p><p>q:表示我们需要查询的节点。C:表示candidate 节点；M:表示返回的最近邻节点的个数M；lc:表示返回的层的编号extendCandidates:表示是否需要扩展candidatekeepPrunedConnection:表示是否需要把废弃节点加入到返回结果中</p><p><strong>返回结果</strong></p><p>通过探索式查找返回最近邻的M个结果。</p><p><strong>K-NN-SEACHER</strong></p><p><img src="/pictures/20250523/hnsw/image%2020.png" /></p><p>从固定的enter节点进入，在顶层开始检索。 在每一层检索到唯一一个最近邻然后作为下一层入口节点。最后在底层检索top K个最相似节点。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vectordb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const vs constexpr</title>
    <link href="/posts/2212644689/"/>
    <url>/posts/2212644689/</url>
    
    <content type="html"><![CDATA[<p>在 C++ 编程中，<code>constexpr</code> 和 <code>const</code> 是两个常用的关键字，它们在定义常量和函数时有着不同的用途和行为。理解它们的区别对于编写高效、安全的代码至关重要。本文将深入探讨 <code>constexpr</code> 和 <code>const</code> 的区别，并通过详细的使用场景和示例代码进行说明。 <span id="more"></span> - <strong><code>constexpr</code></strong>：用于定义<strong>编译期常量</strong>和<strong>编译期计算的函数</strong>。它确保表达式在编译期计算，从而提高性能和安全性。 - <strong><code>const</code></strong>：用于定义运行时常量和不可变的值。它仅表示变量的值在初始化后不可改变，但不保证在编译期计算。 # 1. 适用场景</p><ul><li><strong>编译期常量</strong>：如果需要在编译期确定值，应该使用 <code>constexpr</code>。例如，数组大小、数学常量等。</li><li><strong>运行时常量</strong>：如果值在运行时确定，但在整个程序运行期间不变，使用 <code>const</code>。例如，配置参数、运行时计算结果等。</li></ul><h1 id="修饰函数的区别">2. 修饰函数的区别</h1><h2 id="constexpr-修饰函数">2.1 <code>constexpr</code> 修饰函数</h2><ol type="1"><li><code>constexpr</code> 函数可以在编译期进行计算，如果其参数是编译期常量。</li><li>编译器会尝试在编译期求值 <code>constexpr</code> 函数，以提高性能和安全性。</li><li><strong>函数要求</strong>：<ul><li><code>constexpr</code> 函数必须是纯函数，即没有副作用，且其返回值仅依赖于输入参数。</li><li>函数体必须是一个单一的返回语句，或者是一个常量表达式。</li></ul></li><li><strong>使用场景</strong>：<ul><li>可以用于定义编译期常量。</li><li>可以在编译期进行复杂的计算，一般是数学公式。</li></ul></li><li><strong>示例</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 编译期计算</span><br></code></pre></td></tr></table></figure><p><code>constexpr</code> 的限制</p><ul><li>函数体限制：<code>constexpr</code> 函数的函数体必须是一个单一的返回语句，或者是一个可以在编译时计算的表达式。</li><li><strong>循环和条件语句</strong>：<code>constexpr</code> 函数可以包含循环和条件语句，但这些语句必须能够在编译时完全展开和计算。</li><li><strong>递归</strong>：<code>constexpr</code> 函数可以是递归的，但递归深度必须在编译时确定。</li></ul><h2 id="const-修饰函数">2.2 <code>const</code> 修饰函数</h2><ul><li><strong>运行时计算</strong>：<ul><li><code>const</code> 修饰函数的返回值在运行时计算。</li><li><code>const</code> 仅表示函数返回的值是不可变的，但不保证在编译期计算。</li></ul></li><li><strong>函数要求</strong>：<ul><li><code>const</code> 修饰函数没有特别的要求，可以有副作用。</li><li>函数体可以包含任意的合法 C++ 代码。</li></ul></li><li><strong>使用场景</strong>：<ul><li>用于返回一个不可变的值。</li><li>适用于需要在运行时计算的场景。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 运行时计算</span><br></code></pre></td></tr></table></figure><h1 id="const-的详细使用场景和示例">3. <code>const</code> 的详细使用场景和示例</h1><ol type="1"><li><p><strong>修饰变量</strong>：<code>const</code> 用于修饰变量，表示该变量的值在初始化后不可改变。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>修饰指针</strong>： <code>const</code> 可以修饰指针，表示指针本身或指针指向的值不可变。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr = &amp;x;  <span class="hljs-comment">// 指向常量的指针</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr2 = &amp;x; <span class="hljs-comment">// 常量指针</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>修饰函数参数</strong>：<code>const</code> 可以修饰函数参数，表示参数在函数内部不可改变。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// y 不能被修改</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>修饰成员函数</strong>：<code>const</code> 可以修饰成员函数，表示该成员函数不会修改类的成员变量。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 不能修改类的成员变量</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>成员变量</strong>：<code>const</code> 成员变量必须在构造函数初始化列表中初始化。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> value;<br>&#125;;<br></code></pre></td></tr></table></figure></p></li></ol><h1 id="constexpr-的详细使用场景和示例">4. <code>constexpr</code> 的详细使用场景和示例</h1><ol type="1"><li><p><strong>修饰变量</strong>：<code>constexpr</code> 用于修饰变量，表示该变量的值在编译期确定。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> y = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>修饰函数</strong>：<code>constexpr</code> 用于修饰函数，表示该函数可以在编译期求值。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>修饰表达式</strong>： <code>constexpr</code> 可以修饰表达式，表示该表达式在编译期求值。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure></p></li><li><p><strong>构造函数</strong>：<code>constexpr</code> 可以用于构造函数，表示该构造函数可以在编译时执行。</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> : value(v) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>静态成员变量</strong>：<code>constexpr</code> 可以用于静态成员变量，表示该变量在编译时初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> staticValue = <span class="hljs-number">100</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="constexpr-高级用法">5. <code>constexpr</code> 高级用法</h1><ol type="1"><li><strong>模板元编程</strong>：<code>constexpr</code> 可以与模板结合使用，实现更强大的编译时计算。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N - <span class="hljs-number">1</span>&gt;::value;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> fact5 = Factorial&lt;<span class="hljs-number">5</span>&gt;::value;  <span class="hljs-comment">// 120</span><br></code></pre></td></tr></table></figure><ol type="1"><li><strong><code>constexpr</code></strong> <strong>和 Lambda 表达式：</strong>C++17 引入了 <code>constexpr</code> Lambda 表达式，允许在编译时计算 Lambda 表达式的结果。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">lambda</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h1 id="具体对比">6. 具体对比</h1><ol type="1"><li><strong>编译期 vs 运行时</strong>：<ul><li><code>constexpr</code> 函数可以在编译期计算，<code>const</code> 函数只能在运行时计算。</li></ul></li><li><strong>修饰对象</strong>：<ul><li><code>const</code> 可以修饰变量、指针、函数参数和成员函数。</li><li><code>constexpr</code> 可以修饰变量和函数，确保它们在编译期求值。</li></ul></li><li><strong>函数修饰</strong>：<ul><li><code>const</code> 修饰成员函数，表示该成员函数不会修改类的成员变量。</li><li><code>constexpr</code> 修饰函数，表示该函数可以在编译期求值。</li></ul></li></ol><h1 id="示例代码对比">7. 示例代码对比</h1><p><strong><code>constexpr</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 编译期计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>const</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 运行时计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用建议">8. 使用建议</h1><h2 id="什么时候使用-const"><strong>8.1 什么时候使用 <code>const</code></strong></h2><ol type="1"><li><p><strong>运行时常量</strong>：</p><ul><li>当变量的值在运行时确定，但在整个程序运行期间不变时，使用 <code>const</code>。</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> runtimeValue = <span class="hljs-built_in">someFunction</span>();<br></code></pre></td></tr></table></figure></p></li><li><p><strong>不可变参数</strong>：</p><ul><li>当函数参数在函数内部不应被修改时，使用 <code>const</code> 修饰参数。</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-comment">// input 不能被修改</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>成员函数</strong>：</p><ul><li>当成员函数不应修改类的成员变量时，使用 <code>const</code> 修饰成员函数</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 不能修改类的成员变量</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p></li></ol><h2 id="什么时候使用-constexpr">8.2 什么时候使用 <code>constexpr</code></h2><ol type="1"><li><p><strong>编译期常量</strong>：</p><ul><li>当变量的值在编译期确定时，使用 <code>constexpr</code>。</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> compileTimeValue = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>编译期计算</strong>：</p><ul><li>当函数的返回值可以在编译期计算时，使用 <code>constexpr</code> 修饰函数。</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">square</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 编译期计算</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="什么时候可以互相替换">8.3 什么时候可以互相替换</h2><ol type="1"><li><p><strong>简单常量</strong>：</p><ul><li>对于简单的常量表达式，<code>const</code> 和 <code>constexpr</code> 可以互相替换，但 <code>constexpr</code> 提供了编译期计算的额外优势。</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> y = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 可以互相替换</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>函数返回值</strong>：</p><ul><li>如果函数的返回值可以在编译期计算，优先使用 <code>constexpr</code>，否则使用 <code>const</code>。</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">addRuntime</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><p><strong>逐步引入</strong> <code>constexpr</code>：如果你不确定某个变量或函数是否应该是 <code>constexpr</code>，可以先将其声明为 <code>const</code> 或普通函数，然后逐步引入 <code>constexpr</code>，并观察编译器的反馈。</p><ol type="1"><li><strong>测试和验证</strong>：使用单元测试和静态分析工具来验证 <code>constexpr</code> 的使用是否正确。确保在编译期和运行时都能得到预期的结果。</li><li><strong>文档和注释</strong>：在代码中添加注释，说明为什么某个函数或变量被声明为 <code>constexpr</code>。这有助于其他开发者理解你的意图。</li></ol><h1 id="总结">9. 总结</h1><ol type="1"><li><code>const</code>：主要用于修饰变量、指针、函数参数和成员函数，表示这些对象在运行时不可变。适用于运行时常量和不可变参数。</li><li><code>constexpr</code>：主要用于修饰变量和函数，表示这些对象在编译期求值。适用于编译期常量和编译期计算。</li></ol><p>通过理解这些区别和详细的使用场景，你可以更好地选择何时使用 <code>constexpr</code> 和 <code>const</code> 修饰函数和变量，从而编写更高效和安全的代码。希望本文能帮助你在实际编程中更好地应用这两个关键字。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lower_bound与upper_bound的用法</title>
    <link href="/posts/955192074/"/>
    <url>/posts/955192074/</url>
    
    <content type="html"><![CDATA[<p>定义在头文件&lt;algorithm&gt;里，内部用二分查找实现的，时间复杂度为<code>logN</code>，要求熟练掌握两个函数的高阶用法</p><span id="more"></span><ol type="1"><li><code>lower_bound</code>是在不改变原来顺序的情况下，返回第一个应该插入的位置的迭代器。<code>upper_bound</code>是在不改变原来顺序的情况下，返回最后一个应该插入位置的迭代器。</li><li><code>lower_bound</code>、<code>upper_bound</code>配合使用可返回满足条件的闭区间的采用左含右缺表示法表示的索引结果。</li><li>自定义比较函数都是实现“&lt;”运算符操作，lower_bound找左边界（下限），遍历元素在左（下）；upper_bound找右边界（上限），被遍历元素在右（上）</li></ol><h1 id="基础语法">基础语法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">upper_bound</span>(begin, end, value)<br><span class="hljs-built_in">lower_bound</span>(begin, end, value)<br></code></pre></td></tr></table></figure><p>默认条件下数组从小到大，在区间为[begin，end)中，找到就返回该位置的迭代器，没找到返回end</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br><br><span class="hljs-keyword">auto</span> iter_lower = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><span class="hljs-keyword">auto</span> iter_upper = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><br>cout &lt;&lt; *iter_lower &lt;&lt; endl;<br>cout &lt;&lt; *iter_upper &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>根据上述记录，iter_lower输出为4，iter_upper输出为5</p><h1 id="用-greater重载">用 greater<type>()重载</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">upper_bound</span>(begin, end, value, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;())<br><span class="hljs-built_in">lower_bound</span>(begin, end, value, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;())<br></code></pre></td></tr></table></figure><p>同样的道理，只是大小顺序不同，upper_bound也是返回最后一个应该插入位置的迭代器。lower_bound是返回第一个应该插入位置的迭代器。</p><h1 id="进阶用法自定义匿名函数">进阶用法（自定义匿名函数）</h1><h2 id="upper_bound进阶">upper_bound进阶</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">upper_bound</span>(begin, end, value, cmp)<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(value, element)</span></span><br></code></pre></td></tr></table></figure><p>对于匿名函数cmp，返回类型是bool类型，cmp有两个参数，一个是value，即我们将要比较的值，一个是element，我们要比较的数字。upper_bound返回的是[begin,end)区间中第一个满足cmp为TRUE的数。</p><h2 id="lower_bound进阶">lower_bound进阶</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">lower_bound</span>(begin, end,value, cmp)<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(element, value)</span></span><br></code></pre></td></tr></table></figure><p>lower_bound的匿名函数的cmp和value值顺序是反过来，lower_bound返回的是[begin,end)区间中第一个使cmp为false的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br><br>    <span class="hljs-comment">// 基础用法</span><br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>) - nums.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; nums[pos] &lt;&lt; endl; <span class="hljs-comment">// 输出最后一个应该插入的位置，4</span><br><br>    pos = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>) - nums.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; nums[pos] &lt;&lt; endl; <span class="hljs-comment">// 输出第一个应该插入的位置，3</span><br><br>    cout &lt;&lt; (<span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">7</span>) == nums.<span class="hljs-built_in">end</span>()) &lt;&lt; endl; <span class="hljs-comment">// 输出最后一个应该插入的位置，即数组的末尾，因此返回true，因为没有比7大的数,故为1</span><br><br>    <span class="hljs-comment">// greater&lt;int&gt; 重载</span><br>    <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 7 6 5 4 3 2 1</span><br><br>    pos = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) - nums.<span class="hljs-built_in">begin</span>(); <br>    cout &lt;&lt; nums[pos] &lt;&lt; endl; <span class="hljs-comment">// 在不改变原来顺序的情况下，最后一个位置，就是2</span><br><br>    pos = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) - nums.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; nums[pos] &lt;&lt; endl; <span class="hljs-comment">// 在不改变原来顺序的情况下，第一个位置，就是3</span><br><br>    <span class="hljs-comment">// 高阶用法</span><br>    pos = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>, [](<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> element) &#123;<span class="hljs-keyword">return</span> value &lt; element;&#125;) - nums.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; nums[pos] &lt;&lt; endl; <span class="hljs-comment">// upper_bound 返回第一个匿名函数为TRUE的，且匿名函数的第一个参数为value，第二个为element</span><br><br>    pos = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">6</span>, [](<span class="hljs-type">int</span> element, <span class="hljs-type">int</span> value) &#123; <span class="hljs-keyword">return</span> element &lt; value;&#125;) - nums.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; nums[pos] &lt;&lt; endl; <span class="hljs-comment">// lower_bound 返回第一个匿名为false的element,注意第一个为element</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Elem</span> &#123;<br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">Elem</span>(<span class="hljs-type">int</span> val): <span class="hljs-built_in">val</span>(val) &#123;&#125;<br>&#125;<br><span class="hljs-comment">// 自定义比较函数，目标是实现&lt;操作，</span><br><span class="hljs-comment">// lower_bound找下边界（左），elem在下（左）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LowerCompare</span><span class="hljs-params">(Elem elem, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> elem.val &lt; target; <span class="hljs-comment">//实现&lt;</span><br>&#125;<br><br><span class="hljs-comment">// upper_bound找上边界（右），elem在上（右）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UpperCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> target, Elem elem)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> target &lt; elem.val; <span class="hljs-comment">//实现&lt;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Elem&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行 lower_bound 查找</span><br>    <span class="hljs-keyword">auto</span> lower = std::<span class="hljs-built_in">lower_bound</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), target, LowerCompare);<br>    <span class="hljs-keyword">if</span> (lower != vec.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-type">int</span> lowerIndex = lower - vec.<span class="hljs-built_in">begin</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Lower bound of &quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot; is at index: &quot;</span> &lt;&lt; lowerIndex &lt;&lt; <span class="hljs-string">&quot; with value: &quot;</span> &lt;&lt; *lower &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Lower bound of &quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot; not found!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行 upper_bound 查找</span><br>    <span class="hljs-keyword">auto</span> upper = std::<span class="hljs-built_in">upper_bound</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), target, UpperCompare);<br>    <span class="hljs-keyword">if</span> (upper != vec.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-type">int</span> upperIndex = upper - vec.<span class="hljs-built_in">begin</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Upper bound of &quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot; is at index: &quot;</span> &lt;&lt; upperIndex &lt;&lt; <span class="hljs-string">&quot; with value: &quot;</span> &lt;&lt; *upper &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Upper bound of &quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot; not found!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用C++的String流</title>
    <link href="/posts/2997844977/"/>
    <url>/posts/2997844977/</url>
    
    <content type="html"><![CDATA[<p>最近在打印<code>vector</code>中的向量时，自己用的是非常蹩脚的<code>string str</code>，遍历<code>vector</code>然后一个一个的相加，不够优雅。看到可以使用<code>stringstream</code>来实现这种功能，看着代码比较优雅，特地学习一下。 <span id="more"></span></p><p><code>ostringstream</code>、<code>istringstream</code> 和 <code>stringstream</code> 是 C++ 中非常有用的字符串流类，它们分别用于<strong>输出</strong>、<strong>输入</strong>和<strong>同时输入输</strong>出字符串。通过使用这些类，我们可以更方便地处理字符串数据，以及实现数据类型和字符串之间的转换。在实际编程中，可以根据具体需求选择合适的字符串流类来简化代码的实现。</p><h1 id="ostringstream"><strong>ostringstream</strong></h1><p>ostringstream 是 C++ 中用于输出字符串的流类。它继承自 ostream，可以将各种数据类型输出到一个字符串中，方便地 label primary构造字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ostringstream oss;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">42</span>;<br>    <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-comment">// 向 ostringstream 中输出数据</span><br>    oss &lt;&lt; <span class="hljs-string">&quot;The answer is: &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;, and the value of pi is: &quot;</span> &lt;&lt; pi;<br><br>    <span class="hljs-comment">// 获取 ostringstream 的内容（字符串）</span><br>    std::string result = oss.<span class="hljs-built_in">str</span>();<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// The answer is: 42, and the value of pi is: 3.14159</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="istringstream"><strong>istringstream</strong></h1><p><code>istringstream</code> 是 C++ 中用于<strong>输入字符串</strong>的流类。它继承自 istream，可以将一个字符串解析成各种数据类型，方便地从字符串中读取数据。</p><ol type="1"><li><code>istringstream</code>必须在定义的时候就初始化，<code>std::istringstream iss(data)</code></li><li>每次读取后应检查状态（如 <code>fail()</code>、<code>eof()</code>）</li><li>可以随时用 <code>.str()</code> 方法重置字符串内容</li><li>如果流进入错误状态（如读取失败），必须用 <code>clear()</code> 重置状态才能继续使用</li><li><code>std::istringstream</code> 会拷贝初始字符串，内存开销较小，但频繁创建/销毁可能影响性能。</li><li>可以通过<code>std::setprecision(5)</code>设置精度。具体用法<code>ss &lt;&lt; std::setprecision(5) &lt;&lt; num</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;John 25 3.14&quot;</span>;<br>    <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(data)</span></span>;<br><br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">double</span> pi;<br><br>    <span class="hljs-comment">// 从 istringstream 中读取数据</span><br>    iss &gt;&gt; name &gt;&gt; age &gt;&gt; pi;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value of pi: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="stringstream"><strong>stringstream</strong></h1><p>stringstream 是 C++ 中同时支持输入和输出的字符串流类。它继承自 iostream，可以将各种数据类型输出到一个字符串中，也可以从一个字符串中读取数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">42</span>;<br>    <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-comment">// 向 stringstream 中输出数据</span><br>    ss &lt;&lt; <span class="hljs-string">&quot;The answer is: &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;, and the value of pi is: &quot;</span> &lt;&lt; pi;<br><br>    <span class="hljs-comment">// 获取 stringstream 的内容（字符串）</span><br>    std::string result = ss.<span class="hljs-built_in">str</span>();<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 清空 stringstream</span><br>    ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    ss.<span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-comment">// 从一个字符串中读取数据</span><br>    std::string data = <span class="hljs-string">&quot;John 25 3.14&quot;</span>;<br>    ss &lt;&lt; data;<br><br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">double</span> value;<br><br>    <span class="hljs-comment">// 从 stringstream 中读取数据</span><br>    ss &gt;&gt; name &gt;&gt; age &gt;&gt; value;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我为什么是个学渣？</title>
    <link href="/posts/100616916/"/>
    <url>/posts/100616916/</url>
    
    <content type="html"><![CDATA[<p>今天在<a href="https://www.bilibili.com/video/BV1tTJuzMErq?spm_id_from=333.788.videopod.sections&amp;vd_source=e0aee50f101b406f0d1414f984f3f5c0">B站</a>上听到这个课程，醍醐灌顶，需要经常拿出来鞭策自己……</p><span id="more"></span><p>我为什么学习学不会，因为流程出现了问题。明确学习的过程分两个大阶段，<strong>输入</strong>和<strong>输出</strong>，少任何一个阶段任何一个环节都不可！</p><p>首先需要明确一点，学不明白，一定是这两个阶段出现的问题，不是智商不够，也不是天赋不够，也不是努力不够，先把这个流程走完了再谈其他。</p><p>要么输入有问题，要么输出偷懒，这两个部分没搞好，就不配说自己做出努力了！！！</p><p><img src="../pictures/20250523/06/1.png" /></p><p>输入：</p><ol type="1"><li>品质与质量：要输入高阶的知识，学习顶尖的思想，学习顶尖的方法，不要怕学不明白，要在思路上认为自己是优秀的，才能把知识学明白。对于此项，我最大的问题是畏难！</li><li>输入速度：能一天学会的，觉不拖拉两天，能一周学会的，觉不拖拉一个月，能一个月学会的，绝不拖拉半年。对于此项，要克服拖延症！</li><li>学习必要的知识：这个一定是前人已经总结好的，只需要自己拿过来即可，不需要自己总结，不用自己专研，一定向高人学习。这个需要有自己的判断，那些是必要的，那些是非必要的！比如目前，机器学习对我来说就不是必要的知识！</li><li>完整程度：保证知识的完备性，比如学完三角函数，一定要懂三角函数的所有性质。这个要学习体系的课程，看体系的书，不能东一榔头，西一棒槌的学习。</li></ol><p>输出：</p><ol type="1"><li>精确程度：输出一定要精确，不能模糊，得过且过。丁是丁，卯是卯，尤其是写代码，不能有一点含糊。</li><li>完整：输出一定要具备所有，不要觉得事情简单就跳过，每次跳一点，最后就失之毫厘谬以千里。</li></ol><p>在当前信息爆炸的时代，对于输入的知识，高品质与质量比较好找到，国外课程，优秀的专家，比比皆是……，完整度也不必担心，只要注重品质与质量，就能找到完整度比较高的知识。我最大的问题在于输入的速度，以及输入必要的知识。太过于拖拉，一件事情能拖很久也完不成。</p><p>对于输出，我几乎没有正确的输出过，更谈不上精度和准确度。接下来，对于每个知识点的学习，我都应该精准和完整的输出。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB:如何用x查看内存?</title>
    <link href="/posts/3364006008/"/>
    <url>/posts/3364006008/</url>
    
    <content type="html"><![CDATA[<p>GDB是C++程序员常用的工具，很多时候需要查看内存情况，本文主要介绍x命令的使用 <span id="more"></span></p><p>可以使用命令 <code>x</code>（“examine”的缩写）以多种格式检查内存，<strong>不受程序数据类型</strong>的限制。</p><p><strong>语法有以下3种：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x/nfu addr<br>x addr<br>x<br></code></pre></td></tr></table></figure><p>使用 <code>x</code> 命令检查内存，是本节的主题！</p><p><code>n</code>、<code>f</code> 和 <code>u</code> 是可选参数，用于指定<strong>显示多少内存</strong>以及<strong>如何格式化（其中fu可以换位置，无所谓）</strong>；</p><p><code>addr</code> 是一个表达式，表示开始显示内存的地址。如果使用 <code>nfu</code> 的默认值，可以省略斜杠 <code>/</code>。某些命令会为 <code>addr</code> 设置方便的默认值。</p><p><strong>参数说明：</strong></p><ol type="1"><li><p><strong><code>n</code>（重复计数）</strong></p><p>重复计数是一个十进制整数，默认值为 1。它指定要显示多少内存（以单位 <code>u</code> 字节计算）。如果指定负数，则从 <code>addr</code> 开始向后检查内存。</p></li><li><p><strong><code>f</code>（显示格式）</strong></p><p>显示格式是 <code>print</code> 命令使用的格式之一（如 <code>x</code>、<code>d</code>、<code>u</code>、<code>o</code>、<code>t</code>、<code>a</code>、<code>c</code>、<code>f</code>、<code>s</code>），还包括 <code>i</code>（机器指令）和 <code>m</code>（显示内存标签）。初始默认格式为 <code>x</code>（十六进制），每次使用 <code>x</code> 或 <code>print</code> 后默认格式会改变。经常使用的是<code>x</code>、<code>d</code>(十进制)、<code>u</code>(无符号数)</p></li><li><p><strong><code>u</code>（单位大小）</strong></p><p>单位大小可以是以下之一：</p><ul><li><code>b</code>：字节。</li><li><code>h</code>：半字（两个字节）。</li><li><code>w</code>：字（四个字节）。这是初始默认值。</li><li><code>g</code>：大字（八个字节）。每次使用 <code>x</code> 指定单位大小后，该单位会成为下次使用 <code>x</code> 时的默认单位。对于 <code>i</code> 格式，单位大小会被忽略且通常不写。对于 <code>s</code> 格式，单位大小默认为 <code>b</code>，除非显式指定。例如：<ul><li><code>x/hs</code> 显示 16 位字符字符串。</li><li><code>x/ws</code> 显示 32 位字符串。下次使用 <code>x/s</code> 时会恢复显示 8 位字符串。注意，结果取决于当前编译单元的编程语言。例如，C 语言中 <code>s</code> 会使用 UTF-16 编码，而 <code>w</code> 会使用 UTF-32。编码由编程语言决定，不可更改。</li></ul></li></ul></li><li><p><strong><code>addr</code>（起始地址）</strong></p><p><code>addr</code> 是 GDB 开始显示内存的地址。表达式不必是指针（但可以是），它始终被解释为字节内存的整数地址。默认地址通常是上次检查地址的下一个位置，但其他命令也会设置默认地址：</p><ul><li><code>info breakpoints</code>：设置为最后列出的断点地址。</li><li><code>info line</code>：设置为某行的起始地址。</li><li><code>print</code>：如果用它显示内存中的值。</li></ul></li></ol><p><strong>示例：</strong></p><ul><li><code>x/3uh 0x54320</code>：从地址 <code>0x54320</code> 开始，显示 3 个半字（<code>h</code>），格式为无符号十进制整数（<code>u</code>）。</li><li><code>x/4xw $sp</code>：以十六进制（<code>x</code>）显示栈指针（<code>$sp</code>）上方的 4 个字（<code>w</code>）。</li><li>指定负重复计数可反向检查内存。例如，<code>x/-3uh 0x54320</code> 会显示 <code>0x5431a</code>、<code>0x5431c</code> 和 <code>0x5431e</code> 处的 3 个半字。</li></ul><p><strong>顺序灵活性：</strong></p><p>单位大小字母和格式字母是独立的，顺序无关。例如 <code>4xw</code> 和 <code>4wx</code> 等效，但计数 <code>n</code> 必须在前（如 <code>wx4</code> 无效）。</p><p><strong>特殊格式说明：</strong></p><ul><li><code>i</code> 格式（机器指令）：即使忽略单位大小 <code>u</code>，仍可使用计数 <code>n</code>。例如 <code>3i</code> 显示 3 条指令（包括操作数）。为方便起见，<code>i</code> 还会显示分支延迟槽指令（如果有）。<code>disassemble</code> 是另一种检查指令的方式。</li><li><code>s</code> 或 <code>i</code> 格式的负计数：会从给定地址向前显示字符串或指令（数量为计数的绝对值）。对于 <code>i</code> 格式，使用调试信息中的行号准确定位指令边界；若无行信息，会报错停止。</li></ul><p><strong>默认行为：</strong></p><p><code>x</code> 的<strong>默认参数设计为便于连续扫描内存</strong>。例如：</p><ul><li>用 <code>x/3i addr</code> 检查 3 条指令后，可用 <code>x/7</code> 检查接下来的 7 条。</li><li>按 <code>RET</code> 重复 <code>x</code> 命令时，会复用上次的计数 <code>n</code>，其他参数按 <code>x</code> 的默认规则更新。 –&gt;</li></ul><p><strong>当前指令标记：</strong></p><p>检查机器指令时，当前程序计数器（PC）指向的指令会用 <code>=&gt;</code> 标记。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) x/<span class="hljs-number">5</span>i $pc<span class="hljs-number">-6</span><br>   <span class="hljs-number">0x804837f</span> &lt;main<span class="hljs-number">+11</span>&gt;: mov    %esp,%ebp<br>   <span class="hljs-number">0x8048381</span> &lt;main<span class="hljs-number">+13</span>&gt;: push   %ecx<br>   <span class="hljs-number">0x8048382</span> &lt;main<span class="hljs-number">+14</span>&gt;: sub    $<span class="hljs-number">0x4</span>,%esp<br>=&gt; <span class="hljs-number">0x8048385</span> &lt;main<span class="hljs-number">+17</span>&gt;: movl   $<span class="hljs-number">0x8048460</span>,(%esp)<br>   <span class="hljs-number">0x804838c</span> &lt;main<span class="hljs-number">+24</span>&gt;: call   <span class="hljs-number">0x80482d4</span> &lt;puts@plt&gt;<br></code></pre></td></tr></table></figure><p><strong>内存标签（<code>m</code> 格式）：</strong></p><p>若架构支持内存标签，可用 <code>m</code> 显示标签。标签按颗粒大小（一个标签覆盖的字节数）显示。例如 AArch64 的颗粒大小为 16 字节，因此每 16 字节显示一个标签。</p><p>由于 <code>x</code> 的输出不强制对齐边界，标签信息指向每行显示的初始地址。若一行中跨越标签边界，标签会在下一行显示。<code>m</code> 格式不影响其他指定的格式。</p><p><strong>历史记录：</strong></p><p><code>x</code> 命令输出的地址和内容不会保存在值历史中（因数据量可能过大）。但 GDB 会将其存入以下变量：</p><ul><li><code>$_</code>：最后检查的地址。</li><li><code>$__</code>：该地址的内容。若 <code>x</code> 有重复计数，保存的是最后打印的内存单元的地址和内容（可能与最后打印的地址不同）。</li></ul><p><strong>内存单元与字节：</strong></p><p>大多数目标的可寻址内存单元大小为 8 位（即一个字节）。但某些目标可能有其他大小。在 GDB 中：</p><ul><li>“可寻址内存单元”（或简称“内存单元”）指目标的数据块大小。</li><li>“字节”特指 8 位数据块（无论目标的内存单元大小如何）。多数系统中，两者是同义词。</li></ul><p><strong>比较内存与文件（<code>compare-sections</code>）：</strong></p><p>在远程调试或需要验证程序是否修改了只读段时，可用此命令：</p><p><code>compare-sections [section-name|-r]</code></p><ul><li>无参数：比较所有可加载段。</li><li><code>r</code>：比较所有只读可加载段。对于远程目标，若支持内存块 CRC 校验（<code>qCRC</code> 数据包），可加速比较。</li></ul><hr /><p><strong>总结：</strong></p><p>GDB 的 <code>x</code> 命令用于灵活检查内存，支持多种格式（如十六进制、指令、字符串等）和单位大小（字节、字等）。关键特性包括：</p><ol type="1"><li><strong>参数组合</strong>：<code>nfu</code> 分别控制数量、格式和单位，顺序灵活。</li><li><strong>默认继承</strong>：上次使用的参数（如单位、格式）会成为下次默认值。</li><li><strong>反向检查</strong>：负计数可从地址向前扫描。</li><li><strong>指令标记</strong>：当前 PC 指令用 <code>=&gt;</code> 高亮。</li><li><strong>内存标签</strong>：支持显示架构相关的内存标签（如 AArch64）。</li><li><strong>变量缓存</strong>：<code>$_</code> 和 <code>$__</code> 分别存储最后检查的地址和内容。</li><li><strong>字节与内存单元</strong>：明确区分术语，兼容不同寻址大小的目标。</li><li><strong>段比较</strong>：<code>compare-sections</code> 可验证内存与文件的一致性，支持远程加速。</li></ol><p>此命令是调试内存相关问题（如数据损坏、指令流分析）的核心工具，通过灵活的参数适应多种场景。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc/free详解</title>
    <link href="/posts/3614768602/"/>
    <url>/posts/3614768602/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>内存管理-侯捷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::allocate解析</title>
    <link href="/posts/1398903302/"/>
    <url>/posts/1398903302/</url>
    
    <content type="html"><![CDATA[<p>本文是对STL中标准分配器原理的剖析，通过13张流程图详尽在使用分配器时遇到的各种情况，值得好好揣摩… <span id="more"></span> # 不同编译器对标准分配器的实现</p><p><img src="../pictures/20250523/0601/image.png" /></p><p><img src="../pictures/20250523/0601/image%201.png" /></p><p><img src="../pictures/20250523/0601/image%202.png" /></p><ul><li>通过看源代码可得，以上两种分配器的<code>allocator</code>只是以<code>::operator new()</code>和<code>::operator delete()</code>完成<code>allocate()</code>和<code>deallocate()</code>。没有对内存进行管理，所以这两种编译器的分配效率并不高，因为直接使用<code>::operator new()</code>和<code>::operator delete()</code> 会产生大量的cookies。</li><li>v此处的分配是<strong>以指定的元素的类型为单位</strong>，比方说类型指定为 int，分配 512 就是 512 个 int</li><li>我们为什么要着重看容器的分配器呢？因为现在写代码大部分时间都是用容器，所以重视容器的效率</li></ul><h1 id="stdalloc概述">std::alloc概述</h1><p><img src="../pictures/20250523/0601/image%203.png" /></p><p><code>std::alloc</code>是STL中高效的内存分配器实现，分配器一定要提供两个重要的函数：<code>allocate()</code>（分配）和<code>deallocate()</code>（回收）</p><p><code>std::alloc</code>提供了16 条链表，超过这个链表最大管理的内存块大小范围（128 字节）的内存分配不再受 <code>std::alloc</code> 管理，而是通过 <code>malloc()</code> 进行分配，对于上图有如下解释：</p><ul><li>#0 串联 8 字节的内存块，#1 串联 16 字节的内存块，#2 串联 24 字节的内存块… 链表间的内存块相差 8 字节</li><li>如果容器中的每个元素需求的内存块的大小不是 8 的倍数，比如需要 6，则进入<code>std::alloc</code>这个系统后，会被调成 8；这个设计在所有的分配器上都一样，<code>malloc()</code> 也是这样的设计，一定会调整为设定好的边界</li><li>如果声明一个 vector，每个元素的大小都是 32 字节。#3 是管理 32 字节的内存块的，一开始 #3 是空的，它就会去挖（<code>malloc()</code>）一块 20 * 32 大小的内存以备使用（20 应该是开发 <code>std::alloc</code> 的人员的经验值）；当这 20 块 32 字节的内存使用完之后，又会再要 20* 32 字节大小的内存，以此类推</li><li>实际上挖的大小是 20* 32 字节，其中一半拿来切 32 字节的内存块，另一半空置等待使用</li><li>声明另一个 vector，每个元素的大小是 64 字节。需要 #7 链表来管理 64 字节的内存块，当 #7 链表需要的时候，将剩余的 20*32 切割成每个内存块 64 字节的大小，可以切出 10 个，可以看到它们 #3 和 #7 的内存块是相连的；至此，分配的内存都使用完了</li><li>再声明一个 vector，每个元素的大小是 96 字节。#11 是管理 96 字节内存块的，此时它是空的，而且之前 #3 多分出来的也都用光了，于是<code>malloc()</code> 20 * <em>6</em>2 字节内存，一半拿来用，一半备用</li><li>容器不再需要元素的时候，要归还内存，根据内存大小就回收到负责该大小的内存块的链表上</li><li>如果容器中的每个元素的大小为 256 字节，超出了链表的内存块的范围（8~128），于是调用 malloc 进行分配，将分配得到的空间传回给容器</li><li>容器每次动态分配得到的都是指针，它并不会知道分配到的内存是否带 cookie</li><li>最初分配的 20 * 2 的一大块是<code>malloc()</code>出来的，带 cookie，但<code>std::alloc</code>管理的内存块都是 cookie free 的</li></ul><p><img src="../pictures/20250523/0601/image%204.png" /></p><ul><li>链表借用每个内存块的前4个字节做指针，当把内存块分给容器后，这4个字节会被容器的数据填充，容器归还内存块后，分配器会重新把前 4 个字节用作指针，接到链表上。这种做法称为 embedded pointer（嵌入式指针）</li><li>好的内存管理一定会使用嵌入式指针，否则 class 里还要多设计一个指针</li><li>源代码中的<code>char client_data[1];</code>并没有用到，可以删除，删掉后是 union 还是 struct 就没区别了</li><li>如果对象本身小于 4 个字节，就不能被借用作指针了。但是通常对象大小会大于等于 4 字节</li></ul><h1 id="gnu-allocator-行为剖析">GNU allocator 行为剖析</h1><p>接下来会对alloc的行为进行解释，总共有13个幻灯片，对于每个幻灯片，解释为与下方。</p><p><img src="../pictures/20250523/0601/image%205.png" /></p><p>开始，定义了<code>free_list[16]</code></p><p><img src="../pictures/20250523/0601/image%206.png" /></p><ul><li>容器首次申请32字节，此时链表为空，直接调用malloc申请 32 * 20 * 2 + RoundUp(0&gt;&gt;4) = 1280个字节，从中切除1个返回用户，另外19个挂在list 3中，余下的640备用。</li><li>pool 指的就是之前说的多出来的备用空间，称它为战备池，由 start_free 和 end_free 两个指针围起来。只是蓝色的那个部分，注意区分。</li><li><code>RoundUp()</code>的作用是把数字上调到 8 的倍数，0&gt;&gt;4 指的是 0 右移 4 位，即 0 除以 16。RoundUp(0&gt;&gt;4) 结果是 0，这部分我们可以称为“追加量”</li><li>#3 是空的，先看 pool 有没有，发现也是空的，于是给 pool 申请 32 * 20 * 2 +RoundUp(0&gt;&gt;4) =1280 的空间。640 给客户，另一半 640 备用（pool）</li><li>这一整块是用<code>malloc()</code>分配的，头尾都有 cookie</li></ul><p><img src="../pictures/20250523/0601/image%207.png" /></p><ul><li>另一个容器申请 64 字节，因为 pool 有余量，所以从 pool 中切出 10 个，第一个给用户，剩余的9个挂在list 7。此时战备池已经为空了。注意7号链表的开始是从3号链表的末尾指上去的。</li><li>因为是同一块，所以没有产生额外cookie</li></ul><p><img src="../pictures/20250523/0601/image%208.png" /></p><ul><li>又有一个容器申请 96 字节</li><li>pool 是空的，用<code>malloc()</code>分配 96 * 20 * 2+RoundUp(1280&gt;&gt;4)= 3920，加上之前申请的1280，共5200。分出 20*96=1920，pool 留下 2000，这一大块是带 cookie 的</li><li>这里可以看出追加量的计算方式，<code>RoundUp()</code> 里是累计申请量&gt;&gt;4，即累计申请量/16，发现追加量会越来越大。为什么会有追加量，以及为何如此计算，源码的注释中并没有解释，不过这样的处理带来了安全阀门（后面讲解）</li></ul><p><img src="../pictures/20250523/0601/image%209.png" /></p><ul><li>又有一个容器申请88字节，pool 中有余量，分出20个（哪怕 pool 还有更多，最多也只能分出 20）。此时会将11号链表的剩下的所有的都挂在10号链表下面。所以此时战备此也在10号链表下面了。</li><li>分配为88 * 10个空间后，战备词还剩240个字节。</li></ul><p><img src="../pictures/20250523/0601/image%2010.png" /></p><ul><li>不再新建容器了，而是某个容器连续三次申请88</li><li>直接取出 3 个返回给容器，速度很快，不会影响原来战备池的大小。</li></ul><p><img src="../pictures/20250523/0601/image%2011.png" /></p><ul><li>又有一个容器申请 8 字节，pool中有余量大小为240，分出 20 个。分出20个还剩余80个字节。</li><li>如果不同的容器（vector、list、deque……）大小相同，会共用同一条链表</li></ul><p><img src="../pictures/20250523/0601/image%2012.png" /></p><ul><li>又有一个容器申请 104 字节</li><li>pool只有80，连 1 个都不够，这 80 便是内存碎片，需要先处理碎片</li><li>80归 #9 管理，所以处理方式就是把 80拨给 #9</li><li>然后<code>malloc()</code>分配 104<em>20</em>2+RoundUp(5200&gt;&gt;4)=4488</li></ul><p><img src="../pictures/20250523/0601/image%2013.png" /></p><ul><li>又有一个容器申请 112 字节，pool 中有余量，分出 20 个</li></ul><p><img src="../pictures/20250523/0601/image%2014.png" /></p><ul><li>又有一个容器申请 48 字节，pool 中有余量，分出 3 个。</li></ul><p>以上步骤把所有可能的情况都列出来了，下面看一下内存耗尽的话会发生什么</p><p><img src="../pictures/20250523/0601/image%2015.png" /></p><ul><li>为了测试，将系统内存大小设置为了 10000，而现在已经申请了 9688 了</li><li>又有一个容器申请 72 字节</li><li>pool 只有 24，是碎片，这 24 挂到 #2</li><li><code>malloc()</code>分配 72<em>20</em>2+RoundUp(9688&gt;&gt;4)，因为内存不足，<code>malloc()</code>失败</li><li>为了满足用户需求，从 #8 右侧找离 #8 最近的，发现 #9 有一个 80，于是从 80 中切出 72 给 #8，剩下 8 作为 pool，#9为空</li></ul><p><img src="../pictures/20250523/0601/image%2016.png" /></p><ul><li>又有一个容器申请 72 字节</li><li>pool 只有 8，分给 #0</li><li>从 #10 中拿出一块，72 给 #8，剩下 16 作为 pool</li></ul><p><img src="../pictures/20250523/0601/image%2017.png" /></p><ul><li>又有一个容器申请 120 字节</li><li>从 #14 右边找，发现右边的 #15 也是空的，山穷水尽，无法满足需求</li></ul><p><img src="../pictures/20250523/0601/image%2018.png" /></p><ul><li>如果要把小块合并：因为都是链表，指来指去的，很难找到相邻的两块或几块合并，而且链表长度也不确定，虽然理论上可行，但难度极高，其他分配器也没有实现这样操作的</li><li>如果要把系统剩下的 312 用光：比较简单，<code>malloc()</code> 失败的话，就把<code>malloc()</code>内的数值减半，直到成功，但 GCC 并没有这么做，后面会给出答案</li></ul><h1 id="gnu-alloc源码分析">GNU alloc源码分析</h1><p><img src="../pictures/20250523/0601/image%2019.png" /></p><p><img src="../pictures/20250523/0601/image%2020.png" /></p><p><img src="../pictures/20250523/0601/image%2021.png" /></p><ul><li>这是第一级分配器，前面讲的步骤都在第二级分配器中，如果第二级分配器分配失败就会来到第一级</li><li>第一级会模拟 new handler，不断循环给用户机会去分配</li><li>C++ 本来就有 new handler，没必要模拟，这里这么写可能是因为历史元素，GCC 4.9 就没有这个第一级分配，所以此处也跳过，不详细讲解</li><li>第一级分配器到 74 行截止。77~89 是换肤工程，第二级分配器的单位是字节，换肤工程可以把字节转换为元素的个数。</li></ul><p><img src="../pictures/20250523/0601/image%2022.png" /></p><ul><li>第二级分配器从 90 行开始。为了教学，多线程的部分都被拿掉了。</li><li>三行 enum 其实就是常量定义，因为历史原因没有写成 static const</li><li><code>ROUND_UP()</code>会将传入参数上调为 8 的倍数</li><li>union obj 是嵌入式指针，free_list_link 其实就是我们平时常写的 next</li><li>所有的数据和函数都是静态的，可见非常容易改写为 C 语言</li><li><code>FREELIST_INDEX()</code> 计算出申请的内存块应该由第几号链表提供；</li><li><code>refill()</code> 就是当链表为空的时候，要进行充值（即申请一大块内存）；</li><li><code>chunk_alloc()</code> 申请一大块内存；</li></ul><p><img src="../pictures/20250523/0601/image%2023.png" /></p><ul><li>最重要的<code>allocate()</code>和<code>deallocate()</code></li><li>my_free_list 是指针的指针，因为它指向 16 条链表的其中一个，而里面的元素又是个指向下面链表的指针</li><li>如果申请的内存的大小大于 128，就改用第一级分配器</li><li><code>my_free_list = free_list + FREELIST_INDEX(n);</code>表示定位到第几号链表</li><li>如果 result == 0 ，即链表为空，则需要充值；</li><li>如果不为空，便<code>my_free_list = result-&gt;free_list_link;</code>将第一块内存块给到用户，并向下移动指针；</li><li><code>deallocate()</code>接收指针，并把它还回链表。如果 n&gt;128 也会改用第一级去回收</li><li>两个问题<ul><li><code>deallocate()</code>没有将内存还给操作系统（free），而是将申请到的内存全部掌握在自己手中，不算内存泄露，但是这种做法是有争议的</li><li><code>deallocate()</code>并没有检查传入指针是不是这个 alloc 给出去的，如果这个指针指的大小不是 8 的倍数，可能会有灾难性的后果</li></ul></li></ul><p><img src="../pictures/20250523/0601/image%2024.png" /></p><p><img src="../pictures/20250523/0601/image%2025.png" /></p><ul><li>通过图片更好地展示上面代码的作用</li></ul><p><img src="../pictures/20250523/0601/image%2026.png" /></p><ul><li><code>chunk_alloc()</code>负责帮我们分配一大块区域</li><li>total_bytes 是 20 个的大小，bytes_left 是 pool 的大小</li><li>如果 pool 足够分出 20 个，就直接改 start_free 的位置，然后把 start_free 原先位置传回去</li><li>如果不够 20 个，但够 &gt;= 1 个，看够几个，然后分配</li><li>如果连 1 个都不够，就是 0 或碎片了，对碎片做处理</li></ul><p><img src="../pictures/20250523/0601/image%2027.png" /></p><ul><li>处理完碎片后 pool 为空，开始分配内存，让 start_free 和 end_free 指到对应位置，然后递归调用自己，因为 pool 大小足够了，所以肯定能满足要求，完成分配</li><li>如果<code>malloc()</code>失败，找右边的链表，拿出一块，放到 pool 中，然后再递归调用自己，完成分配</li><li>英文注释部分说明了为什么没有再申请更小的内存，后面 2.3.4 检讨部分会解释</li><li>G4.9 中 start_free 是通过 operator new 进行分配的，而非 malloc，所以可以重载 operator new 接管内存分配，这就是为什么我们在 2.4 节是用 4.9 版测试的</li></ul><p><img src="../pictures/20250523/0601/image%2028.png" /></p><ul><li><code>refill()</code>函数</li><li>20 是个 magic number，不大好，最好是写成常量或宏</li><li>交给<code>chunk_alloc()</code>去拿一大块内存</li><li>如果只有一个，直接返回，否则就建立自由链表</li><li>注意 for 循环是从 1 开始的，因为第一个要给出去，没必要再切割、链接</li><li>所谓切割就是把指针所指处转为 obj*（嵌入式指针）</li></ul><p><img src="../pictures/20250523/0601/image%2029.png" /></p><ul><li>因为数据是 static 的，所以需要在 class 外部定义</li></ul><h1 id="g4.9-pool-allocator-运行观察"><strong>G4.9 pool allocator 运行观察</strong></h1><p><img src="../pictures/20250523/0601/image%2030.png" /></p><ul><li>Foo(1) 是个临时对象，非动态分配的，存在于 stack，容器 c 的内存是通过 alloc 分配的，不带 cookie</li><li>new 底层是通过<code>malloc()</code>分配的，存在于 heap，分配的内存块带 cookie。<code>push_back()</code>到链表后也是不带 cookie 的。</li></ul><p><img src="../pictures/20250523/0601/image%2031.png" /></p><ul><li>208、218、255 行是数值比较，一般的习惯则是把变量写左边，把要比较的值写右边，这里之所以反着写，是因为如果把变量写左边，哪怕 == 写成 = 也会通过编译，数值写左边的话编译器可以帮我们找出问题</li><li>197 行的变量一直到 207 行才用到，中间做了许多操作，这样不好，应该把变量写到 206 行。因为如果是指针的话，中间的操作可能会使指针失效，出了问题后难以排查</li><li>136 和 210 行不用管 volatile。<code>obj* *my_free_list, *p;</code> 的意思是<code>obj** my_free_list</code>和<code>obj* p</code>，所以它这种写法很容易搞错，建议分开写</li><li>34 行的内容等同于右边框里的两行，硬要把这两行写成一行，纯属炫技，可读性差</li><li>212、213、214 行说如果尝试申请小内存，会在多进程机器上造成大灾难，意思不是说这个程序会怎么样，而是如果把内存都占用光，机器上的其他程序会没有内存可用</li><li><code>deallocate()</code>没有调用<code>free()</code>或<code>delete()</code>，源于其设计上的先天缺陷：交给客户的内存块没有指针一直记录着其地址，所以归还的时候不知道地址，就无法回收。后面第四部分讲 Loki allocator 时会处理这个问题</li></ul><p><img src="../pictures/20250523/0601/image%2032.png" /></p><ul><li>为了测试是否真的节省了 cookie，编写测试代码，通过重写 operator new/delete 统计总分配量和总释放量</li><li>右边为什么 (1) (2) 可以并存老师也不知道</li></ul><p><img src="../pictures/20250523/0601/image%2033.png" /></p><ul><li>右侧 lst 默认使用的是标准分配器，每个元素都带 cookie。double 占 8 字节，每个节点带两个指针，一个元素就是 16 字节，<code>push_back()</code>1000000 次，总共执行了 1000000 次<code>malloc()</code>，分配了 16000000 字节，这 1000000 次每次都带 cookie</li><li>左侧 lst 使用的分配器为 __pool_alloc，<code>push_back()</code>1000000 次，总共只执行了 122 次<code>malloc()</code>，分配了 16752832 字节，122 次每次都带 cookie，可见差距之大</li><li>不能观察到 malloc 真正分配出去的总量（含所有 overhead），因为 malloc 不能重载，除非你有很高的技巧，清楚地理解了 malloc 的行为模式，理解了它管理的每个区块其实是个链表，知道了链表的头，遍历一遍，就能得到内存块的大小。第三讲我们会为大家建立起这种能力</li></ul><h1 id="g2.9-stdalloc-移植至c"><strong>G2.9 std::alloc 移植至C</strong></h1><p><img src="../pictures/20250523/0601/image%2034.png" /></p>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>内存管理-侯捷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存原语</title>
    <link href="/posts/572525303/"/>
    <url>/posts/572525303/</url>
    
    <content type="html"><![CDATA[<p>本文是对侯捷老师内存管理课程学习记录与总结，原课程见<a href="https://www.youtube.com/playlist?list=PLTcwR9j5y6W2eH37R2_4oEO4Y0tksot56">此处</a>,其中本文是对第一节的整理，第一节是关于内存原语~</p><span id="more"></span><h1 id="使用内存的方式有哪些">使用内存的方式有哪些？</h1><p>在日常的开发环境中，我们都是在应用层进行开发，其直接接触内存的方式有多种。如下图</p><figure><img src="../pictures/20250522/eda72137-4d4d-4349-9b25-987a8ef9aa16.png" alt="" /><figcaption>image.png</figcaption></figure><ol type="1"><li>直接使用标准库，比如STL</li><li>使用C++提供的管理内存的方式，比如<code>new</code>，<code>delete</code>，<code>operator new()</code>,<code>operator delete()</code></li><li>使用C提供的内存管理方式，<code>malloc/free</code></li><li>直接使用OS的API(几乎没)，此种方式和操作会和操作系统及其绑定。</li></ol><h1 id="c-memory-primitives">C++ memory primitives</h1><table><thead><tr class="header"><th>分配</th><th>释放</th><th>归属</th><th>是否可重载</th><th>单位</th></tr></thead><tbody><tr class="odd"><td><code>malloc()</code></td><td><code>free()</code></td><td>C 函数</td><td>不可</td><td>byte</td></tr><tr class="even"><td><code>new</code></td><td><code>delete</code></td><td>C++ 表达式(expressions)</td><td>不可</td><td>object</td></tr><tr class="odd"><td><code>::operator new()</code></td><td><code>::operator delete()</code></td><td>C++ 函数</td><td>可</td><td>byte</td></tr><tr class="even"><td><code>allocator&lt;T&gt;::allocate()</code></td><td><code>allocator&lt;T&gt;::deallocate()</code></td><td>C++ 标准库</td><td>可以自由设计并搭配容器</td><td>需要填入T，因此是object</td></tr></tbody></table><p>无论是什么方式，在CRT(<strong>C run-time library</strong>)时，基本都是执行的<code>malloc/free</code> ，对于不同的编译器，其allocate函数的接口也有所不同：</p><figure><img src="../pictures/20250522/image.png" alt="" /><figcaption>image.png</figcaption></figure><p>对于GNU C，不同版本又有所不同：</p><figure><img src="../pictures/20250522/image%201.png" alt="" /><figcaption>image.png</figcaption></figure><p>这张图中的<code>gnu_cxx::pool_alloc&lt; T &gt;().allocate()</code>对应于上张图中的<code>allocator&lt; T &gt;().allocate()</code>。</p><p>通过<code>malloc</code>和<code>new</code>分配内存、通过<code>free</code>和<code>delete</code>释放内存是十分常用的，通过<code>::operator new</code>操作内存比较少见，<code>allocator</code>分配器操作内存在STL源码中使用较多，对于不同的编译环境使用也有所不同。</p><h1 id="基本构件之一-newdelete-expression"><strong>基本构件之一 new/delete expression</strong></h1><h2 id="内存申请">1. 内存申请</h2><figure><img src="../pictures/20250522/image%202.png" alt="" /><figcaption>image.png</figcaption></figure><p>上面这张图揭示了new操作背后编译器做的事：</p><ul><li>1、通过<code>operator new()</code>操作分配一个目标类型的内存大小，这里是<code>Complex</code>的大小；</li><li>2、通过<code>static_cast</code>将得到的内存块强制转换为目标类型指针，这里是<code>Complex*</code></li><li>3、调用目标类型的构造方法，但是需要注意的是，直接通过<code>pc-&gt;Complex::Complex(1, 2)</code>这样的方法调用构造函数<strong>只有编译器可以做</strong>，用户这样做将产生错误。</li></ul><p>值得注意的是，<code>operator new()</code>操作的内部是调用了<code>malloc()</code>函数。</p><h2 id="内存释放">2. 内存释放</h2><figure><img src="../pictures/20250522/image%203.png" alt="" /><figcaption>image.png</figcaption></figure><p>同样地，<code>delete</code>操作第一步也是调用了对象的析构函数，然后再通过operator delete()函数释放内存，本质上也是调用了<code>free</code>函数。</p><h2 id="编译器模拟调用构造函数和析构函数">3. 编译器模拟调用构造函数和析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">//#include &lt;memory&gt;              //std::allocator  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> jj02<br>&#123;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> id;<br><br>        <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>)      &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor. this=&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;ctor. this=&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;<br>        ~<span class="hljs-built_in">A</span>()             &#123; cout &lt;&lt; <span class="hljs-string">&quot;dtor. this=&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_call_ctor_directly</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\ntest_call_ctor_directly().......... \n&quot;</span>;<br><br>        string* pstr = <span class="hljs-keyword">new</span> string;<br>        cout &lt;&lt; <span class="hljs-string">&quot;str= &quot;</span> &lt;&lt; *pstr &lt;&lt; endl;<br>        <span class="hljs-comment">//! pstr-&gt;string::string(&quot;jjhou&quot;);  </span><br>        <span class="hljs-comment">//[Error] &#x27;class std::basic_string&lt;char&gt;&#x27; has no member named &#x27;string&#x27;</span><br>        <span class="hljs-comment">//! pstr-&gt;~string();    //crash -- 其語法語意都是正確的, crash 只因為上一行被 remark 起來嘛.  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;str= &quot;</span> &lt;&lt; *pstr &lt;&lt; endl;<br>            <span class="hljs-comment">//------------</span><br><br>        A* pA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">//ctor. this=000307A8 id=1</span><br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     <span class="hljs-comment">//1</span><br>        pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>);<br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;<br>        <span class="hljs-comment">//! pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3</span><br>        <span class="hljs-comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span><br><br>        A::<span class="hljs-built_in">A</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//! A::A(5);                    //in VC6 : ctor. this=0013FF60 id=5</span><br>        <span class="hljs-comment">//         dtor. this=0013FF60      </span><br>        <span class="hljs-comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly</span><br>        <span class="hljs-comment">//         [Note] for a function-style cast, remove the redundant &#x27;::A&#x27;</span><br><br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     <span class="hljs-comment">//in VC6 : 3</span><br>        <span class="hljs-comment">//in GCC : 1    </span><br><br>        <span class="hljs-keyword">delete</span> pA;                  <span class="hljs-comment">//dtor. this=000307A8 </span><br><br>        <span class="hljs-comment">//simulate new</span><br>        <span class="hljs-type">void</span>* p = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(A));<br>        cout &lt;&lt; <span class="hljs-string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">//p=000307A8</span><br>        pA = <span class="hljs-built_in">static_cast</span>&lt;A*&gt;(p);<br>        pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//! pA-&gt;A::A(2);                //in VC6 : ctor. this=000307A8 id=2</span><br>        <span class="hljs-comment">//in GCC : [Error] cannot call constructor &#x27;jj02::A::A&#x27; directly    </span><br><br>        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     <span class="hljs-comment">//in VC6 : 2</span><br>        <span class="hljs-comment">//in GCC : 0    </span><br><br>        <span class="hljs-comment">//simulate delete</span><br>        pA-&gt;~<span class="hljs-built_in">A</span>();                   <span class="hljs-comment">//dtor. this=000307A8 </span><br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pA)</span></span>;      <span class="hljs-comment">//free()</span><br>    &#125;<br>&#125; <span class="hljs-comment">//namespace</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    jj02::<span class="hljs-built_in">test_call_ctor_directly</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">215.1</span>.cpp: In function ‘<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jj02::test_call_ctor_directly</span><span class="hljs-params">()</span>’:</span><br><span class="hljs-function"><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">33</span>:<span class="hljs-number">16</span>: error: cannot call constructor ‘jj02::A::A’ directly</span><br><span class="hljs-function">   <span class="hljs-number">33</span> |         pA-&gt;A::A(<span class="hljs-number">3</span>);</span><br>      |                ^<br><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">38</span>:<span class="hljs-number">13</span>: error: cannot call constructor ‘jj02::A::A’ directly [-fpermissive]<br>   <span class="hljs-number">38</span> |         A::<span class="hljs-built_in">A</span>(<span class="hljs-number">5</span>);<br>      |         ~~~~^~~<br><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">38</span>:<span class="hljs-number">13</span>: note: <span class="hljs-keyword">for</span> a function-style cast, remove the redundant ‘::A’<br><span class="hljs-number">215.1</span>.cpp:<span class="hljs-number">53</span>:<span class="hljs-number">16</span>: error: cannot call constructor ‘jj02::A::A’ directly<br>   <span class="hljs-number">53</span> |         pA-&gt;A::<span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">// 将所有直接调用构造函数的注释掉，在GNU中得到如下</span><br> <span class="hljs-built_in">test_call_ctor_directly</span>().......... <br>str= <br>str= <br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae32b62f0</span> id=<span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae32b62f0</span> id=<span class="hljs-number">1</span> <span class="hljs-comment">// 调用delete</span><br>p=<span class="hljs-number">0xaaaae32b62f0</span> <span class="hljs-comment">// 调用::operator new()</span><br><span class="hljs-number">-1431424330</span> <span class="hljs-comment">// 由于无法模拟调用构造函数，因此是未知数据</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae32b62f0</span> id=<span class="hljs-number">-1431424330</span> <span class="hljs-comment">// 调用析构函数</span><br></code></pre></td></tr></table></figure><p>代码是直接复制的侯捷老师的代码，执行结果如上所示。VS下可以直接通过内存空间调用构造函数，但GNU C下无法通过，具体的内容可见代码注解和打印效果。</p><h1 id="基础构件之二-array-newdelete">基础构件之二 Array new/delete</h1><figure><img src="../pictures/20250522/image%204.png" alt="" /><figcaption>image.png</figcaption></figure><p>上图主要展示的是关于<code>new array</code>内存分配的大致情况。当<code>new</code>一个<strong>数组对象</strong>时（例如 <code>new Complex[3]</code>），编译器将分配一块内存，这块内存首部是关于对象内存分配的一些标记，然后下面会分配三个连续的对象内存，在使用<code>delete</code>释放内存时需要使用<code>delete[]</code>。如果不使用<code>delete[]</code>，只是使用<code>delete</code>会根据这块内存的cookies，只会将分配的三块内存空间释放，但不会调用对象的析构函数，如果对象内部还使用了<code>new</code>指向其他空间，如果指向的该空间里的对象的析构函数没有意义（没有申请新的内存），那么不会造成问题，如果有意义（申请了新的内存），那么由于该部分对象析构函数不会调用，那么将会导致内存泄漏。图中<code>new string[3]</code>便是一个例子，虽然<code>str[0]</code>、<code>str[1]</code>、<code>str[2]</code>被析构了，但只是调用了<code>str[0]</code>的析构函数，其他对象的析构函数不被调用，这里就会出问题。</p><p>接下来对上述进行代码验证！！！</p><figure><img src="../pictures/20250522/image%205.png" alt="" /><figcaption>image.png</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> id;<br>  <br>  <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>)      &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl;  &#125;<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl;  &#125;<br>  ~<span class="hljs-built_in">A</span>()             &#123; cout &lt;&lt; <span class="hljs-string">&quot;dtor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; endl;  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br><span class="hljs-comment">//case 1</span><br><span class="hljs-comment">//模拟 memory pool 的作法, array new + placement new. 崩潰 </span><br> <br>    A* buf = (A*)(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(A)*size]); <span class="hljs-comment">// 注意这里是new的char</span><br>    A* tmp = buf;   <br>       <br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        <span class="hljs-keyword">new</span> (tmp++) <span class="hljs-built_in">A</span>(i);  <span class="hljs-comment">//3次 ctor </span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>            <br>    <span class="hljs-comment">//!delete [] buf;    //crash. why?</span><br>                        <span class="hljs-comment">//因为new的是一个 char array，编译器看到 delete [] buf; 编译器企图调用多次 A::~A. </span><br>                        <span class="hljs-comment">// 但 array memory layout 中找不到与 array 元素个数 (本例 3) 相关的信息, </span><br>                        <span class="hljs-comment">// -- 整个内存布局都乱掉，於是崩潰。 </span><br>    <span class="hljs-keyword">delete</span> buf;     <span class="hljs-comment">//dtor just one time, ~[0]</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 调用delete buf</span><br><span class="hljs-built_in">test_placement_new</span>()..........<br>buf=<span class="hljs-number">0xaaaae6feb2c0</span>  tmp=<span class="hljs-number">0xaaaae6feb2c0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c0</span> id=<span class="hljs-number">0</span> <span class="hljs-comment">// 相差4个字节是因为类A的大小是4个字节</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c4</span> id=<span class="hljs-number">1</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c8</span> id=<span class="hljs-number">2</span><br>buf=<span class="hljs-number">0xaaaae6feb2c0</span>  tmp=<span class="hljs-number">0xaaaae6feb2cc</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae6feb2c0</span> id=<span class="hljs-number">0</span> <span class="hljs-comment">// 只调用了第一个元素的构造函数</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 调用delete [] buf</span><br><span class="hljs-built_in">test_placement_new</span>()..........<br>buf=<span class="hljs-number">0xaaaace26f2c0</span>  tmp=<span class="hljs-number">0xaaaace26f2c0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c0</span> id=<span class="hljs-number">0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c4</span> id=<span class="hljs-number">1</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c8</span> id=<span class="hljs-number">2</span><br>buf=<span class="hljs-number">0xaaaace26f2c0</span>  tmp=<span class="hljs-number">0xaaaace26f2cc</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f340</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f33c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f338</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f334</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f330</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f32c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f328</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f324</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f320</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f31c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f318</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f314</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f310</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f30c</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f308</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f304</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f300</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2fc</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2f8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2f4</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2f0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2ec</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2e8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2e4</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2e0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2dc</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2d8</span> id=<span class="hljs-number">60721</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2d4</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2d0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2cc</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c8</span> id=<span class="hljs-number">2</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c4</span> id=<span class="hljs-number">1</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaace26f2c0</span> id=<span class="hljs-number">0</span><br><span class="hljs-built_in">free</span>(): invalid pointer<br>[<span class="hljs-number">1</span>]    <span class="hljs-number">1773946</span> <span class="hljs-built_in">abort</span> (core dumped)  ./a<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br><span class="hljs-comment">//case 2</span><br><span class="hljs-comment">// test array new</span><br>    A* buf = <span class="hljs-keyword">new</span> A[size];  <span class="hljs-comment">//default ctor 3 次. [0]先于[1]先于[2])</span><br>             <span class="hljs-comment">//A有 default ctor, 否则 [Error] no matching function for call to &#x27;jj02::A::A()&#x27;</span><br>    A* tmp = buf;   <br>       <br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        <span class="hljs-keyword">new</span> (tmp++) <span class="hljs-built_in">A</span>(i);  <span class="hljs-comment">//3次 ctor </span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;buf=&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;  tmp=&quot;</span> &lt;&lt; tmp &lt;&lt; endl;<br>            <br>    <span class="hljs-keyword">delete</span> [] buf;    <span class="hljs-comment">//dtor three times (次序逆反, [2]先于[1]先于[0])</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_placement_new</span>()..........<br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442c8</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442cc</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442d0</span> id=<span class="hljs-number">0</span><br>buf=<span class="hljs-number">0xaaaaee7442c8</span>  tmp=<span class="hljs-number">0xaaaaee7442c8</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442c8</span> id=<span class="hljs-number">0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442cc</span> id=<span class="hljs-number">1</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442d0</span> id=<span class="hljs-number">2</span><br>buf=<span class="hljs-number">0xaaaaee7442c8</span>  tmp=<span class="hljs-number">0xaaaaee7442d4</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442d0</span> id=<span class="hljs-number">2</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442cc</span> id=<span class="hljs-number">1</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaee7442c8</span> id=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>构造函数调用顺序是按照构建对象顺序来执行的，但是析构函数执行却相反。值得注意的是，在调用了<code>delete</code>的case1的代码段中，数组有三个元素，但最后只调用了第一个对象的析构函数。</p><p>接下来将更具体地展示new array对象的内存分配情况：</p><figure><img src="../pictures/20250522/image%206.png" alt="" /><figcaption>image.png</figcaption></figure><p>如果使用<code>new</code>分配十个内存的<code>int</code>，内存空间如上图所示，首先内存块会有一个头和尾，黄色部分为debug信息，灰色部分才是真正使用到的内存，蓝色部分的12 bytes是为了让该内存块以16字节对齐。在这个例子中<code>delete pi</code>和<code>delete[] pi</code>效果是一样的，因为<code>int</code>没有析构函数。但是下面的例子就不一样了：</p><figure><img src="../pictures/20250522/image%207.png" alt="" /><figcaption>image.png</figcaption></figure><p>上图通过<code>new</code>申请三个<code>Demo</code>空间大小，内存块使用了96 byte，这里是这样计算得到的：黄色部分调试信息32 + 4 = 36 byte；黄色部分下面的“3”用于标记实际分配给对象内存个数，这里是三个所以里面内容为3，消耗4 byte；<code>Demo</code>内有三个<code>int</code>类型成员变量，一个<code>Demo</code>消耗内存3 * 4 = 12 byte，由于有三个<code>Demo</code>，所以消耗了12 * 3 = 36 <code>byte</code>空间；到目前为止消耗36 + 4 + 36 = 76 byte，加上头尾<code>cookie</code>一共8 <code>byte</code>一共消耗84 <code>byte</code>，由于需要16位对齐，所以填充蓝色部分为12 byte，一共消耗了84 + 12 = 96 <code>byte</code>。这里释放内存时需要加上<code>delete[]</code>，上面分配内存中有个标记“3”，所以编译器将释放三个Demo对象空间，如果不加就会报错。</p><p>因为在内存的布局中了多了个3，是因为构造函数是<code>no-trivial</code>的。整个内存布局就不同了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-type">int</span> x, y, z; <span class="hljs-comment">// 假设有三个int成员变量</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Demo</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// ~Demo() &#123;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; &quot;Destructor called&quot; &lt;&lt; std::endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Demo* p = <span class="hljs-keyword">new</span> Demo[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br>Constructor called<br>Constructor called<br>Constructor called<br></code></pre></td></tr></table></figure><p>假如析构函数是<code>no-trivial</code>，即把注释去掉，就必须调用<code>delete []</code>，否则会出现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a.cpp: In function ‘<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>’:</span><br><span class="hljs-function">a.cpp:<span class="hljs-number">88</span>:<span class="hljs-number">12</span>: warning: ‘void operator delete(void*, std::size_t)’ called on pointer ‘&lt;unknown&gt;’ with nonzero offset <span class="hljs-number">8</span> [-Wfree-nonheap-object]</span><br><span class="hljs-function">   <span class="hljs-number">88</span> |     delete p;</span><br>      |            ^<br>a.cpp:<span class="hljs-number">87</span>:<span class="hljs-number">25</span>: note: returned from ‘<span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> [](std::<span class="hljs-type">size_t</span>)’<br>   <span class="hljs-number">87</span> |     Demo* p = <span class="hljs-keyword">new</span> Demo[<span class="hljs-number">3</span>];<br><br><span class="hljs-function">Constructor called</span><br><span class="hljs-function">Constructor called</span><br><span class="hljs-function">Constructor called</span><br><span class="hljs-function">Destructor called</span><br><span class="hljs-function"><span class="hljs-title">munmap_chunk</span><span class="hljs-params">()</span>: invalid pointer</span><br><span class="hljs-function">[<span class="hljs-number">1</span>]    <span class="hljs-number">1779694</span> abort (core dumped)  ./a</span><br></code></pre></td></tr></table></figure><h1 id="基础构件之三-placement-newdelete">基础构件之三 placement new/delete</h1><figure><img src="../pictures/20250522/image%208.png" alt="" /><figcaption>image.png</figcaption></figure><h1 id="基本构件之分配流程">基本构件之分配流程</h1><figure><img src="../pictures/20250522/image%209.png" alt="" /><figcaption>image.png</figcaption></figure><p>在应用程序调用<code>new</code>和<code>delete</code>之后，编译器会调用<code>operator new/delete</code>，在正常的情况下，是调用全局的<code>operator new/delete</code>，走第二条路线，但是如果类中有重载<code>operator new/delete</code>时，会走第一条路线。注意<code>new expression</code>（即第一层<code>new</code>）是不可改变不可重载的。正式因为可以重做类中的<code>operator new/delete</code>，程序员才有机会将内存管理接管过来，做更细致和高效的内存管理。</p><aside><p>💡 我们的目标是把第二条线路接管过来，走第一条线路。如此，我们就可以做类的内存管理了</p></aside><figure><img src="../pictures/20250522/image%2010.png" alt="" /><figcaption>image.png</figcaption></figure><p>对于GNU C，背后使用的<code>allocate()</code>函数最后也是调用了系统的<code>::operator new()</code>函数。</p><h1 id="基本构件之重载">基本构件之重载</h1><figure><img src="../pictures/20250522/image%2011.png" alt="" /><figcaption>image.png</figcaption></figure><p>上面这张图演示了如何重载系统的<code>::operator new()</code>函数，该方法最后也是模拟了系统的做法，效果和系统的方法一样，但一般不推荐重载<code>::operator new()</code>函数，因为它对全局有影响，如果使用不当将造成很大的问题。</p><p>如果是在类中重载<code>operator new()</code>方法，那么该方法有N多种形式，但必须保证函数参数列表第一个参数是<code>size_t</code>类型变量；对于<code>operator delete()</code>，第一个参数必须是<code>void*</code> 类型，第二个<code>size_t</code>是可选项，可以去掉。</p><figure><img src="../pictures/20250522/image%2012.png" alt="" /><figcaption>image.png</figcaption></figure><p>对于<code>operator new[]</code>和<code>operator delete[]</code>函数的重载，和前面类似。</p><figure><img src="../pictures/20250522/image%2013.png" alt="" /><figcaption>image.png</figcaption></figure><figure><img src="../pictures/20250522/image%2014.png" alt="" /><figcaption>image.png</figcaption></figure><figure><img src="../pictures/20250522/image%2015.png" alt="" /><figcaption>image.png</figcaption></figure><figure><img src="../pictures/20250522/image%2016.png" alt="" /><figcaption>image.png</figcaption></figure><p>代码如下，在下面代码中，尽管重载了operator new，operator delete等。但是在底层还是用的malloc和free，只是加了些打印的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> _id; <span class="hljs-comment">// 4 bytes</span><br>  <span class="hljs-type">long</span> _data; <span class="hljs-comment">// 8 bytes</span><br>  string _str; <span class="hljs-comment">// 32 bytes</span><br>  <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* deadObject, <span class="hljs-type">size_t</span> size)</span></span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size);<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* deadObject, <span class="hljs-type">size_t</span> size);    <br>  <br>  <span class="hljs-built_in">Foo</span>() : _id(<span class="hljs-number">0</span>)      &#123; cout &lt;&lt; <span class="hljs-string">&quot;default ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; endl;  &#125;<br>  <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> i) : _id(i) &#123; cout &lt;&lt; <span class="hljs-string">&quot;ctor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; endl;  &#125;<br>  <span class="hljs-comment">//virtual </span><br>  ~<span class="hljs-built_in">Foo</span>()              &#123; cout &lt;&lt; <span class="hljs-string">&quot;dtor. this=&quot;</span>  &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot; id=&quot;</span> &lt;&lt; _id &lt;&lt; endl;  &#125;<br>  <br>  <span class="hljs-comment">//不加 virtual dtor, sizeof = 48, new Foo[5] =&gt; operator new[]() 的 size 参数是 64, </span><br>  <span class="hljs-comment">//加了 virtual dtor, sizeof = 56, new Foo[5] =&gt; operator new[]() 的 size 参数是 84, </span><br>  <span class="hljs-comment">//上述二例，多出來的 4 可能就是個 size_t 欄位用來放置 array size. </span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span>* Foo::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    Foo* p = (Foo*)<span class="hljs-built_in">malloc</span>(size);  <br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator new(), size=&quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot;\t  return: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> Foo::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator delete(), pdead= &quot;</span> &lt;&lt; pdead &lt;&lt; <span class="hljs-string">&quot;  size= &quot;</span> &lt;&lt; size &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(pdead);<br>&#125;<br><br><span class="hljs-type">void</span>* Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size)<br>&#123;<br>    Foo* p = (Foo*)<span class="hljs-built_in">malloc</span>(size);  <span class="hljs-comment">//crash, 問題可能出在這兒 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator new[](), size=&quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot;\t  return: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <br>    <br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-type">void</span> Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Foo::operator delete[](), pdead= &quot;</span> &lt;&lt; pdead &lt;&lt; <span class="hljs-string">&quot;  size= &quot;</span> &lt;&lt; size &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">free</span>(pdead);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 测试语句</span><br>&#123;<br>Foo* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">7</span>);<br><span class="hljs-keyword">delete</span> p;<br><br>Foo* pArray = <span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];<span class="hljs-comment">//無法給 array elements 以 initializer</span><br><span class="hljs-keyword">delete</span> [] pArray;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_overload_operator_new_and_array_new</span>()..........<br><span class="hljs-built_in">sizeof</span>(Foo)= <span class="hljs-number">56</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(), size=<span class="hljs-number">56</span>  <span class="hljs-keyword">return</span>: <span class="hljs-number">0xaaaaf47622c0</span><br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47622c0</span> id=<span class="hljs-number">7</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47622c0</span> id=<span class="hljs-number">7</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(), pdead= <span class="hljs-number">0xaaaaf47622c0</span>  size= <span class="hljs-number">56</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](), size=<span class="hljs-number">288</span>  <span class="hljs-keyword">return</span>: <span class="hljs-number">0xaaaaf4762300</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762308</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762340</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762378</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623b0</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623e8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623e8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf47623b0</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762378</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762340</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaaf4762308</span> id=<span class="hljs-number">0</span><br>Foo::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](), pdead= <span class="hljs-number">0xaaaaf4762300</span>  size= <span class="hljs-number">288</span><br></code></pre></td></tr></table></figure><p>分析：当执行<code>Foo* p = new Foo(7);</code>时，编译器会调用类重载的<code>void* Foo::operator new(size_t size)</code>函数，其中参数<code>size_t</code>会自动识别为类的大小56，然后调用类的构造函数，传入的参数为7，而后执行delete p;时，会先调用类的析构函数，然后执行调用类重载的<code>void Foo::operator delete(void* pdead, size_t size)，</code>参数为自动传入的，大小也为类的大小56</p><p>当执行<code>Foo* pArray = new Foo[5];</code>，编辑器会自动调用<code>void* Foo::operator new[](size_t size)</code>，然后传入的<code>size_t</code>是288，这个参数也是自动传入的。然后调用5次类的构造函数。执行<code>void Foo::operator delete[](void* pdead, size_t size)</code>，按逆序自动调用类的析构函数后，然后调用类重载的<code>void Foo::operator delete[](void* pdead, size_t size)</code>，参数也是自动传入的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>&#123;    <br>cout &lt;&lt; <span class="hljs-string">&quot;testing global expression ::new and ::new[] \n&quot;</span>;<br><span class="hljs-comment">// 這會繞過 overloaded new(), delete(), new[](), delete[]() </span><br><span class="hljs-comment">// 但當然 ctor, dtor 都會被正常呼叫.  </span><br><br>Foo* p = ::<span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">7</span>);<br>::<span class="hljs-keyword">delete</span> p;<br><br>Foo* pArray = ::<span class="hljs-keyword">new</span> Foo[<span class="hljs-number">5</span>];<br>::<span class="hljs-keyword">delete</span> [] pArray;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_overload_operator_new_and_array_new</span>()..........<br><span class="hljs-built_in">sizeof</span>(Foo)= <span class="hljs-number">48</span><br>testing global expression ::<span class="hljs-keyword">new</span> <span class="hljs-keyword">and</span> ::<span class="hljs-keyword">new</span>[]<br>ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d092c0</span> id=<span class="hljs-number">7</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d092c0</span> id=<span class="hljs-number">7</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09308</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09338</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09368</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09398</span> id=<span class="hljs-number">0</span><br><span class="hljs-keyword">default</span> ctor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d093c8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d093c8</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09398</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09368</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09338</span> id=<span class="hljs-number">0</span><br>dtor. <span class="hljs-keyword">this</span>=<span class="hljs-number">0xaaaae8d09308</span> id=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当使用全局的<code>new</code>和<code>delete</code>时，会跳过重载的函数。</p><figure><img src="../pictures/20250522/image%2017.png" alt="" /><figcaption>image.png</figcaption></figure><ol type="1"><li><strong>重载 <code>operator new()</code></strong>：<ul><li>可以为类定义多个版本的 <code>operator new()</code>。</li><li>每个版本必须有独特的参数列表，其中第一个参数必须是 <code>size_t</code>，因为<code>Foo</code>的大小会被传入函数里面，所以第一个必须为<code>size_t</code>于接受类型的大小。</li><li>额外参数称为 placement arguments，可以在 <code>new</code> 表达式中传递。</li><li>示例：<code>Foo* pf = new (300, 'c') Foo;</code> 使用了 placement new。</li></ul></li><li><strong>重载 <code>operator delete()</code></strong>：<ul><li>也可以为类定义多个版本的 <code>operator delete()</code>。</li><li>这些版本不会被常规的 <code>delete</code> 调用。</li><li>只有当 <code>new</code> 所调用的构造函数抛出异常时，才会调用这些重载的 <code>operator delete()</code>。原因是在C++中，如果<code>new</code>完数据后，构造函数构造失败，需要能够<code>delete</code>掉内存。主要用于处理未能成功构造对象时释放内存。</li></ul></li></ol><p>示例：</p><figure><img src="../pictures/20250522/image%2018.png" alt="" /><figcaption>image.png</figcaption></figure><figure><img src="../pictures/20250522/image%2019.png" alt="" /><figcaption>image.png</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">namespace</span> jj07<br>&#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bad</span> &#123; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Foo::Foo()&quot;</span> &lt;&lt; endl;  &#125;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>) &#123; <br>                cout &lt;&lt; <span class="hljs-string">&quot;Foo::Foo(int)&quot;</span> &lt;&lt; endl;  <br>                <span class="hljs-comment">// throw Bad();  </span><br>             &#125;<br><br>    <span class="hljs-comment">//(1) 这个就是一般的 operator new() 的重载</span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size), size= &quot;</span> &lt;&lt; size &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);  <br>    &#125;<br><br>    <span class="hljs-comment">//(2) 这个就是标准库已经提供的 placement new() 的重载 (形式)</span><br>    <span class="hljs-comment">//    (所以我也模拟 standard placement new 的动作, just return ptr) </span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* start)</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size, void* start), size= &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot;  start= &quot;</span> &lt;&lt; start &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br><br>    <span class="hljs-comment">//(3) 这个才是崭新的 placement new </span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra)</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size, long extra)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size+extra);<br>    &#125;<br><br>    <span class="hljs-comment">//(4) 這又是一个 placement new </span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra, <span class="hljs-type">char</span> init)</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;operator new(size_t size, long extra, char init)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; init &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size+extra);<br>    &#125;<br>    <br>    <span class="hljs-comment">//(5) 這又是一個 placement new, 但故意寫錯第一參數的 type (它必須是 size_t 以滿足正常的 operator new) </span><br><span class="hljs-comment">//!  void* operator new(long extra, char init) &#123; //[Error] &#x27;operator new&#x27; takes type &#x27;size_t&#x27; (&#x27;unsigned int&#x27;) as first parameter [-fpermissive]</span><br><span class="hljs-comment">//!  cout &lt;&lt; &quot;op-new(long,char)&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//!    return malloc(extra);</span><br><span class="hljs-comment">//!  &#125; </span><br><br>    <span class="hljs-comment">//以下是搭配上述 placement new 的各個 called placement delete. </span><br>    <span class="hljs-comment">//當 ctor 發出異常，這兒對應的 operator (placement) delete 就會被喚起. </span><br>    <span class="hljs-comment">//應該是要負責釋放其搭檔兄弟 (placement new) 分配所得的 memory.  </span><br>    <span class="hljs-comment">//(1) 這個就是一般的 operator delete() 的重载 </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">size_t</span>)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,size_t)  &quot;</span> &lt;&lt; endl;  &#125;<br><br>    <span class="hljs-comment">//(2) 这是对上述的 (2)  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">void</span>*)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,void*)  &quot;</span> &lt;&lt; endl;  &#125;<br><br>    <span class="hljs-comment">//(3) 这是对上述的 (3)  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">long</span>)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,long)  &quot;</span> &lt;&lt; endl;  &#125;<br><br>    <span class="hljs-comment">//(4) 這是对上述的 (4)  </span><br>    <span class="hljs-comment">//如果沒有一一对应, 也不會有任何编译报错</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">long</span>,<span class="hljs-type">char</span>)</span></span><br><span class="hljs-function">    </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;operator delete(void*,long,char)  &quot;</span> &lt;&lt; endl; &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_i;<br>&#125;;<br><br><span class="hljs-comment">//-------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_overload_placement_new</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n\n\ntest_overload_placement_new().......... \n&quot;</span>;<br>    <br>    Foo start;  <span class="hljs-comment">//Foo::Foo</span><br><br>    Foo* p1 = <span class="hljs-keyword">new</span> Foo;           <span class="hljs-comment">//op-new(size_t)</span><br>    Foo* p2 = <span class="hljs-built_in">new</span> (&amp;start) Foo;  <span class="hljs-comment">//op-new(size_t,void*)</span><br>    Foo* p3 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>) Foo;     <span class="hljs-comment">//op-new(size_t,long)</span><br>    Foo* p4 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;a&#x27;</span>) Foo; <span class="hljs-comment">//op-new(size_t,long,char)</span><br><br>    Foo* p5 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>) <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);     <span class="hljs-comment">//op-new(size_t,long)  op-del(void*,long)</span><br>    Foo* p6 = <span class="hljs-built_in">new</span> (<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//</span><br>    Foo* p7 = <span class="hljs-built_in">new</span> (&amp;start) <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//</span><br>    Foo* p8 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//VC6 warning C4291: &#x27;void *__cdecl Foo::operator new(unsigned int)&#x27;</span><br>    <span class="hljs-comment">//no matching operator delete found; memory will not be freed if</span><br>    <span class="hljs-comment">//initialization throws an exception</span><br>&#125;<br>&#125; <span class="hljs-comment">//namespace</span><br><span class="hljs-comment">//----------------------------------------------------</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    jj07::<span class="hljs-built_in">test_overload_placement_new</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">test_overload_placement_new</span>()..........<br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>, size</span>= <span class="hljs-number">4</span><br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* start)</span>, size</span>= <span class="hljs-number">4</span>  start= <span class="hljs-number">0xffffcd958430</span><br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra)  <span class="hljs-number">4</span> <span class="hljs-number">100</span><br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra, <span class="hljs-type">char</span> init)  <span class="hljs-number">4</span> <span class="hljs-number">100</span> a<br>Foo::<span class="hljs-built_in">Foo</span>()<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra)  <span class="hljs-number">4</span> <span class="hljs-number">100</span><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">long</span> extra, <span class="hljs-type">char</span> init)  <span class="hljs-number">4</span> <span class="hljs-number">100</span> a<br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* start), size= <span class="hljs-number">4</span>  start= <span class="hljs-number">0xffffcd958430</span><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">size_t</span> size), size= <span class="hljs-number">4</span><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>在进行重载new()，delete()，第一个参数默认是的size_t，是不能改变的，改变就会错误。在进行函数定义时必须要这么定义，否则就会出错。</p><p>在进行函数调用时，第一个参数是默认传入对象的大小，这个是不用写，我们只需要填写从第二个开始的函数即可。</p><figure><img src="../pictures/20250522/image%2020.png" alt="" /><figcaption>image.png</figcaption></figure><p>C++中使用 <code>new(extra)</code> 来动态分配（即“扩充申请”）<code>basic_string</code>对象的内容</p><ol type="1"><li><strong><code>basic_string</code> 类的定义：</strong><ul><li>这是C++标准库中字符串类的基础模板，支持自定义字符类型（如 <code>char</code>、<code>wchar_t</code> 等）。</li><li>它内部有一个私有成员 <code>Rep</code>，代表字符串的存储结构（通常包括指针、长度、容量等信息）。</li></ul></li><li><strong><code>new(extra)</code> 的作用：</strong><ul><li>在传统的 <code>new</code> 操作中，动态分配一块内存用来存放对象。</li><li><code>new(extra)</code> 是一种“扩展”用法，允许在分配的同时为对象预留额外空间（这里指 <code>extra</code> 字节），以便存放额外数据或优化存储。</li></ul></li></ol><h1 id="per-class-allocator-版本一">Per-class allocator 版本一</h1><figure><img src="../pictures/20250522/image%2021.png" alt="" /><figcaption>image.png</figcaption></figure><p>类的内存分配器有两个作用，一是降低<code>malloc</code>的调用次数，二是减少每次调用<code>malloc</code>都会产生的<code>cookies</code>，因此我们希望对类设计一个分配器，我可以一次性申请24个类的大小，每次需要时都可以从已经分配好的内存池中获取。针对以上的设计目的，类可以设计成如上的版本。</p><p>对于每一个类都有一个<code>next</code>指针，指向下一个块，另外对于此类还需要一个<code>freeStore</code>来存储整个空闲块的位置。</p><p>对于类中<code>operator new的</code>设计，我们已经知道，<code>operator new</code>的第一个参数是类的大小，<code>freeStore</code>是申请的字节的大小，然后又将其转成了<code>Screen</code>类型，当把指针的类型转成<code>Screen</code>类型时，每次对指针的<code>++</code>编译器都会将其转换成对类型大小的操作。</p><p>在<code>operator delete</code>时，需要传入指针的位置以及大小，大小是我们已知的，因此是无用的，归还时直接将其插入到队列的最前端。</p><p>对应的测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Screen</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">i</span>(x) &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> i;&#125;<br>    <span class="hljs-comment">// 重载的operator new和delete的size_t的大小默认是类的大小</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-comment">// static void operator delete(void*, size_t);</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span></span>; <span class="hljs-comment">// 只能任选一个，但是两者不能共存</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 内存管理数据结构</span><br>    Screen* next;<br>    <span class="hljs-type">static</span> Screen* freeStore;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> screenChunk;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> i;<br>&#125;;<br><br><span class="hljs-comment">// 静态成员变量在类外初始化</span><br>Screen* Screen::freeStore = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Screen::screenChunk = <span class="hljs-number">24</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    Screen* p = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (!freeStore) &#123;<br>        <span class="hljs-comment">// 刚开始linklist是空，所以取一大块的memory</span><br>        <span class="hljs-comment">// 接下来是调用全局的 operator new</span><br>        <span class="hljs-type">size_t</span> chunk = screenChunk * size;<br>        freeStore = p =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;Screen*&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[chunk]);<br>        <span class="hljs-comment">// 现在内存已经分配还了，需要把其链接起来</span><br>        <span class="hljs-keyword">for</span> (; p != &amp;freeStore[screenChunk - <span class="hljs-number">1</span>]; ++p) &#123;<br>            p-&gt;next = p + <span class="hljs-number">1</span>;<br>        &#125;<br>        p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    p = freeStore;<br>    freeStore = freeStore-&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> Screen::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span>&#123;<br>    (<span class="hljs-built_in">static_cast</span>&lt;Screen*&gt;(p))-&gt;next = freeStore;<br>    freeStore = <span class="hljs-built_in">static_cast</span>&lt;Screen*&gt;(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;test per class allocator 1.....&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(Screen) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Screen) &lt;&lt; endl;<br><br>    <span class="hljs-type">size_t</span> <span class="hljs-type">const</span> N = <span class="hljs-number">100</span>;<br>    Screen* p[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        p[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Screen</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        cout &lt;&lt; p[i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">delete</span> p[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">test per <span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator</span> <span class="hljs-number">1.</span>....<br><span class="hljs-built_in">sizeof</span>(Screen) = <span class="hljs-number">16</span><br><span class="hljs-number">0xaaaac8b402c0</span><br><span class="hljs-number">0xaaaac8b402d0</span><br><span class="hljs-number">0xaaaac8b402e0</span><br><span class="hljs-number">0xaaaac8b402f0</span><br><span class="hljs-number">0xaaaac8b40300</span><br><span class="hljs-number">0xaaaac8b40310</span><br><span class="hljs-number">0xaaaac8b40320</span><br><span class="hljs-number">0xaaaac8b40330</span><br><span class="hljs-number">0xaaaac8b40340</span><br><span class="hljs-number">0xaaaac8b40350</span><br></code></pre></td></tr></table></figure><p>由测试结果可见，我们确实已经把内存接管过来了，因为分配的几个<code>Screen</code>是连续的，<code>Screen</code>之间是只相差了16个字节，与类的大小保持一致，上下并没有<code>cookies</code>，符合预期。</p><p>但是这样做好像是有些浪费资源，因为在类中额外定义了<code>Screen*</code>的<code>next</code>指针，浪费了4个字节。如果<code>new</code>的数目足够的大，那么此部分的消耗也是不可忽略的。因此引出了接下来的版本2，不再额外定义<code>Screen*</code>的<code>next</code>指针。</p><h1 id="per-class-allocator-版本二">Per-class allocator 版本二</h1><figure><img src="../pictures/20250522/image%2022.png" alt="" /><figcaption>image.png</figcaption></figure><ul><li>设计<code>per-class allocator 2</code>的目的，是为了避免在每个对象中都额外存储一个<code>next</code>指针，节省空间。</li><li>为此，采用<strong>联合体（<code>union</code>）</strong>，让内存块在空闲时可以用作链表的<code>next</code>指针。</li><li><strong>当这块内存未被使用（空闲）时</strong>，前四个字节（或最开始的部分）用来存放<code>next</code>指针。</li><li><strong>当这块内存被使用（分配给对象）时</strong>，它就占用整个块，用于存放对象数据。</li></ul><figure><img src="../pictures/20250522/image%2023.png" alt="" /><figcaption>image.png</figcaption></figure><p>根据图示的测试结果，如果使用的是全局的<code>operator new/delete</code>时，则类与类之间的内存间隔就会多些，因为上下cookies的占用。</p><p>接下来，用代码测试这部分是否符合预期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AirplaneRep</span> &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> miles;<br>        <span class="hljs-type">char</span> type;<br>    &#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">union</span> &#123;<br>        AirplaneRep rep; <span class="hljs-comment">// used object</span><br>        Airplane* next;  <span class="hljs-comment">// free list</span><br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">getMiles</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.miles;&#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rep.type;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> m, <span class="hljs-type">char</span> t)</span> </span>&#123;<br>        rep.miles = m;<br>        rep.type = t;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* deadobject, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> BLOCK_SIZZ;<br>    <span class="hljs-type">static</span> Airplane* headofFreeList;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Airplane::BLOCK_SIZZ = <span class="hljs-number">512</span>;<br>Airplane* Airplane::headofFreeList = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// static类型的变量在类外定义时不能指定static类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span>* Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果大小错误，交给 global operator new</span><br>    <span class="hljs-comment">// 在常规的情况下不会走到这里</span><br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Airplane)) &#123;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>    &#125;<br>    Airplane* p = headofFreeList;<br>    <span class="hljs-comment">// if p 有效，就把free list往下一个移</span><br>    <span class="hljs-keyword">if</span> (p) &#123;<br>        headofFreeList = p-&gt;next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// free list为空，要重新分配</span><br>        Airplane* newBlock = <span class="hljs-built_in">static_cast</span>&lt;Airplane*&gt;<br>            (::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(BLOCK_SIZZ * <span class="hljs-built_in">sizeof</span>(Airplane)));<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; BLOCK_SIZZ - <span class="hljs-number">1</span>; ++i) &#123;<br>            newBlock[i].next = &amp;newBlock[i + <span class="hljs-number">1</span>];  <br>        &#125;<br>        newBlock[BLOCK_SIZZ - <span class="hljs-number">1</span>].next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 将p设置为头部，将headofFreeList设置为下一个可用的块</span><br>        p = newBlock;<br>        headofFreeList = &amp;newBlock[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> Airplane::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* deadobject, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (deadobject == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in">sizeof</span>(Airplane)) &#123;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(deadobject)</span></span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Airplane *carcass = <span class="hljs-built_in">static_cast</span>&lt;Airplane*&gt;(deadobject);<br>    carcass-&gt;next = headofFreeList;<br>    headofFreeList = carcass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;test per class allocator 2.....&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(Airplane) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Airplane) &lt;&lt; endl;<br><br>    <span class="hljs-type">size_t</span> <span class="hljs-type">const</span> N = <span class="hljs-number">100</span>;<br>    Airplane* p[N];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        p[i] = <span class="hljs-keyword">new</span> Airplane;<br>    &#125;<br>    <span class="hljs-comment">// 随机测试objec 正常否</span><br>    p[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-number">10000</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>    p[<span class="hljs-number">4</span>]-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>    p[<span class="hljs-number">9</span>]-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-number">30000</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>    cout &lt;&lt; p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">getType</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">getMiles</span>() &lt;&lt; endl;<br>    cout &lt;&lt; p[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">4</span>]-&gt;<span class="hljs-built_in">getType</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">4</span>]-&gt;<span class="hljs-built_in">getMiles</span>() &lt;&lt; endl;<br>    cout &lt;&lt; p[<span class="hljs-number">9</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">9</span>]-&gt;<span class="hljs-built_in">getType</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[<span class="hljs-number">9</span>]-&gt;<span class="hljs-built_in">getMiles</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        cout &lt;&lt; p[i] &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-keyword">delete</span> p[i];<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>    Airplane* p1[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        p1[i] = <span class="hljs-built_in">static_cast</span>&lt;Airplane*&gt;(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(Airplane)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        cout &lt;&lt; p1[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">test per <span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator</span> <span class="hljs-number">2.</span>....<br><span class="hljs-built_in">sizeof</span>(Airplane) = <span class="hljs-number">16</span><br><span class="hljs-number">0xaaaac59802d0</span> A <span class="hljs-number">10000</span><br><span class="hljs-number">0xaaaac5980300</span> B <span class="hljs-number">20000</span><br><span class="hljs-number">0xaaaac5980350</span> C <span class="hljs-number">30000</span><br><span class="hljs-number">0xaaaac59802c0</span><br><span class="hljs-number">0xaaaac59802d0</span><br><span class="hljs-number">0xaaaac59802e0</span><br><span class="hljs-number">0xaaaac59802f0</span><br><span class="hljs-number">0xaaaac5980300</span><br><span class="hljs-number">0xaaaac5980310</span><br><span class="hljs-number">0xaaaac5980320</span><br><span class="hljs-number">0xaaaac5980330</span><br><span class="hljs-number">0xaaaac5980340</span><br><span class="hljs-number">0xaaaac5980350</span><br>---------------------<br><span class="hljs-number">0xaaaac59822d0</span><br><span class="hljs-number">0xaaaac59822f0</span><br><span class="hljs-number">0xaaaac5982310</span><br><span class="hljs-number">0xaaaac5982330</span><br><span class="hljs-number">0xaaaac5982350</span><br><span class="hljs-number">0xaaaac5982370</span><br><span class="hljs-number">0xaaaac5982390</span><br><span class="hljs-number">0xaaaac59823b0</span><br><span class="hljs-number">0xaaaac59823d0</span><br><span class="hljs-number">0xaaaac59823f0</span><br></code></pre></td></tr></table></figure><p>根据输出结果来看，用全局的<code>operator new</code>时，类与类之间的间隔是32个字节，如果用我们自定义的<code>new</code>方法，可以加减少<code>cookies</code>的占用，从32个字节变成了16个字节。</p><h1 id="common-static-allocator-版本三">Common static allocator 版本三</h1><p>对每一个类写一个上述的operator new和operator delete的静态成员函数显得有些重复，我们可以将其包装起来，以便下次使用时可以直接调用。每个分配器都是一个对象，我们可以直接调用。</p><figure><img src="../pictures/20250522/image%2024.png" alt="" /><figcaption>image.png</figcaption></figure><figure><img src="../pictures/20250522/image%2025.png" alt="" /><figcaption>image.png</figcaption></figure><figure><img src="../pictures/20250522/image%2026.png" alt="" /><figcaption>image.png</figcaption></figure><p>任然使用embeding Point的形式，类的大小是allocator传入的size_t，我们使用的size_t的前四个字节进行内存管理。具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">allocator_my</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">obj</span> &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">obj</span>* next;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dealloacte</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    obj* freestore&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> CHUNK = <span class="hljs-number">5</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocator_my::allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">obj</span>* p;<br>    <span class="hljs-keyword">if</span> (!freestore) &#123;<br>        <span class="hljs-type">size_t</span> chunk = CHUNK * size;<br>        freestore = p = (obj*)<span class="hljs-built_in">malloc</span>(chunk);<br><br>        <span class="hljs-comment">// 分割好后，需要将链表串起来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHUNK - <span class="hljs-number">1</span>; ++i) &#123;<br>            p-&gt;next = (obj*)(((<span class="hljs-type">char</span>*)p) + size);<br>            p = p -&gt;next;<br>        &#125;<br>        p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    p = freestore;<br>    freestore = freestore-&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocator_my::dealloacte</span><span class="hljs-params">(<span class="hljs-type">void</span>* p, <span class="hljs-type">size_t</span>)</span> </span>&#123;<br>    ((obj*)p)-&gt;next = freestore;<br>    freestore = (obj*)p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocator_my::check</span><span class="hljs-params">()</span> </span>&#123;<br>    obj* p = freestore;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        cout &lt;&lt; p &lt;&lt; endl;<br>        p = p-&gt;next;<br>        count++;<br>    &#125;<br>    cout &lt;&lt; count &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> L;<br>    string str;<br>    <span class="hljs-type">static</span> allocator_my myAlloc;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">long</span> l) : <span class="hljs-built_in">L</span>(l) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">allocate</span>(size);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">dealloacte</span>(pdead, size);<br>    &#125;<br>&#125;;<br><br>allocator_my Foo::myAlloc;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    complex&lt;<span class="hljs-type">double</span>&gt; c;<br>    string str;<br>    <span class="hljs-type">static</span> allocator_my myAlloc;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Goo</span>(<span class="hljs-type">const</span> complex&lt;<span class="hljs-type">double</span>&gt;&amp; x) : <span class="hljs-built_in">c</span>(x) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">allocate</span>(size);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pdead, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myAlloc.<span class="hljs-built_in">dealloacte</span>(pdead, size); <br>    &#125;<br>&#125;;<br><br>allocator_my Goo::myAlloc;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        Foo* p[<span class="hljs-number">100</span>];<br>        cout &lt;&lt; <span class="hljs-string">&quot;sizeof (Foo) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Foo) &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; ++i) &#123;<br>            p[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(i);<br>            cout &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;L &lt;&lt; endl;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; ++i) &#123;<br>            <span class="hljs-keyword">delete</span> p[i];<br>        &#125;<br>        Foo::myAlloc.<span class="hljs-built_in">check</span>();<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br>    &#123;<br>        Goo* p[<span class="hljs-number">100</span>];<br>        cout &lt;&lt; <span class="hljs-string">&quot;sizeof(Goo) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Goo) &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            p[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Goo</span>(<span class="hljs-built_in">complex</span>&lt;<span class="hljs-type">double</span>&gt;(i, i));<br>            cout &lt;&lt; p[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;c &lt;&lt; endl;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            <span class="hljs-keyword">delete</span> p[i];<br>        &#125;<br>        Goo::myAlloc.<span class="hljs-built_in">check</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp">➜  mem ./<span class="hljs-function">jj09                 </span><br><span class="hljs-function"><span class="hljs-title">sizeof</span> <span class="hljs-params">(Foo)</span> </span>= <span class="hljs-number">40</span><br><span class="hljs-number">0xaaaaec5062c0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0xaaaaec5062e8</span> <span class="hljs-number">1</span><br><span class="hljs-number">0xaaaaec506310</span> <span class="hljs-number">2</span><br><span class="hljs-number">0xaaaaec506338</span> <span class="hljs-number">3</span><br><span class="hljs-number">0xaaaaec506360</span> <span class="hljs-number">4</span><br><span class="hljs-number">0xaaaaec506390</span> <span class="hljs-number">5</span><br><span class="hljs-number">0xaaaaec5063b8</span> <span class="hljs-number">6</span><br><span class="hljs-number">0xaaaaec5063e0</span> <span class="hljs-number">7</span><br><span class="hljs-number">0xaaaaec506408</span> <span class="hljs-number">8</span><br><span class="hljs-number">0xaaaaec506430</span> <span class="hljs-number">9</span><br><span class="hljs-number">0xaaaaec506460</span> <span class="hljs-number">10</span><br><span class="hljs-number">0xaaaaec506488</span> <span class="hljs-number">11</span><br><span class="hljs-number">0xaaaaec5064b0</span> <span class="hljs-number">12</span><br><span class="hljs-number">0xaaaaec5064d8</span> <span class="hljs-number">13</span><br><span class="hljs-number">0xaaaaec506500</span> <span class="hljs-number">14</span><br><span class="hljs-number">0xaaaaec506530</span> <span class="hljs-number">15</span><br><span class="hljs-number">0xaaaaec506558</span> <span class="hljs-number">16</span><br><span class="hljs-number">0xaaaaec506580</span> <span class="hljs-number">17</span><br><span class="hljs-number">0xaaaaec5065a8</span> <span class="hljs-number">18</span><br><span class="hljs-number">0xaaaaec5065d0</span> <span class="hljs-number">19</span><br><span class="hljs-number">0xaaaaec506600</span> <span class="hljs-number">20</span><br><span class="hljs-number">0xaaaaec506628</span> <span class="hljs-number">21</span><br><span class="hljs-number">0xaaaaec506650</span> <span class="hljs-number">22</span><br><span class="hljs-number">0xaaaaec506678</span> <span class="hljs-number">23</span><br><span class="hljs-number">0xaaaaec5066a0</span> <span class="hljs-number">24</span><br><span class="hljs-number">0xaaaaec5066a0</span><br><span class="hljs-number">0xaaaaec506678</span><br><span class="hljs-number">0xaaaaec506650</span><br><span class="hljs-number">0xaaaaec506628</span><br><span class="hljs-number">0xaaaaec506600</span><br><span class="hljs-number">0xaaaaec5065d0</span><br><span class="hljs-number">0xaaaaec5065a8</span><br><span class="hljs-number">0xaaaaec506580</span><br><span class="hljs-number">0xaaaaec506558</span><br><span class="hljs-number">0xaaaaec506530</span><br><span class="hljs-number">0xaaaaec506500</span><br><span class="hljs-number">0xaaaaec5064d8</span><br><span class="hljs-number">0xaaaaec5064b0</span><br><span class="hljs-number">0xaaaaec506488</span><br><span class="hljs-number">0xaaaaec506460</span><br><span class="hljs-number">0xaaaaec506430</span><br><span class="hljs-number">0xaaaaec506408</span><br><span class="hljs-number">0xaaaaec5063e0</span><br><span class="hljs-number">0xaaaaec5063b8</span><br><span class="hljs-number">0xaaaaec506390</span><br><span class="hljs-number">0xaaaaec506360</span><br><span class="hljs-number">0xaaaaec506338</span><br><span class="hljs-number">0xaaaaec506310</span><br><span class="hljs-number">0xaaaaec5062e8</span><br><span class="hljs-number">0xaaaaec5062c0</span><br><span class="hljs-number">25</span><br>----------------<br><span class="hljs-built_in">sizeof</span>(Goo) = <span class="hljs-number">48</span><br><span class="hljs-number">0xaaaaec5066d0</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-number">0xaaaaec506700</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-number">0xaaaaec506730</span> (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">0xaaaaec506760</span> (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">0xaaaaec506790</span> (<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br><span class="hljs-number">0xaaaaec5067d0</span> (<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)<br><span class="hljs-number">0xaaaaec506800</span> (<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)<br><span class="hljs-number">0xaaaaec506830</span> (<span class="hljs-number">7</span>,<span class="hljs-number">7</span>)<br><span class="hljs-number">0xaaaaec506860</span> (<span class="hljs-number">8</span>,<span class="hljs-number">8</span>)<br><span class="hljs-number">0xaaaaec506890</span> (<span class="hljs-number">9</span>,<span class="hljs-number">9</span>)<br><span class="hljs-number">0xaaaaec506890</span><br><span class="hljs-number">0xaaaaec506860</span><br><span class="hljs-number">0xaaaaec506830</span><br><span class="hljs-number">0xaaaaec506800</span><br><span class="hljs-number">0xaaaaec5067d0</span><br><span class="hljs-number">0xaaaaec506790</span><br><span class="hljs-number">0xaaaaec506760</span><br><span class="hljs-number">0xaaaaec506730</span><br><span class="hljs-number">0xaaaaec506700</span><br><span class="hljs-number">0xaaaaec5066d0</span><br></code></pre></td></tr></table></figure><h1 id="macro-allocator-版本四">Macro allocator 版本四</h1><p>既然上述的写法比较通用，我们可以将其抽象为宏，这样才后续的代码撰写中就可以轻松的写出类的分配器。</p><figure><img src="../pictures/20250522/image%2027.png" alt="" /><figcaption>image.png</figcaption></figure><figure><img src="../pictures/20250522/image%2028.png" alt="" /><figcaption>image.png</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//借鏡 MFC macros. </span><br><span class="hljs-comment">// DECLARE_POOL_ALLOC -- used in class definition</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_POOL_ALLOC() \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">    void* operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; \</span><br><span class="hljs-meta">    void operator delete(void* p) &#123; myAlloc.deallocate(p, 0); &#125; \</span><br><span class="hljs-meta">protected: \</span><br><span class="hljs-meta">    static allocator myAlloc; </span><br><br><span class="hljs-comment">// IMPLEMENT_POOL_ALLOC -- used in class implementation file</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span><br><span class="hljs-meta">allocator class_name::myAlloc; </span><br><br><span class="hljs-comment">// in class definition file</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>   <span class="hljs-built_in">DECLARE_POOL_ALLOC</span>()<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">long</span> L;<br>    string str;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">long</span> l) : <span class="hljs-built_in">L</span>(l) &#123;  &#125;   <br>&#125;;<br><span class="hljs-comment">//in class implementation file</span><br><span class="hljs-built_in">IMPLEMENT_POOL_ALLOC</span>(Foo) <br><br><span class="hljs-comment">//  in class definition file</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goo</span> &#123;<br>   <span class="hljs-built_in">DECLARE_POOL_ALLOC</span>()<br><span class="hljs-keyword">public</span>: <br>    complex&lt;<span class="hljs-type">double</span>&gt; c;<br>    string str;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Goo</span>(<span class="hljs-type">const</span> complex&lt;<span class="hljs-type">double</span>&gt;&amp; x) : <span class="hljs-built_in">c</span>(x) &#123;  &#125;   <br>&#125;;<br><span class="hljs-comment">//in class implementation file</span><br><span class="hljs-built_in">IMPLEMENT_POOL_ALLOC</span>(Goo) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课程学习</category>
      
      <category>内存管理-侯捷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章：站在对象模型的尖端</title>
    <link href="/posts/2554354592/"/>
    <url>/posts/2554354592/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章：执行期语意学</title>
    <link href="/posts/3122301031/"/>
    <url>/posts/3122301031/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章：构造、析构、拷贝语意学</title>
    <link href="/posts/3301587688/"/>
    <url>/posts/3301587688/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章：Function语意学</title>
    <link href="/posts/2197280911/"/>
    <url>/posts/2197280911/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章：Data语意学</title>
    <link href="/posts/1668188749/"/>
    <url>/posts/1668188749/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章：构造函数语意学</title>
    <link href="/posts/4223977684/"/>
    <url>/posts/4223977684/</url>
    
    <content type="html"><![CDATA[<p>本章内容是挖掘编译器对<strong>对象构造</strong>程的干涉，及其对代码形式以及执行效率的影响… <span id="more"></span></p><h1 id="默认构造函数">1. 默认构造函数</h1><p>如果某个 C++ 类未定义任何构造器（有参/无参），C++ 编译器会自动为该类合成默认构造函数。譬如以下这个<code>ListNode</code>类，只有成员变量，没有<code>ListNode()</code>的任何形式的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ListNode node1; <span class="hljs-comment">//有没有这句话，汇编语言竟然是一样的，奇怪吧！！！</span><br>    ListNode node2 = <span class="hljs-built_in">ListNode</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说上述情况下编译器合成的默认构造函数是 trivial（没有用的）的。但从实际调试过程发现</p><ol type="1"><li><code>node1</code>的成员变量的值是随机的</li><li><code>node2</code>的成员变量<code>node2.val</code>值为 0，<code>node2.next</code>值为 <code>nullptr</code></li></ol><p>对于上面情况的解释如下：</p><ul><li><p>在GNU编译器的情况下，如果定义了但是没有使用且没有初始化，栈上就不会分配空间。如果只定义了<code>ListNode node1;</code> 可见栈上是没有分配内存的。</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    1131:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    1136:       5d                      pop    %rbp<br>    1137:       c3   <br></code></pre></td></tr></table></figure></p></li><li><p>如果有调用默认构造函数，那么在栈上就会分配空间，且将初值设置成0。</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    1131:       c7 45 f0 00 00 00 00    movl   <span class="hljs-variable">$0x0</span>,-0x10(%rbp)<br>    1138:       48 c7 45 f8 00 00 00    movq   <span class="hljs-variable">$0x0</span>,-0x8(%rbp)<br>    113f:       00 <br>    1140:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    1145:       5d                      pop    %rbp<br>    1146:       c3                      ret<br></code></pre></td></tr></table></figure></p></li></ul><p>原因是如果在栈上分配了对象的空间，那么就会把栈上空间清空，如果在堆上分配空间，那么就会是之前的内容。</p><p>让我们从汇编的角度来验证上面的结论,，使用<code>objdump -d bin</code>的形式查看源码，我们看下main函数对应的汇编代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    A obj;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    <span class="hljs-comment"># 重点语句</span><br>    1131:       c7 45 ec 01 00 00 00    movl   <span class="hljs-variable">$0x1</span>,-0x14(%rbp)<br>    1138:       c7 45 f0 02 00 00 00    movl   <span class="hljs-variable">$0x2</span>,-0x10(%rbp)<br>    <br>    113f:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    1144:       5d                      pop    %rbp<br>    1145:       c3                      ret<br></code></pre></td></tr></table></figure><p>震惊不，三句C++ 语言代码竟然只使用两条汇编代码就实现了。只对<code>i,j</code>在栈上分配空间，对<code>obj</code>并没有分配空间。</p><p>如果我们在定义的时候调用了默认构造函数，我们继续看其汇编代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-comment">// 如果显示定义了默认构造函数，那将完全不一样</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    A obj = <span class="hljs-built_in">A</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000001129 &lt;main&gt;:<br>    1129:       f3 0f 1e fa             endbr64<br>    112d:       55                      push   %rbp<br>    112e:       48 89 e5                mov    %rsp,%rbp<br>    1131:       c7 45 f8 01 00 00 00    movl   <span class="hljs-variable">$0x1</span>,-0x8(%rbp) <br>    1138:       c7 45 f4 00 00 00 00    movl   <span class="hljs-variable">$0x0</span>,-0xc(%rbp)<br>    113f:       c7 45 <span class="hljs-built_in">fc</span> 02 00 00 00    movl   <span class="hljs-variable">$0x2</span>,-0x4(%rbp)<br>    1146:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>    114b:       5d                      pop    %rbp<br>    114c:       c3                      ret<br></code></pre></td></tr></table></figure><ul><li>把当前栈帧-<code>0x8</code>写入<code>0x1</code>，代表的是<code>-0x8</code>到<code>-0xc</code>是i</li><li>把当前栈帧<code>-0xc</code>写入<code>0</code>，代表的是<code>-0xc</code>到<code>-0xd</code>是<code>obj</code></li><li>把当前栈帧<code>-0x4</code>写入<code>0x2</code>，代表的是<code>-0x4</code>到<code>-0x8</code>是<code>j</code></li></ul><p>书中总结的 C++ 编译器会生成 nontrivial 默认构造函数的四种场景：</p><ul><li><p>成员变量的类显式定义了默认构造函数；</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Member</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Member default constructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Member m; <span class="hljs-comment">// 当 Container 被构造时，Member 的默认构造函数被调用</span><br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br>Container c; <span class="hljs-comment">// 输出: Member default constructor</span><br></code></pre></td></tr></table></figure></p><p>其本质会生成一个默认构造函数，在默认构造函数中调用了成员变量的默认构造函数。编译器会以 <code>inline</code> 方式合成默认构造函数。若函数复杂，则生成显式 <code>non-inline static</code> 实体。</p></li><li><p>基类之一显式定义了默认构造函数；</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base default constructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 无显式构造函数</span><br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br>Derived d; <span class="hljs-comment">// 输出: Base default constructor</span><br></code></pre></td></tr></table></figure></p><p>派生类会先调用基类的默认构造函数（按声明顺序）。</p></li><li><p>定义了 virtual 函数；</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 测试</span><br>VBase v; <span class="hljs-comment">// 编译器生成虚函数表（vtbl）并初始化 vptr</span><br></code></pre></td></tr></table></figure></p></li><li><p>虚拟继承一个基类；</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> i; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> j; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">double</span> d; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B &#123; <span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> k; &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="hljs-number">1024</span>; &#125; <span class="hljs-comment">// 需运行时确定 X::i 的位置</span><br><br><span class="hljs-comment">// 测试</span><br>C c;<br><span class="hljs-built_in">foo</span>(&amp;c); <span class="hljs-comment">// 编译器确保 virtual base class 位置在执行期可确定</span><br></code></pre></td></tr></table></figure></p></li></ul><p>编译器生成的默认构造函数仅初始化基类和成员类对象，其他非静态成员（如整数、指针等）不会被初始化。这是程序员的责任。</p><ol type="1"><li><strong>误解</strong>：任何未定义默认构造函数的类都会被编译器生成一个。<ul><li><strong>事实</strong>：仅当编译器需要时才生成。</li></ul></li><li><strong>误解</strong>：编译器生成的默认构造函数会初始化所有数据成员。<ul><li><strong>事实</strong>：仅初始化基类和成员类对象。</li></ul></li></ol><h1 id="拷贝构造函数">2. 拷贝构造函数</h1><h2 id="拷贝构造函数的使用场景">2.1 拷贝构造函数的使用场景</h2><p>复制构造函数在什么情况下会被调用</p><ol type="1"><li>用一个对象初始化另一个新对象（注意与赋值运算符的区别）。构造函数都是在定义对象的时候用到了，定义是指申请内存空间</li><li>向函数传递对象参数时（值传递）</li><li>函数返回对象时（通常会被返回值优化RVO/NRV优化）</li></ol><p>何时需要自定义复制构造函数</p><ol type="1"><li>动态内存分配（指针成员）</li><li>文件句柄等系统资源</li><li>需要<strong>深拷贝</strong>的复杂数据结构</li></ol><p>编译器何时合成复制构造函数</p><ol type="1"><li>类没有显式定义复制构造函数</li><li>类不满足“位逐次拷贝”(bitwise copy)条件</li></ol><p>编译器如何扩充复制构造函数</p><ol type="1"><li>基类复制构造函数的调用</li><li>成员对象复制构造函数的调用</li><li>虚表指针(vptr)的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Default Constructor\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MyClass obj)</span> </span>&#123;&#125;  <span class="hljs-comment">// 值传递会调用复制构造</span><br><br><span class="hljs-function">MyClass <span class="hljs-title">createObj</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// 可能调用复制构造（取决于优化）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 情况1：显式初始化</span><br>    MyClass obj1;<br>    MyClass obj2 = obj1;  <span class="hljs-comment">// 调用复制构造</span><br>    <br>    <span class="hljs-comment">// 情况2：参数传递</span><br>    <span class="hljs-built_in">func</span>(obj1);  <span class="hljs-comment">// 调用复制构造</span><br>    <br>    <span class="hljs-comment">// 情况3：返回值</span><br>    MyClass obj3 = <span class="hljs-built_in">createObj</span>();  <span class="hljs-comment">// 可能调用复制构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位逐次拷贝bitwise-copy"><strong>2.2 位逐次拷贝(bitwise copy)</strong></h2><ol type="1"><li>适用bitwise copy的情况</li></ol><p>对于简单类<code>Point</code>，编译器直接使用内存复制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><br>Point p1;<br>Point p2 = p1;  <span class="hljs-comment">// 直接内存复制</span><br></code></pre></td></tr></table></figure><ol type="1"><li>****不适用bitwise copy的四种情况</li></ol><p>不适用bitwise copy的四种情况下，如果没有显示的定义copy构造函数，编译器就会合成copy构造函数，如果显示的定义copy构造函数，编译器还会进行构造函数的填充。</p><ul><li><p>成员有复制构造函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Member</span>(<span class="hljs-type">const</span> Member&amp;) &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br>    Member m;<br>    <span class="hljs-comment">// 编译器合成复制构造时会调用m的复制构造</span><br>&#125;;<br></code></pre></td></tr></table></figure></p></li><li><p>基类有复制构造函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">const</span> Base&amp;) &#123; <span class="hljs-comment">//... &#125;</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-comment">// 编译器合成复制构造时会调用Base的复制构造*</span><br>&#125;;<br></code></pre></td></tr></table></figure></p></li><li><p>类有虚函数</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WithVirtual</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">// 编译器合成复制构造时会初始化vptr</span><br>&#125;;<br></code></pre></td></tr></table></figure></p></li><li><p>继承虚基类</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualBase</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> VirtualBase &#123;<br>    <span class="hljs-comment">// 编译器合成复制构造时会处理虚基类</span><br>&#125;;<br></code></pre></td></tr></table></figure></p></li></ul><h2 id="编译器合成的copy构造函数"><strong>2.3 编译器合成的copy构造函数</strong></h2><p>编译器合成的复制构造函数分为两类：</p><ol type="1"><li><p><strong>trivial（平凡的）</strong> - 直接bitwise copy</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trivial</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;  <span class="hljs-comment">// 编译器使用内存复制*</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>nontrivial（非平凡的）</strong> - 需要额外处理</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonTrivial</span> &#123;<br>    std::string str;  <span class="hljs-comment">// string有复制构造函数// 编译器合成复制构造时会调用str的复制构造*</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>成员变量有默认的构造函数，所以<code>NonTrivial</code>类会调用string的copy构造函数，执行深copy</p></li></ol><h2 id="总结"><strong>2.4 总结</strong></h2><ol type="1"><li><strong>位逐次拷贝适用条件</strong>：类必须同时满足：<ul><li>成员无复制构造函数</li><li>基类无复制构造函数</li><li>无虚函数</li><li>不继承虚基类</li></ul><blockquote><p>此种情况下编译器会合成无用的copy构造函数，本质上是做内存的memset</p></blockquote></li><li><strong>必须自定义复制构造函数的场景</strong>：<ul><li>管理动态内存（深拷贝需求）</li><li>持有系统资源（文件/网络等）</li><li>需要特殊拷贝语义的复杂数据结构</li></ul></li><li><strong>编译器扩充规则</strong>：<ul><li>保证基类和成员的正确拷贝</li><li>维护虚函数机制</li><li>处理虚继承体系</li></ul></li><li><strong>现代C++最佳实践</strong>：<ul><li>明确使用<code>=default</code>或<code>=delete</code>表明意图</li><li>资源管理类应遵循Rule of Three/Five</li><li>优先使用移动语义(C++11)减少拷贝开销</li></ul></li></ol><h1 id="程序转化语义学">3. 程序转化语义学</h1><p>程序转化语义学是指编译器在处理<strong>对象初始化</strong>、<strong>参数传递</strong>和<strong>返回值</strong>时，会对代码进行一系列转换。这些转换保证了C++语义的正确实现，同时也为优化提供了空间。如定义所写，本文介绍3方面的程序转化。</p><h2 id="对象初始化">3.1 对象初始化</h2><p>对象初始化是指在定义一个对象后，编译器在背后做了哪些事情</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Default Constructor\\n&quot;</span>; &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor\\n&quot;</span>; &#125;<br>&#125;;<br><br>X x0;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">X <span class="hljs-title">x1</span><span class="hljs-params">(x0)</span></span>;  <span class="hljs-comment">// 直接初始化</span><br>    X x2 = x0; <span class="hljs-comment">// 拷贝初始化</span><br>    X x3 = <span class="hljs-built_in">X</span>(x0); <span class="hljs-comment">// 显式临时对象</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上文定义了三个对象，然后对其进行3种初始化方式，直接初始化，拷贝初始化，显示临时对象初始化，这3种初始化方式，最终都会调用copy构造函数，其经编译器转换后，相当于执行了下面的代码(伪码)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义被重写，初始化的操作会被剔除</span><br>    X x1;<br>    X x2;<br>    X x3;<br><br>    <span class="hljs-comment">// 编译器插入copy constructor的调用</span><br>    x<span class="hljs-number">1.</span>X::<span class="hljs-built_in">X</span>(x0);  <span class="hljs-comment">// 调用复制构造</span><br>    x<span class="hljs-number">2.</span>X::<span class="hljs-built_in">X</span>(x0);<br>    x<span class="hljs-number">3.</span>X::<span class="hljs-built_in">X</span>(x0);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl;; &#125;<br>&#125;;<br><br>X x0;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo_bar</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside foo_bar():&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-function">X <span class="hljs-title">x1</span><span class="hljs-params">(x0)</span></span>;<br>    X x2 = x0;<br>    X x3 = <span class="hljs-built_in">X</span>(x0);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Calling foo_bar():&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">foo_bar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Default</span> <span class="hljs-keyword">Constructor</span><br><span class="hljs-title function_">Calling</span> <span class="hljs-title function_">foo_bar</span><span class="hljs-params">()</span>:<br>Inside foo_bar():<br><span class="hljs-keyword">Copy</span> <span class="hljs-keyword">Constructor</span><br><span class="hljs-title function_">Copy</span> <span class="hljs-title function_">Constructor</span><br><span class="hljs-title function_">Copy</span> <span class="hljs-title function_">Constructor</span><br></code></pre></td></tr></table></figure><h2 id="传参初始化转换">3.2 传参初始化转换</h2><p>传参初始化是指在向函数进行<strong>值传递</strong>的过程中，编译器在背后做了哪些事情。有两种策略</p><p>策略1：创建临时对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X x0)</span></span>;  <span class="hljs-comment">// 值传递</span><br><br>X xx;<br><span class="hljs-built_in">foo</span>(xx);<br><br><span class="hljs-comment">// 转换后</span><br>X __temp0;<br>__temp<span class="hljs-number">0.</span>X::<span class="hljs-built_in">X</span>(xx);  <span class="hljs-comment">// 调用复制构造</span><br><span class="hljs-built_in">foo</span>(__temp0);<br><br></code></pre></td></tr></table></figure><p>策略2：直接拷贝到栈上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 编译器可能直接在调用栈上构造对象</span><br><span class="hljs-built_in">foo</span>(xx);<br><span class="hljs-comment">// 转换为在栈上直接调用复制构造</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X x0)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside foo() &quot;</span> &lt;&lt; std::endl;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;testing parameter passing:&quot;</span> &lt;&lt; std::endl;<br>    X xx;<br>    <span class="hljs-built_in">foo</span>(xx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">testing parameter passing:<br><span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Inside</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>根据输出结构，先调用copy构造函数，再走到inside foo()，说明在进行值传递的时候，会调用copy构造函数。</p><h2 id="返回值初始化转换">3.3 返回值初始化转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br><span class="hljs-comment">// 转换为</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(X&amp; __result)</span> </span>&#123;<br>    X xx;<br>    xx.X::<span class="hljs-built_in">X</span>();      <span class="hljs-comment">// 默认构造</span><br>    __result.X::<span class="hljs-built_in">X</span>(xx);  <span class="hljs-comment">// 复制构造</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接返回某个类的对象，编译器相当于隐私的定义了一个引用形参，然后传递到函数体内，在函数体内进行构造对象。</p><h2 id="使用者层面的优化">3.4 使用者层面的优化</h2><p>程序员在编写程序时，应尽量避免先定义临时对象，然后再返回，应该直接进行返回构造。（实际在编程中，很少遇到这种，我们的函数经常返回的是错误码，需要的对象应该是传参或者是线程中的变量）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 原写法：</span><br><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;y, <span class="hljs-type">const</span> T &amp;z)</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-comment">// 用y,z计算xx</span><br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br><span class="hljs-comment">// 优化后：</span><br><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;y, <span class="hljs-type">const</span> T &amp;z)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>(y, z);  <span class="hljs-comment">// 直接构造返回</span><br>&#125;<br><br><span class="hljs-comment">// 编译器转换：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(X &amp;__result, <span class="hljs-type">const</span> T &amp;y, <span class="hljs-type">const</span> T &amp;z)</span> </span>&#123;<br>    __result.X::<span class="hljs-built_in">X</span>(y, z);  <span class="hljs-comment">// 直接构造到结果</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="nrvnamed-return-value优化少使用">3.5 NRV（Named Return Value）优化（少使用）</h2><p>优化原理，借用编译器特性，让编译器进行优化，但是这种方案通常不好。在现代C++中，有更好的替代方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 原函数</span><br><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br><span class="hljs-comment">// NRV优化后</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(X &amp;__result)</span> </span>&#123;<br>    __result.X::<span class="hljs-built_in">X</span>();  <span class="hljs-comment">// 直接在结果上构造</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>NRV优化的争议点</p><ol type="1"><li><p><strong>不可预测性</strong>：优化由编译器决定，开发者无法确保是否发生</p><ul><li>解决方案：使用移动语义(C++11)明确优化意图</li></ul></li><li><p><strong>对称性破坏</strong>：跳过copy constructor可能影响程序逻辑</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Resource</span>() &#123; count++; &#125;<br>    <span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> Resource&amp;) &#123; count++; &#125;<br>    ~<span class="hljs-built_in">Resource</span>() &#123; count--; &#125;<br>    <span class="hljs-comment">// NRV优化会破坏计数的一致性</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></p></li><li><p><strong>复杂函数优化困难</strong>：当函数有多条返回路径时，NRV难以应用</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        X yy;<br>        <span class="hljs-keyword">return</span> yy;  <span class="hljs-comment">// 多返回路径使优化困难</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="总结优先">3.6 总结（优先）</h2><ol type="1"><li><p><strong>优先使用移动语义</strong>（明确优化意图）</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    X xx;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(xx);  <span class="hljs-comment">// 明确请求移动而非拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>返回值优化(RVO)更可靠</strong>：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">X <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>();  <span class="hljs-comment">// 保证RVO</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>避免依赖NRV</strong>：编写不依赖特定优化的代码</p></li><li><p><strong>复杂对象使用智能指针</strong>：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;X&gt; <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> xx = std::<span class="hljs-built_in">make_unique</span>&lt;X&gt;();<br>    <span class="hljs-keyword">return</span> xx;  <span class="hljs-comment">// 无拷贝开销</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><h1 id="成员初始化列表">4. 成员初始化列表</h1><p>成员初始化列表（Member Initialization List）是构造函数中初始化类成员的特殊语法。在某些情况下，使用初始化列表是<strong>必须的</strong>，而不仅仅是风格选择。</p><p>基本语法形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    Type member;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">member</span>(initialValue) &#123;&#125;  <span class="hljs-comment">// 初始化列表</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="必须使用初始化列表的四种情况">4.1 必须使用初始化列表的四种情况</h2><ol type="1"><li>初始化引用成员（reference member）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefHolder</span> &#123;<br>    <span class="hljs-type">int</span>&amp; ref;  <span class="hljs-comment">// 引用成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RefHolder</span>(<span class="hljs-type">int</span>&amp; value) : <span class="hljs-built_in">ref</span>(value) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表</span><br>    <span class="hljs-comment">// 错误写法：RefHolder(int&amp; value) &#123; ref = value; &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：引用必须在创建时初始化，不能在构造函数体内赋值。</p><ol type="1"><li>初始化常量成员（const member）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstHolder</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> value;  <span class="hljs-comment">// 常量成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConstHolder</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表</span><br>    <span class="hljs-comment">// 错误写法：ConstHolder(int v) &#123; value = v; &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：const成员必须在创建时初始化，之后不能修改。</p><ol type="1"><li>调用基类有参数的构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> value) &#123;&#125;  <span class="hljs-comment">// 有参构造</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">Base</span>(v) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表调用基类构造</span><br>    <span class="hljs-comment">// 错误写法：Derived(int v) &#123; Base(v); &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：基类必须在派生类构造前初始化。</p><ol start="4" type="1"><li>调用成员类有参数的构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Member</span>(<span class="hljs-type">int</span> value) &#123;&#125;  <span class="hljs-comment">// 有参构造</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> &#123;<br>    Member mem;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Container</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">mem</span>(v) &#123;&#125;  <span class="hljs-comment">// 必须用初始化列表</span><br>    <span class="hljs-comment">// 错误写法：Container(int v) &#123; mem = Member(v); &#125;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>原因</strong>：成员对象必须在容器类构造时初始化。</p><h2 id="初始化列表的其他重要特性">4.2 初始化列表的其他重要特性</h2><ol type="1"><li>初始化顺序与声明顺序一致</li></ol><p>编译器会按照成员<strong>声明顺序</strong>初始化，而非初始化列表中的顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderMatters</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">OrderMatters</span>() : <span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>) &#123;&#125;  <span class="hljs-comment">// 实际初始化顺序：a(2)先于b(1)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol type="1"><li>初始化代码插入时机</li></ol><p>编译器将初始化列表的代码插入到构造函数体<strong>之前</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 概念性转换</span><br><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">member</span>(v) &#123; <span class="hljs-comment">/* user code */</span> &#125;<br><span class="hljs-comment">// 转换为：</span><br><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) &#123;<br>    <span class="hljs-built_in">member</span>(v);  <span class="hljs-comment">// 初始化列表代码</span><br>    <span class="hljs-comment">/* user code */</span>  <span class="hljs-comment">// 构造函数体</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结-1">4.3 总结</h2><ol type="1"><li><p><strong>必须使用的情况</strong>：遇到上述四种情况时，必须使用初始化列表</p></li><li><p><strong>效率考虑</strong>：对于非POD类型，使用初始化列表比构造函数体内赋值更高效</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 更高效</span><br><span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;hello&quot;</span>) &#123;&#125;<br><br><span class="hljs-comment">// 低效（先默认构造，再赋值）</span><br><span class="hljs-built_in">MyClass</span>() &#123; str = <span class="hljs-string">&quot;hello&quot;</span>; &#125;<br><br></code></pre></td></tr></table></figure></p></li><li><p><strong>顺序一致性</strong>：按照成员声明顺序编写初始化列表，避免混淆</p></li><li><p><strong>简单初始化</strong>：对于简单POD类型(int, float等)，初始化列表不是必须的，但推荐使用保持一致性</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章：关于对象</title>
    <link href="/posts/726162626/"/>
    <url>/posts/726162626/</url>
    
    <content type="html"><![CDATA[<p>本章主要以对象为基础观念背景，对C++对象模型进行一个概述~ <span id="more"></span></p><p>前情提要，本文示例的编译环境<code>Linux ubuntu-linux-22-04-02-desktop 5.15.0-133-generic #144-Ubuntu SMP Sat Feb 8 14:13:21 UTC 2025 aarch64 aarch64 aarch64 GNU/Linux</code> g++版本<code>g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</code></p><h1 id="基础">1. 基础</h1><p>首先是不考虑C++的基本的特性，单纯用C++写C，观察下C++在运行时的一些特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//section1</span><br>    <span class="hljs-type">uint64_t</span> longNo2; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//section2</span><br>    <span class="hljs-type">uint64_t</span> longNo1; <span class="hljs-comment">// 8</span><br>    <span class="hljs-type">uint8_t</span> no1; <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">uint8_t</span> no2; <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">uint8_t</span> no3; <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">//section3</span><br>    <span class="hljs-type">uint8_t</span> no4; <span class="hljs-comment">// 1</span><br>&#125;;<br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    cout &lt;&lt; sizeObj &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果<code>sizeObj</code>为 24，调整下不同变量的位置，发现输出结果不同：</p><ul><li>把<code>section2</code>移到<code>section1</code>上方（调整 access sections 的顺序），输出<code>sizeObj</code>为 32；</li><li>把<code>no2</code>移到<code>longNo1</code>上方（调整成员变量的顺序），输出<code>sizeObj</code>为 32；</li></ul><p>为什么会出现这种现象呢？因为有字节对齐！！！</p><p>我们在对上面的程序进行调试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(<span class="hljs-type">int</span>)(&amp;(obj.no2) - (<span class="hljs-type">uint8_t</span>*)(&amp;obj.longNo1))<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><ol type="1"><li>首先明确<code>no2</code>和<code>longNo1</code>之间差了9个字节，且<code>longNo1</code>在低地址，<code>no2</code>在高地址</li><li>其次分析上面的debug语句。<code>(int)(&amp;(obj.no2) - (&amp;obj.longNo1))</code>这样写是不行的，因为类型不同的两个变量之间的地址是没办法相减的，报错如下<code>First argument of</code>-’ is a pointer and second argument is neither an integer nor a pointer of the same type.`</li></ol><aside><p>💡 发现 C++ 对象的成员变量布局和 C 语言的 struct 布局非常相似，同样需要考虑内存字节对齐问题，同样是按照成员声明的顺序进行布局。</p></aside><p>接下来对比上述变量就行复制，然后查看内存布局。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>;<br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint8_t</span> no1 = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">uint8_t</span> no3 = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no4 = <span class="hljs-number">14</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    cout &lt;&lt; sizeObj &lt;&lt; endl;<br>    <br>    Object *objPtr = <span class="hljs-keyword">new</span> Object;<br>    <span class="hljs-type">size_t</span> sizeObjPtr = <span class="hljs-built_in">sizeof</span>(objPtr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用GDB的<code>X</code>命令查看对于的内存布局，使用<code>x/32bx &amp;obj</code>打印<code>obj</code>对象的内存，其中<code>b</code>表示以字节划分，32 表示打印 32 个字节的内存空间，<code>x</code>代表的是以16进制打印。打印结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/32bx &amp;obj<br>0xffffffffeed0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br></code></pre></td></tr></table></figure><p>首先内存空间是<code>0xff</code>打头，基本可以断定是栈空间（从高位向地位分配）。其次内存空间中有很多值为<code>0x00</code>的 Padding 字节空间，为了满足内存对齐的需要。注意到前 8 个字节中，低位保存低位，所以当前调试平台是使用小端模式（little-endian）。</p><p>继续查看<code>&amp;sizeObj</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>(gdb) x/32bx &amp;obj<br>0xffffffffeed0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/8bx &amp;sizeObj<br>0xffffffffeec8: 0x20    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br></code></pre></td></tr></table></figure><p>由于栈是从高地址向低地址分配，而<code>&amp;sizeoObj</code> <code>0xffffffffeec8</code> 与<code>&amp;obj</code> <code>0xffffffffeed0</code>刚好差8个字节，是一个<code>size_t</code>的大小。</p><p>从上面的调试过程可见，上面构建的<code>Object</code>对象的内存空间在<strong>栈空间</strong>中。稍微修改一下调试代码，以<code>new</code>方式构建<code>Object</code>对象。编译运行，<code>po objPtr</code>打印<code>objPtr</code>指针（表示<code>objPtr</code>所指向的内存地址），输出结果为 <code>0xaaaaaaac3eb0</code>，此时构建的<code>Object</code>对象存在于内存堆空间中。使用<code>x/32b objPtr</code>查看内存，从数据不难发现它就是个<code>Object</code>对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/32xb objPtr<br>0xaaaaaaac3eb0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xaaaaaaac3eb8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xaaaaaaac3ec0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xaaaaaaac3ec8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/32xbu objPtr<br>0xaaaaaaac3eb0: 1       0       0       0       0       0       0       0<br>0xaaaaaaac3eb8: 12      0       0       0       0       0       0       0<br>0xaaaaaaac3ec0: 2       0       0       0       0       0       0       0<br>0xaaaaaaac3ec8: 11      13      14      0       0       0       0       0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p objPtr <br><span class="hljs-variable">$6</span> = (Object *) 0xaaaaaaac3eb0<br></code></pre></td></tr></table></figure><h1 id="继承">2. 继承</h1><p>上面的类的实现与C语言的struct本质上并没有什么区别，C++相比比C语言而言，最突出的优势是封装，继承，多态。那么在上面的基础情况下，我们再考虑下继承的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>;<br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint8_t</span> no1 = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">uint8_t</span> no3 = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no4 = <span class="hljs-number">14</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject</span> : Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> subLongNo1 = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">uint8_t</span> subNo1 = <span class="hljs-number">16</span>;<br>    <span class="hljs-type">uint8_t</span> subNo2 = <span class="hljs-number">15</span>;<br>    <br>&#125;;<br><br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj;<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    <br>    SubClassObject subobj;<br>    <span class="hljs-type">size_t</span> sizeSubobj = <span class="hljs-built_in">sizeof</span>(SubClassObject);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印<code>sizeSubobj</code>为 48，<code>x/48b &amp;subobj</code>打印内存空间，不难发现，子类成员变量的数据是直接拼接在基类的成员变量内存空间后面。可以看到低32字节是子类的成员变量，高16字节是派生类的成员变量，派生类是直接append到子类的后面的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p sizeSubobj <br><span class="hljs-variable">$1</span> = 48<br>(gdb) x/48bx &amp;subobj<br>0xffffffffeeb8: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec0: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec8: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed0: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x10    0x0f    0x00    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/48bu &amp;subobj<br>0xffffffffeeb8: 1       0       0       0       0       0       0       0<br>0xffffffffeec0: 12      0       0       0       0       0       0       0<br>0xffffffffeec8: 2       0       0       0       0       0       0       0<br>0xffffffffeed0: 11      13      14      0       0       0       0       0<br>0xffffffffeed8: 3       0       0       0       0       0       0       0<br>0xffffffffeee0: 16      15      0       0       0       0       0       0<br></code></pre></td></tr></table></figure><p>在子类定义代码中，交换<code>subNo1</code>和<code>subLongNo1</code>的顺序会导致<code>sizeSubobj</code>变化么？答案是会变化，交换后<code>sizeSubobj</code> 56。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/56xb &amp;subobj<br>0xffffffffeeb0: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeeb8: 0x0c    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec0: 0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeec8: 0x0b    0x0d    0x0e    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed0: 0x10    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeed8: 0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>0xffffffffeee0: 0x0f    0x00    0x00    0x00    0x00    0x00    0x00    0x00<br>(gdb) x/56xu &amp;subobj<br>0xffffffffeeb0: 1       0       0       0       0       0       0       0<br>0xffffffffeeb8: 12      0       0       0       0       0       0       0<br>0xffffffffeec0: 2       0       0       0       0       0       0       0<br>0xffffffffeec8: 11      13      14      0       0       0       0       0<br>0xffffffffeed0: 16      0       0       0       0       0       0       0<br>0xffffffffeed8: 3       0       0       0       0       0       0       0<br>0xffffffffeee0: 15      0       0       0       0       0       0       0<br>(gdb) p sizeSubobj <br><span class="hljs-variable">$2</span> = 56<br></code></pre></td></tr></table></figure><p>同时请注意，在子类是不用用基类的padding空间的。证据如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">2</span>; <span class="hljs-comment">// 8</span><br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-comment">// uint8_t no1 = 11; // 1</span><br>    <span class="hljs-comment">// uint8_t no3 = 13; // 1</span><br><span class="hljs-keyword">public</span>:<br>&#125;;<br><br><span class="hljs-comment">/// 子类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject</span> : Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> subNo1 = <span class="hljs-number">16</span>;<br>    <span class="hljs-type">uint8_t</span> subNo2 = <span class="hljs-number">15</span>;<br>    <span class="hljs-type">uint8_t</span> subNo3 = <span class="hljs-number">17</span>;<br>    <span class="hljs-type">uint8_t</span> subNo4 = <span class="hljs-number">18</span>;<br>    <br>&#125;;<br><br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj;<br>    <span class="hljs-type">size_t</span> sizeObj = <span class="hljs-built_in">sizeof</span>(Object);<br>    <br>    SubClassObject subobj;<br>    <span class="hljs-type">size_t</span> sizeSubobj = <span class="hljs-built_in">sizeof</span>(SubClassObject);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p sizeSubobj <br><span class="hljs-variable">$1</span> = 32<br>(gdb) x/32bu &amp;subobj<br>0xffffffffeec8: 1       0       0       0       0       0       0       0<br>0xffffffffeed0: 2       0       0       0       0       0       0       0<br>0xffffffffeed8: 12      0       0       0       0       0       0       0<br>0xffffffffeee0: 16      15      17      18      0       0       0       0<br></code></pre></td></tr></table></figure><h1 id="虚拟">3. 虚拟</h1><p>类的继承链中是否存在虚拟函数会直接影响<strong>类的实例</strong>的大小。总体是这样的规律：若某个类型声明了 <code>virtual</code> 函数，则直接或间接继承了该类型的<strong>所有</strong>衍生类，都需要维护一张 <code>virtual table</code>，用于保存 <code>virtual</code> 函数指针，而此时声明了 <code>virtual</code> 函数的类的实例以及该类的所有衍生类的实例，都需要保证 8 个字节（64 位机）的内存空间用于保存 <code>virtual table</code> 的内存地址，这就是 <code>vptr</code> 指针。代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint64_t</span> longNo2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no2 = <span class="hljs-number">12</span>;<br>    <span class="hljs-type">uint64_t</span> longNo1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint8_t</span> no1 = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">uint8_t</span> no3 = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">uint8_t</span> no4 = <span class="hljs-number">14</span>;<br>&#125;; <span class="hljs-comment">// 32</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MidObject</span> : Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        <span class="hljs-comment">// Abstract Method</span><br>    &#125;<br>&#125;; <span class="hljs-comment">// 40</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject1</span> : MidObject &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vfun</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;implement one&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClassObject2</span> : MidObject &#123;<br><br>&#125;;<br><br><span class="hljs-comment">/// 调试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(obj) &lt;&lt; endl; <span class="hljs-comment">// 32</span><br>    MidObject midObj = <span class="hljs-built_in">MidObject</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(midObj) &lt;&lt; endl; <span class="hljs-comment">// 40</span><br>    SubClassObject1 subObj1 = <span class="hljs-built_in">SubClassObject1</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(subObj1) &lt;&lt; endl; <span class="hljs-comment">// 40</span><br>    SubClassObject2 subObj2 = <span class="hljs-built_in">SubClassObject2</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(subObj2) &lt;&lt; endl; <span class="hljs-comment">// 40</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>sizeof(Object)</code>为 32，因为继承链上没有 virtual 函数，所以无需保存 vptr 指针；</li><li><code>sizeof(MidObject)</code>为 40，因为自身声明了 virtual 函数，所以需要保存 vptr 指针；</li><li><code>sizeof(SubClassObject1)</code>和<code>sizeof(SubClassObject2)</code>均为 40，因为父类<code>MidObject</code>声明了 virtual 函数，所以需要保存 vptr 指针（不管有没实现 virtual 函数）；</li></ul><p>那么，virtual table 大概保存了什么东西呢？</p><p>同样可以用GDB 的<code>x</code>命令来简单探索一下。分别打印<code>midObj</code>、<code>subObj1</code>、<code>subObj2</code>的内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) x/<span class="hljs-number">32</span>bu &amp;obj<br><span class="hljs-number">0xffffffffee38</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee40</span>: <span class="hljs-number">12</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee48</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee50</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>(gdb) x/<span class="hljs-number">40</span>bu &amp;midObj<br><span class="hljs-number">0xffffffffee58</span>: <span class="hljs-number">200</span>     <span class="hljs-number">28</span>      <span class="hljs-number">171</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee60</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee68</span>: <span class="hljs-number">12</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee70</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee78</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">240</span>     <span class="hljs-number">15</span>      <span class="hljs-number">240</span>     <span class="hljs-number">15</span>      <span class="hljs-number">240</span><br>(gdb) x/<span class="hljs-number">40</span>bu &amp;subObj1<br><span class="hljs-number">0xffffffffee80</span>: <span class="hljs-number">176</span>     <span class="hljs-number">28</span>      <span class="hljs-number">171</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee88</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee90</span>: <span class="hljs-number">12</span>      <span class="hljs-number">240</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffee98</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeea0</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>(gdb) x/<span class="hljs-number">40</span>bu &amp;subObj2<br><span class="hljs-number">0xffffffffeea8</span>: <span class="hljs-number">152</span>     <span class="hljs-number">28</span>      <span class="hljs-number">171</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">170</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeeb0</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeeb8</span>: <span class="hljs-number">12</span>      <span class="hljs-number">115</span>     <span class="hljs-number">191</span>     <span class="hljs-number">247</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeec0</span>: <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br><span class="hljs-number">0xffffffffeec8</span>: <span class="hljs-number">11</span>      <span class="hljs-number">13</span>      <span class="hljs-number">14</span>      <span class="hljs-number">247</span>     <span class="hljs-number">255</span>     <span class="hljs-number">255</span>     <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>差异在前 8 个字节，也就是说 GNU编译器将 vptr 保存在实例的首 8 个字节。在派生类不太一样，但是这无所谓，因为主题的数据部分是保持一致的。</p><p><code>midObj</code>、<code>subObj1</code>、<code>subObj2</code>的 vptr 也就是 virtual table 的内存地址分别是<code>0xffffffffee58</code>、<code>0xffffffffee80</code>、<code>0xffffffffeea8</code>。用<code>x/g</code>命令分别打印出出上述三个地址为起始的 8 个字节的内存中所保存的内容，比较明显的是三个内存地址从大小上看应该是 text segment 或 data segment 范畴内的内存地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/gx 0xffffffffee58<br>0xffffffffee58: 0x0000aaaaaaab1cc8<br>(gdb) x/gx 0xffffffffee80<br>0xffffffffee80: 0x0000aaaaaaab1cb0<br>(gdb) x/gx 0xffffffffeea8<br>0xffffffffeea8: 0x0000aaaaaaab1c98<br></code></pre></td></tr></table></figure><p>进一步实例的首地址进行分析，发现其确实是执行不同类的虚函数表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p (void(*)(void)) 0x0000aaaaaaab1cc8<br><span class="hljs-variable">$1</span> = (void (*)(void)) 0xaaaaaaab1cc8 &lt;vtable <span class="hljs-keyword">for</span> MidObject+16&gt;<br>(gdb) p (void(*)(void)) 0x0000aaaaaaab1cb0<br><span class="hljs-variable">$2</span> = (void (*)(void)) 0xaaaaaaab1cb0 &lt;vtable <span class="hljs-keyword">for</span> SubClassObject1+16&gt;<br>(gdb) p (void(*)(void)) 0x0000aaaaaaab1c98<br><span class="hljs-variable">$3</span> = (void (*)(void)) 0xaaaaaaab1c98 &lt;vtable <span class="hljs-keyword">for</span> SubClassObject2+16&gt;<br></code></pre></td></tr></table></figure><p>有实现虚函数<code>vfunc</code>的类对象的 virtual table，保存了指向自身实现的<code>vfun</code>的函数指针。而未实现<code>vfun</code>的类对象的 virtual table，则保存了继承链中某个类所实现的<code>vfun</code>的函数指针（这里是指向<code>MidObject</code>实现的<code>vfun</code>）。</p><p>既然虚拟函数有引入 virtual table 的特殊性，那么虚拟继承呢，其会更加复杂，我们再后续的学习中会逐步探索。</p><h1 id="小结">小结</h1><p>本章简单调试了 C++ 模型的一些特性，发现其内存布局和 Objective-C 的 Runtime 实现还是有一定的相似之处，例如要求<strong>字节对齐</strong>和<strong>继承触发</strong>的对象尺寸扩展的行为特点。</p><p>C++ 实现面向对象，实际是以 C++ 编译器强干预为前提的。这也是为什么编写 C++ 代码过程中，会更容易遇到类型检查相关的编译 Error 提示，尤其是不按规则的强转，因为 C++ 在编译阶段就需要<strong>确立</strong>很多具体的类型信息，例如成员变量在对象内存空间中的偏移，类的成员函数的具体地址，这些类型信息基本不会推迟到运行时决议（也不需要），所以 C++ 原生是没有反射机制的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Object obj = <span class="hljs-built_in">Object</span>();<br>    MidObject midObj = <span class="hljs-built_in">MidObject</span>();<br>    SubClassObject1 subObj1 = <span class="hljs-built_in">SubClassObject1</span>();<br>    SubClassObject2 subObj2 = <span class="hljs-built_in">SubClassObject2</span>();<br>    <br>    <span class="hljs-comment">// 调试代码一：非 virtual 机制</span><br>    MidObject *midObjPtr = (MidObject *)&amp;midObj;<br>    Object *baseObjPtr = (Object *)&amp;midObj;<br>    <br>    <span class="hljs-comment">// 调试代码二：virtual 机制</span><br>    SubClassObject1 *subObjPtr1 = &amp;subObj1;<br>    MidObject *midObjPtr12= (MidObject *)subObjPtr1;<br>    midObjPtr-&gt;<span class="hljs-built_in">vfun</span>(); <span class="hljs-comment">//打印结果：implement it</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面调试代码一所示，用 GDB <code>p sizeof(*baseObjPtr)</code>和<code>p sizeof(*midObjPtr)</code>得到的结果分别是 32 和 40，即使<code>baseObjPtr</code>和<code>midObjPtr</code>指向相同的内存地址，但编译阶段实际上已经将其标记为两种类型，所以运行时<code>baseObjPtr</code>和<code>midObjPtr</code>所指向的对象类型就是编译时所声明的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(gdb) <span class="hljs-function">p <span class="hljs-title">sizeof</span><span class="hljs-params">(*baseObjPtr)</span></span><br><span class="hljs-function">$3 </span>= <span class="hljs-number">32</span><br>(gdb) <span class="hljs-function">p <span class="hljs-title">sizeof</span><span class="hljs-params">(*midObjPtr)</span></span><br><span class="hljs-function">$4 </span>= <span class="hljs-number">40</span><br>(gdb) p &amp;midObj<br>$<span class="hljs-number">5</span> = (MidObject *) <span class="hljs-number">0xffffffffe9a0</span><br>(gdb) <span class="hljs-built_in">p</span> (MidObject *) &amp;midObj<br>$<span class="hljs-number">6</span> = (MidObject *) <span class="hljs-number">0xffffffffe9a0</span><br>(gdb) <span class="hljs-built_in">p</span> (Object *) &amp;midObj<br>$<span class="hljs-number">7</span> = (Object *) <span class="hljs-number">0xffffffffe9a8</span> <span class="hljs-comment">// 比Midobject高8个字节，是因为减去了虚函数的指向</span><br>(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">int</span> *) &amp;midObj<br>$<span class="hljs-number">8</span> = (<span class="hljs-type">int</span> *) <span class="hljs-number">0xffffffffe9a0</span><br>(gdb) <span class="hljs-built_in">p</span> (<span class="hljs-type">void</span> *) &amp;midObj<br>$<span class="hljs-number">9</span> = (<span class="hljs-type">void</span> *) <span class="hljs-number">0xffffffffe9a0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>深度探索C++对象模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-02</title>
    <link href="/posts/1979324518/"/>
    <url>/posts/1979324518/</url>
    
    <content type="html"><![CDATA[<p>本文是LeetCode刷题记录的第二批</p><span id="more"></span><h1 id="最小栈"><a href="https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>155. 最小栈</strong></a></h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p>解答：此题是模拟题，不难，主要在于思路的打开。想明白成员变量的设计，此题就迎刃而解。</p><p>仍然使用<code>stack</code>作为底层的存储结构，只是成员变量用<code>pari&lt;int, int&gt;</code>，其中<code>first</code>为<code>value</code>， <code>second</code>为目前的最小值。</p><p>如此往栈中新加入数据时，只需要使用<code>geMin()</code>与当前的值取最小值，作为新加入数据的最小值即可。</p><p>在初始化栈时，需要额外<code>(0, INT_MAX)</code>作为初始值，如此在后续添加数据时可以直接使用<code>getMin()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        min_st.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, INT_MAX&#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        min_st.<span class="hljs-built_in">push</span>(&#123;val, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">getMin</span>(), val)&#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        min_st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_st.<span class="hljs-built_in">top</span>().first;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_st.<span class="hljs-built_in">top</span>().second;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; min_st;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此题中用到了make_pair，关于其用法如下：</p><table><thead><tr class="header"><th><strong>方法</strong></th><th><strong>示例</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr class="odd"><td><code>std::make_pair</code></td><td><code>auto p = std::make_pair(1, 2);</code></td><td>最简洁、推荐</td></tr><tr class="even"><td>直接构造 <code>pair</code></td><td><code>std::pair&lt;int, int&gt; p(1, 2);</code></td><td>明确创建对象</td></tr><tr class="odd"><td>列表初始化</td><td><code>std::pair&lt;int, int&gt; p&#123;1, 2&#125;;</code></td><td>C++11特性</td></tr><tr class="even"><td>复制构造</td><td><code>auto p = std::pair&lt;int, int&gt;(1, 2);</code></td><td>也可以用，效果一样</td></tr></tbody></table><ul><li>通常建议用 <code>std::make_pair()</code>，因为它可以自动推导类型。</li><li>如果明确类型，直接用构造函数也很好。</li></ul><p>对于<code>pair</code>和<code>make_pair</code>的解析如下：</p><p><code>std::make_pair</code>实际上是一个模板函数，而<code>pair</code>是一个模板类。</p><p>具体来说：</p><p><strong><code>std::pair</code> 是一个模板类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    T1 first;<br>    T2 second;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以用它来定义不同类型的pair，比如：</p><p><code>std::pair&lt;int, int&gt; p1(1, 2);  std::pair&lt;std::string, double&gt; p2("hello", 3.14);</code></p><p><code>std::make_pair</code> 是一个模板函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function">std::pair&lt;T1, T2&gt; <span class="hljs-title">make_pair</span><span class="hljs-params">(T1 t, T2 u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pair</span>&lt;T1, T2&gt;(t, u);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>模板参数：<code>T1</code> 和 <code>T2</code> <strong>根据传入的参数自动推导</strong>。</li><li>返回值：<code>pair&lt;T1, T2&gt;</code>。</li></ul><h1 id="powx-n"><a href="https://leetcode.cn/problems/powx-n/description/"><strong>50. Pow(x, n)</strong></a></h1><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p><p>解答：</p><ol type="1"><li>使用库函数，直接调用<code>pow(x,n)</code> 显然不合题意</li><li>使用暴力循环，直接循环n次，求得最后结果，显然也不合题意</li><li>使用分治的方法</li></ol><p>为什么采用分治的方法？常规来讲，对<code>n</code>个<code>x</code>求积，可以先求出<code>n/2</code>个<code>x</code>的积，然后再想乘。同理，对于<code>n/2</code>个<code>x</code>的积，可以先求出<code>n/4</code>个<code>x</code>的积，然后再想乘。直到最终<code>n</code>为0时，是已经到达了递归的最深层，此时，梦改醒了。</p><p>在求<code>n</code>个<code>x</code>的积时，由于不知道<code>n</code>的奇偶性，因此开始需要分类讨论。如果是奇数，则需要额外再乘个<code>x</code>，当进入第二层后，就会确定一直是偶数了，不会再走到奇数的分支。</p><ol type="1"><li>如果<code>n</code>是负数，需要求其倒数，注意<code>n</code>要<strong>取反</strong></li><li>如果<code>n</code>是奇数，第一步就将其转成偶数</li><li>如果n是偶数，则需要计算 <code>x*x</code> 的 <code>n/2</code>次方</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / <span class="hljs-built_in">pow</span>(x, -n);<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">myPow</span>(x, n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">myPow</span>(x * x , n / <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上是采用递归+分治的方法去做，也可以直接去做，结合位运算，以下是整体思路。</p><ol type="1"><li>针对负数做特殊处理</li><li>在循环中获取最后的结果值pow</li><li>如果n是奇数，多乘x，这个在每轮循环中都有可能出现。</li><li>否则直接求得x的平方，n右移两位。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>            x = <span class="hljs-number">1</span> / x;<br>            n = -n;<br>        &#125;<br>        <span class="hljs-type">int</span> pow = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>                pow = x * pow;<br>            &#125;<br>            x *= x;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> pow;   <br>    &#125;<br>&#125;；<br></code></pre></td></tr></table></figure><h1 id="最长连续序列"><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>128. 最长连续序列</strong></a></h1><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> **的算法解决此问题。</p><ol type="1"><li>排序后求解，时间复杂度不合题意</li><li>核心思想，如果在遍历<code>x</code>的时候，发现<code>x-1</code>也在数组里面，那么一定不会以<code>x</code>为起点，至少应该以<code>x-1</code>为起点。</li><li>如果找到了<code>x</code>，其是当前序列最小的，需要循环去遍历<code>x+1</code>是否存在，求得以<code>x</code>开始的序列的长度。</li><li>数组需要去重，因此需要将其放在<code>set</code>里面，然后去<strong>遍历<code>set</code></strong>求解。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">unordered_set <span class="hljs-title">st</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : st) &#123;<br>            <span class="hljs-comment">// 如果i - 1 存在，则一定不用从i -1 开始遍历</span><br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> tmp = num + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">count</span>(tmp)) &#123;<br>                tmp++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, tmp - num);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另外，其中对于容器的遍历，请用现代C++推荐的<code>based_for</code>形式，无论是关系型容器还是序列性容器，如果只是提取元素，建议<code>for (const auto&amp; val : vec) &#123; /* 访问val */ &#125;</code></p><h1 id="岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>200. 岛屿数量</strong></a></h1><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>对于图的遍历，要求掌握DFS和BFS两种算法，此题由于陆地是连续的，因此要使用DFS遍历。</p><p>使用DFS遍历图时，要注意边界条件，边界条件是递归的出口。</p><p>此题中应该是</p><ol type="1"><li>不超过矩阵的范围</li><li>还没有被填充（假设填充时将此块置2）</li></ol><p>所以DFS的算法应该这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>(), col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= row || j &lt; <span class="hljs-number">0</span> || j &gt;=  col || grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j);<br>            <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, j);<br>            <span class="hljs-built_in">dfs</span>(i, j - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">dfs</span>(i, j + <span class="hljs-number">1</span>);<br>        &#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-built_in">dfs</span>(i, j);<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此题的难点主要在于养成图算法的思路，如果遍历整个图？如何写DFS等？</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础能力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板元编程</title>
    <link href="/posts/2756375431/"/>
    <url>/posts/2756375431/</url>
    
    <content type="html"><![CDATA[<h2 id="模板元编程">模板元编程</h2><p>本节是对B站课程的记录<a href="https://www.bilibili.com/video/BV1FLAAe3E7r/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=e0aee50f101b406f0d1414f984f3f5c0">来源</a>，主要是对特化进行介绍~ <span id="more"></span></p><p>keywords: 模板，偏特化，全特化，可变参数模板</p><p>练手：实现一个可变参数的日志打印算子，对于不同的参数调用不同的类 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;General log &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;T*&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T* p_value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Pointer log &quot;</span> &lt;&lt; *p_value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;<span class="hljs-type">double</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; d_value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Double log &quot;</span> &lt;&lt; d_value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>&lt;T&amp;&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Reference log &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logone</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>    Logger&lt;T&gt;::<span class="hljs-built_in">log</span>(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAll</span><span class="hljs-params">(<span class="hljs-type">const</span> Args&amp;... args)</span> </span>&#123;<br>    (<span class="hljs-built_in">logone</span>(args),...);<br>&#125;<br><br>---<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-number">10.00</span>;<br>log21::<span class="hljs-built_in">logAll</span>(a, &amp;a, b, &amp;b);<br><br>General log <span class="hljs-number">10</span><br>Pointer log <span class="hljs-number">10</span><br>Double log <span class="hljs-number">10</span><br>Pointer log <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>模板编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见设计类</title>
    <link href="/posts/309135859/"/>
    <url>/posts/309135859/</url>
    
    <content type="html"><![CDATA[<p>本文是对面试题目中常见的手撸算法的总结与汇总…</p><span id="more"></span><h2 id="实现一个string类">实现一个string类</h2><ul><li>牢记5大件：复制构造函数，移动构造函数，赋值运算符，移动赋值运算符，析构函数。</li><li>成员变量： <code>char *</code> 指针， <code>int len</code> ,要注意申请空间时+1，因为有个默认的换行符</li><li>移动构造函数&amp;移动赋值运算符可以加上 <code>noexpect</code> ，因为移动构造函数不会出现异常</li><li>在移动**函数中，把源对象的指针置空。</li><li>在赋值运算符和赋值构造函数中，const不能去掉，因为const T&amp;即可以接受左值又可以接受右值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mystring</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mystring</span>() : <span class="hljs-built_in">m_arr</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">m_len</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Mystring</span>(<span class="hljs-type">const</span> Mystring&amp; str) : <span class="hljs-built_in">m_len</span>(str.m_len) &#123;<br>        <span class="hljs-keyword">if</span> (m_len != <span class="hljs-number">0</span>) &#123;<br>            m_arr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_len + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">memcpy</span>(m_arr, str.m_arr, m_len + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m_arr = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">Mystring</span>(Mystring&amp;&amp; str) <span class="hljs-keyword">noexcept</span>: <span class="hljs-built_in">m_arr</span>(str.m_arr), <span class="hljs-built_in">m_len</span>(str.m_len)&#123;<br>        str.m_arr = <span class="hljs-literal">nullptr</span>;<br>        str.m_len = <span class="hljs-number">0</span>;<br>    &#125;<br>    Mystring&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Mystring&amp; str) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span>* new_arr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_len + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">memcpy</span>(new_arr, str.m_arr, str.m_len + <span class="hljs-number">1</span>);<br>            m_arr = new_arr;<br>            m_len = str.m_len;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    Mystring&amp; <span class="hljs-keyword">operator</span>=(Mystring&amp;&amp; str) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">delete</span>[] m_arr;<br>            m_arr = str.m_arr;<br>            m_len = str.m_len;<br>            str.m_arr = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Mystring</span>() &#123;<br>        <span class="hljs-keyword">if</span> (m_arr) &#123;<br>            <span class="hljs-keyword">delete</span>[] m_arr;<br>            m_len = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_arr;<br>    <span class="hljs-type">size_t</span> m_len;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="lru-算法">LRU 算法</h2><p>LRU算法关键在于数据结构的设计。1)链表用<code>list&lt;pair(int ,int)&gt;</code>来记录 2)为方便快速查找，可以用map&lt;int, <code>list&lt;pair(int, int)&gt;::iterator</code>&gt;来记录 1. 当队列满的时候，清楚完需要添加新的元素进行，注意不用用到了<strong>旧key</strong> 2. 然后尽量用<code>make_pair(key, value)</code>来构造数据 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">m_capacity</span>(capacity) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_mp.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> iter = m_mp[key]; <span class="hljs-comment">// 值拷贝替代引用</span><br>            <span class="hljs-type">int</span> value = iter-&gt;second;<br>            m_list.<span class="hljs-built_in">erase</span>(iter);<br>            m_list.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>            m_mp[key] = m_list.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_mp.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> iter = m_mp[key]; <span class="hljs-comment">// 值拷贝替代引用</span><br>            m_list.<span class="hljs-built_in">erase</span>(iter);<br>            m_list.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>            m_mp[key] = m_list.<span class="hljs-built_in">begin</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (m_mp.<span class="hljs-built_in">size</span>() &gt;= m_capacity) &#123;<br>                <span class="hljs-type">int</span> old_key = m_list.<span class="hljs-built_in">back</span>().first; <span class="hljs-comment">// 修复键覆盖问题</span><br>                m_list.<span class="hljs-built_in">pop_back</span>();<br>                m_mp.<span class="hljs-built_in">erase</span>(old_key);<br>            &#125;<br>            m_list.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>            m_mp[key] = m_list.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_capacity;<br>    std::list&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; m_list;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::list&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; m_mp;<br>&#125;;<br></code></pre></td></tr></table></figure> <strong>重要</strong></p><ol type="1"><li>对于关联式容器，尽量不要使用引用，因为引用很有可能导致引用悬挂的风险和迭代器失效的我问题(比如当底层若其扩容时)</li><li>对于C++11提供了初始化列表的语法，所以对于make_pair(key, value)可以简单的写成{key,value}。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-01</title>
    <link href="/posts/3975367132/"/>
    <url>/posts/3975367132/</url>
    
    <content type="html"><![CDATA[<p>本文是LeetCode刷题记录的第一批 <span id="more"></span></p><h1 id="区域和检索---数组不可变"><a href="https://leetcode.cn/problems/range-sum-query-immutable/"><strong>303. 区域和检索 - 数组不可变</strong></a></h1><p>题目描述：给个数组，给个区间，求<code>[left, right]</code>的和。</p><p>解题思路：</p><p>用前缀和，前缀和定义为<code>s[i] = num[0] + …… + num[i - 1]，s[j] = num[0] + …… + num[i - 1] + num[i] + …… + num[j - 1]</code>。那么从<code>i→j</code>的和是<code>num[i] + …… + num[j] = s[j + 1] - s[i]</code></p><p>在上述背景下，s[0] = 0，为什么这么定义呢？</p><ol type="1"><li>考虑边界条件，如果left为0，直接-s[0]就可以了，否则还需要考虑left=0的情况。</li><li>假设定义<code>s[i] = num[0] + …… + num[i]</code>, <code>s[j] = num[0] + …… + num[i] + num[i + 1] + …… num[j]</code>，那么[i,j] = s[j] - s[i-1]。 此时要求<code>i &gt;= 1</code>，对于i为0的情况，需要单独考虑。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        m_sum.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        m_sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            m_sum[i] += m_sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_sum[right + <span class="hljs-number">1</span>] - m_sum[left];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; m_sum; <br>&#125;;<br></code></pre></td></tr></table></figure><p>总结：</p><ol type="1"><li>对于前缀和，要考虑<code>s[0]</code>的情况，一般设置<code>s[0]=0</code>，那么<code>[i-j]</code>的和可以写成<code>s[i + 1] - s[j]</code>。</li></ol><h1 id="和为k的子数组"><a href="https://leetcode.cn/problems/subarray-sum-equals-k/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>560. 和为k的子数组</strong></a></h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 *该数组中和为 <code>k</code> 的子数组的个数。</p><p>子数组是数组中元素的连续非空序列。</p><p>此题适合用前缀和的方式去解答，首先前缀和的基本思路是定义<code>s[0] = 0</code>, <code>sum[i] = sum[i - 1] + nums[i - 1]</code></p><p>计算和为k的连续子数组，计算方法是只要数组中任意两个数之间的差值是k，就是满足题意的。</p><p>前缀和得出后如何求数组中和为<code>k</code>的子数组的个数呢？</p><p>从左到右遍历前缀和数组，如果右边的某位-左边的某位=k，则满足题意。但是如果直接按照这种方式模拟，又是暴力求解。</p><p>所以此时用一个hash表去记录，从左到右查找，直接加上目标元素的<code>value</code>值。然后把当前的元素值放在map表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            sum[i + <span class="hljs-number">1</span>] = sum[i] + nums[i];<br>        &#125;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; sum_cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> value : sum) &#123;<br>            <span class="hljs-keyword">if</span> (sum_cnt.<span class="hljs-built_in">count</span>(value - k) != <span class="hljs-number">0</span>) &#123;<br>                res += sum_cnt[value - k];<br>            &#125;<br>            sum_cnt[value]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>239. 滑动窗口最大值</strong></a></h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> **的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><hr /><p>此题在难度为hard，并没有思路。题解描述为使用双端队列来做，队列是单调的，队首对应的元素一直是组大的。然后队列的大小没必要是滑动窗口的大小。因为要保证队列元素有序，所以双端队列的大小是小于滑动窗口的大小的。</p><p>有一个比较有意思的记忆方法：公司的人数有k，数组的下标对应的是员工的年龄，数组的值对应的是员工的能力。</p><ol type="1"><li>如果当前员工比公司最差的员工的还差，则不让他进公司</li><li>如果当前员工进入了公司，就要把最差的踢出去。</li><li>团队最厉害的人到了年纪，也必须要踢出去。</li></ol><p>由于进公司有一定的标准，所以其是个单调栈，所以一定会保证栈中元素顺序。</p><p>其中，单调栈是指双端队列中的数据是有序的，到底是&lt;还是≤是无所谓的，因为决定滑动窗口大小的是i和队首的大小。</p><p>为什么最后一个循环一定是满足题意的，考虑一下最后的结果，就是从刚开始第一个窗口处开始，每次加一个元素，都会有一个结果加入的res中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 滑动窗口，求窗口内的最大值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">reserve</span>(nums.<span class="hljs-built_in">size</span>());<br>        deque&lt;<span class="hljs-type">int</span>&gt; qu;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">// 维护单调栈，此处是&lt;还是&lt;=</span><br>            <span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[qu.<span class="hljs-built_in">back</span>()] &lt; nums[i]) &#123;<br>                qu.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            qu.<span class="hljs-built_in">push_back</span>(i);<br><br>            <span class="hljs-keyword">if</span> (i - qu.<span class="hljs-built_in">front</span>() &gt;= k) &#123;<br>                qu.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-comment">// 每次走到这，一定是满足题意了，除了第一次还没形成过一个窗口</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(nums[qu.<span class="hljs-built_in">front</span>()]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="螺旋矩阵"><a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>54. 螺旋矩阵</strong></a></h1><blockquote><p>本题是个模拟题，还是有难度的，因为相对来说比较绕</p></blockquote><p>螺旋矩阵用肉眼观察是比较好得出结论，但是用程序模拟还是需要费点功夫。</p><p>方法: 定义上下左右的边界，都是闭区间的。然后上下，或者左右边界不符合条件时，就要跳出循环</p><ol type="1"><li><p>————-&gt; 遍历条件是从最左边到最右边，遍历完后，这一行就没了，所以upper要+1,加1完之后要判断和down的关系决定是否要推出</p></li><li><p>遍历条件是从upper-&gt;down，在最右边，遍历完后，–right,减一之后还要判断和left的关系，决定是否要推出循环。 <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br><span class="hljs-string">|</span><br>V<br></code></pre></td></tr></table></figure></p></li><li><p>遍历条件是从right到left<code>&lt;------------</code>，遍历完之后，down要减一，减一之后要和upper进行比对，判断。</p></li><li><p>遍历条件是从down到upper，遍历完之后，left要+1。加1之后再进行比对判断。</p></li></ol><h1 id="旋转矩阵"><a href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>48. 旋转矩阵</strong></a></h1><blockquote><p>矩阵的题目对我来说都有点难度，因为对模拟的要求比较高</p></blockquote><p>此题还算比较简单,因为只涉及到了两次交换,第一次是对称交换,对称交开始也没有写对，第二次循环应该是基于第一层循环来做。 <code>for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; i; ++j)&#125;</code>,在循环体内要，j&lt;i 才是对的。</p><h1 id="搜索二维矩阵-ii"><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>240. 搜索二维矩阵 II</strong></a></h1><p>在一个排列有序的二维矩阵中搜索想要的字符是需要点技术的，不能从最小开始搜索，也不能从最大开始搜索。原因是如果从最小开始搜索 不符合条件有两个去处，那么此时就得再进行判断。也不能从最大开始搜索，原因是从最大开始搜索后，不满足题意也要从两个方向开始改动</p><p>因此需要找个不大不小的，所有要么是左上角，要么是右小角：</p><p>左上角： 相等则返回， 大于则排除一行，小于则排除一列，逐步往里缩小</p><p>右小角： 相等则返回，大于则排序一列，小于则排序最下面一行，逐步往里缩小</p><h1 id="数组中的第k个最大元素"><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>215. 数组中的第K个最大元素</strong></a></h1><p>[题目描述]：数组无序，有可能重复，求排序完后第K大的元素。要求：时间复杂度O(n)</p><p>解答：</p><ol type="1"><li>排序完后获取第K大的元素，时间复杂度不符合要求。</li><li>用优先队列，时间复杂度为<code>O(NlogK)</code>，不合题意</li><li>使用快排，时间复杂度平均情况下是<code>O(N)</code>,最坏的情况下可能达<code>O(N^2)</code></li></ol><p>因此此处采用快排的方式求解。快排是一个递归的过程，每次都要找到当前元素应该在的位置，即该位置左边的元素都大于等于此元素，右边的元素都小于等与此元素。至于该元素左边和右边的元素整体的顺序不做要求，比如有元素[4,10,3,4,5,6]，在经历了一次快排后，要求第一个元素4需要在其应该在的位置上。</p><p>一次快排的具体步骤：</p><ol type="1"><li>随机选取一个位置，也可以选择第一个，要求结束此次快排时，目标元素在其应该在的位置。</li><li>开始找目标元素的位置。<ol type="1"><li>从第二个元素到最后一个元素之间寻找</li><li>如果left所指向的元素大于等于目标元素，则不应该动left所指向的元素，我们最后的目标就是大于等于目标元素的元素在左边。</li><li>如果left所指向的元素小于等于目标元素，则也不应该动right所指向的元素，理由同上。</li><li>最终left所指的元素是第一个小于目标元素的元素，或者是数组的最后一个位置，此时left的位置是无效的。</li><li>最终right所指的元素是第一个大于目标元素的元素，或者是指向第一个元素，此时right的位置是有效的。</li></ol></li><li>当跳出循环时，一定是l &gt; r，因为这是循环终止的条件，由于right是第一个大于目标元素的位置，所以目标元素可以与right进行交换，可以保证左变的元素都大于等于目标元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = left;<br>    <span class="hljs-type">int</span> l = left + <span class="hljs-number">1</span>, r = right;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[l] &gt;= nums[pivot]) l++;<br>        <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[r] &lt;= nums[pivot]) r--; <br>        <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[l], nums[r]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums[pivot], nums[r]);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>把所有过程串联起来</p><ol type="1"><li>首选需要不断的寻找，直到找到最后正确的位置。</li><li>如果位置比目标位置小，说明需要向右边找</li><li>如果位置比目标位置大，说明需要向左边找</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">Partition</span>(nums, l, r);<br>        <span class="hljs-keyword">if</span> (pos == k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[pos];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pos &lt; k - <span class="hljs-number">1</span>) l = pos + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = pos - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="字符串解码"><a href="https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&amp;envId=top-100-liked"><strong>394. 字符串解码</strong></a></h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p>思路：</p><p>本题的本质是将字符串用分配率展开，比如如<code>3[a2[c]b]</code> 使用一次分配律-&gt; <code>3[accb]</code> 再使用一次分配律-&gt;<code>accbaccbaccb</code></p><p>需要使用<strong>双栈结构</strong>来处理<strong>嵌套字符串</strong>重复模式。有<strong>字符串栈</strong>和<strong>数字栈</strong>两个</p><ul><li>数字栈用来存储每个 <strong><code>k[encoded_string]</code></strong> 结构中的重复次数 <strong><code>k</code></strong></li><li>字符串栈用来存储每个 <strong><code>k[encoded_string]</code></strong> 结构<strong>之前</strong>已经解码的字符串部分</li></ul><p>整个算法过程类似一个状态机的转换，根据不同的情况做不同的操作</p><p>遍历字符串，总共有以下几种可能：</p><ol type="1"><li>数字<ol type="1"><li>用num记录当前数字，因为有可能是十位数或者百位数，所以为 <code>num = num * 10 + (s[i] - '0');</code></li></ol></li><li>字符<ol type="1"><li>用res记录当前的字符状态，如果是字符则拼接在后面。</li></ol></li><li>左括号<ol type="1"><li>碰到左括号时，前面一定会有数字和已经解码的字符串，如果左括号前就是数字，则默认解码的字符串为空</li><li>此时的数字代表着下一次要重复的字符串的次数，字符串代表的<code>pre_str</code>，后续要<code>pre_str +</code></li><li>碰到左括号时，状态机要置空，接下来是单独的一层，<code>res</code>和<code>num</code>都置空</li></ol></li><li>右括号<ol type="1"><li>碰到右括号，说明需要展开了</li><li>把当前的字符串 *数字栈顶元素，这个是[]里面的处理逻辑，<code>res</code>代表的内层字符串，<code>str_top()</code>代表的外层字符串</li><li>字符串栈顶 + b的结果</li><li>记录当前字符串的情况</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; nums_st;<br>        stack&lt;string&gt; str_st;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        string res&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp;  s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>                res += s[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                nums_st.<span class="hljs-built_in">push</span>(num);<br>                str_st.<span class="hljs-built_in">push</span>(res);<br>                num = <span class="hljs-number">0</span>;<br>                res = <span class="hljs-string">&quot;&quot;</span>; <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> time = nums_st.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; time; ++i) &#123;<br>                    str_st.<span class="hljs-built_in">top</span>() += res;<br>                &#125;<br>                res = str_st.<span class="hljs-built_in">top</span>();<br>                nums_st.<span class="hljs-built_in">pop</span>();<br>                str_st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前-k-个高频元素"><a href="https://leetcode.cn/problems/top-k-frequent-elements/"><strong>347. 前 K 个高频元素</strong></a></h1><p>常规模拟题</p><ol type="1"><li>会自定义大顶堆（默认less），小顶堆（great）的比较函数</li><li>priority_queue不能使用迭代器，只能通过pop的循环方法不断循环跳出。</li><li>自定义的lambda比较函数不能做为类的成员函数，由于是自定义的比较函数，因此可以出现在任何地方。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; key_cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : nums) &#123;<br>            key_cnt[num]++;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; rhs) &#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        &#125;;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; key_val : key_cnt) &#123;<br>            <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &lt; k) &#123;<br>                pq.<span class="hljs-built_in">push</span>(key_val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">auto</span>&amp; tmp = pq.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span> (tmp.second &lt; key_val.second) &#123;<br>                    pq.<span class="hljs-built_in">pop</span>();<br>                    pq.<span class="hljs-built_in">push</span>(key_val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">reserve</span>(k);<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="接雨水"><a href="https://leetcode.cn/problems/trapping-rain-water/"><strong>42. 接雨水</strong></a></h1><p>方法一：单调栈</p><p>想想不是接雨水，而是填水泥。水泥会把坑填平，当水泥把坑填平时，高度就不变了。</p><p>需要<strong>左（栈顶元素的下一个元素）右（当前元素）</strong>以及<strong>中间柱子（栈顶元素）</strong>的高度才能计算得到最终的结果。</p><p><img src="../pictures/729image.png" alt="image.png" /> 思路：</p><ol type="1"><li>从左到右遍历数组</li><li>如果栈不为空，并且栈顶元素大于等于当前元素，则可以接水了，栈顶元素就是中间的柱子。如果当前元素小于栈顶元素，则需要继续遍历</li><li>将中间的柱子pop出栈，如果此时栈为空，则break</li><li>否则则再次取栈顶元素，此时只用栈顶元素，求栈顶元素与当前元素的位置之差作为宽，高是两边柱子的较小值减去中间元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt;= height[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-type">int</span> bottom_h = height[st.<span class="hljs-built_in">top</span>()];<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) <br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> lens = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> hei = (<span class="hljs-built_in">min</span>(height[i], height[st.<span class="hljs-built_in">top</span>()]) - bottom_h);<br>                res += lens * hei;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="每日温度"><a href="https://leetcode.cn/problems/daily-temperatures/description/"><strong>739. 每日温度</strong></a></h1><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>参考<a href="https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=e0aee50f101b406f0d1414f984f3f5c0">灵神</a>的解答</p><p>方法一：右往左遍历</p><figure><img src="./pictures/729image.png" alt="" /><figcaption>image.png</figcaption></figure><p>当遍历到5时，由于2比5小，所以2排除，3比5小，3也排除，6比5大，所以应该是6的下标减去5的下标得到目标答案。</p><p>既然在遍历到5时，把2和3排除掉了，那么2和3还有可能是5左边的元素的目标答案，显然不可能，由于5的存在，5左边的元素不会选择2和3作为比其大的天气的温度。</p><ul><li>栈中顺序有序</li><li>满足先近后出</li></ul><p>因此是此题用单调栈。</p><p>栈中元素保证严格递减，栈中存放的是下一个更大的数。</p><p>在此题中，栈中存储的应该是数组的下标，存储数组下标的好处一是可以直接用下标相减得到目标答案。二也可以通过下标的比较获得元素的大小。</p><ol type="1"><li>从右向左遍历</li><li>当栈顶元素<strong>小于等于</strong>当前当前元素时，需要将元素pop出来，最后跳出循环时，栈顶元素一定是大于当前元素的。</li><li>由于栈顶元素是大于当前元素的，所以将当前元素压榨是可以保证栈的单调性的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = temperatures.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[st.<span class="hljs-built_in">top</span>()] &lt;= temperatures[i]) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>                res[i] = st.<span class="hljs-built_in">top</span>() - i;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二：从左到右遍历</p><p>从左到右遍历，栈中存储的元素是<strong>还没找到第一个大于它的元素</strong>，如果找到了，就将其pop出来。</p><ol type="1"><li>如果当前元素大于栈顶元素了，则需要更新栈顶元素的结果值。这里需要不断循环，直到栈顶元素小于等于当前元素，</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="hljs-built_in">top</span>()]) &#123;<br>                res[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><aside><p>💡</p><p>及时去除无用数据</p><p>保证栈中数据有序</p></aside>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>基础能力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法笔记</title>
    <link href="/posts/2063046854/"/>
    <url>/posts/2063046854/</url>
    
    <content type="html"><![CDATA[<p>本文是在学习数据结构与算法的记录于思考，包括但不限于LeetCode，算法笔记，算法思想的记录…… <span id="more"></span></p><h1 id="数据结构与算法之美">数据结构与算法之美</h1><h2 id="递归分治">递归&amp;分治</h2><p>递归：</p><p>递归的本质就是循环，只是与我们传统理解的<code>for</code>，<code>while</code>不同，其是用函数来进行循环。递归的实现和盗梦空间里的场景非常类似，可以在梦里再进入梦境，但是总归有梦醒的时候。所以之前的故事，从前有座山，山里有座庙，庙里有个和尚讲故事……，这是个死递归，因为没有递归返回的时候。</p><p>因此我们在编写递归程序的时候，一定要避免这种情况，一定要有递归跳出的时候。所以递归的模板总结如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  level 表示当前进入了递归的哪一层</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recuresion</span>(<span class="hljs-params">level, param1, param2, ...</span>)<br>    <span class="hljs-keyword">if</span> level &gt; MAX_LEVEL<br>        print_result()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-comment"># 当前层处理逻辑</span><br>    process_data(level, data...)<br>    <span class="hljs-comment"># 进入下一层</span><br>    <span class="hljs-variable language_">self</span>.recuresion(level + <span class="hljs-number">1</span>, p1, ...)<br><br>    <span class="hljs-comment"># 当前层如果需要一下后置处理</span><br>    reverse_state(level)<br></code></pre></td></tr></table></figure><p>分治：</p><p>分治需要将大问题分割成小问题，然后依次处理各个小问题，最后合并。思想比较简单，但是实现起来就没那么简单了，算法模板如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide_conquer</span>(<span class="hljs-params">problem, param1, param2, ...</span>)<br>    <span class="hljs-keyword">if</span> problem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        print_result()<br>        <span class="hljs-keyword">return</span><br>    <br>    data = process_data(problem)<br>    subproblems = spilt_problem(problem, data)<br><br>    subresult1 = <span class="hljs-variable language_">self</span>.divide_conquer(subproblems[<span class="hljs-number">0</span>], p1, p2, ...)<br>    subresult2 = <span class="hljs-variable language_">self</span>.divide_conquer(subproblems[<span class="hljs-number">1</span>], p1, p2, ...)<br>    subresult3 = <span class="hljs-variable language_">self</span>.divide_conquer(subproblems[<span class="hljs-number">2</span>], p1, p2, ...)<br>    <span class="hljs-comment"># ...</span><br><br>    result = process_result(subresult1, subresult2, subresult3, ...)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/posts/4049607742/"/>
    <url>/posts/4049607742/</url>
    
    <content type="html"><![CDATA[<p>单例模式是指整个程序（<strong>进程</strong>）中只有一个实例，这可以为程序提供一个<strong>唯一的全局控制点</strong> <span id="more"></span> 其目的主要在于控制实例的数量，提供全局唯一控制点，以及延迟实例化等。</p><p>在第一版中，只提供了简单的实现形式，还有指针，只能指针，递归奇异模式，将会在后续的版本中讲述。</p><p>通常用于如日志记录器或者线程池等类似的全局只需要有一个实例的场景下。其通常有饿汉式和懒汉式两种，这两种最本质的区别在于实例是什么时候创建的。即在<code>GetInstance</code>时是否已经创建了</p><ol type="1"><li>饿汉式是在程序开始时就创建，而不管后续在程序的运行过程中是否使用它。</li><li>懒汉式只在程序必须要创建的时候才创建，通常在调用 <code>GetInstance</code> 时才会创建。</li></ol><p>其优缺点到此显而易见，一个是资源利用效率，明显懒汉式要高，那懒汉式的缺点在于程序可能存在并发的问题（在C++11）中也解决了，C++11中保证了<code>static</code>变量的线程安全。</p><h1 id="懒汉式">懒汉式</h1><p>懒汉式的核心在于真正调用的时候才去创建这个实例。所以只需要在GetInstance中声明一个，并返回就可以。</p><p>需要主要的是，为防止实例被拷贝和赋值，应该将其赋值运算符和拷贝构造函数都声明为<code>delete</code>，然后默认构造函数要么由编译器提供，要么是由程序员自己提供。</p><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton1</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton1</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton1</span>(<span class="hljs-type">const</span> Singleton1&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton1&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton1&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Singleton1</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Singleton1 destructed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton1&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 在getInstance内创建的，属于懒汉式</span><br>        <span class="hljs-type">static</span> Singleton1 obj;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        Singleton1::getInstance();</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;singleton1 add is &quot;</span> &lt;&lt; &amp;Singleton1::getInstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        Singleton1::getInstance();</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;singleton2 add is &quot;</span> &lt;&lt; &amp;Singleton1::getInstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 输出</span><br>singleton2 add is <span class="hljs-number">0x5587e7cf6151</span><br>singleton1 add is <span class="hljs-number">0x5587e7cf6151</span><br>Singleton1 destructed<br></code></pre></td></tr></table></figure><p>以上用<code>static</code>实现的懒汉式的单例模式，在多线程下是线程安全的，因为C++11保证了<code>static</code>的变量在多线程访问下的线程安全性。</p><hr /><p>以上是最经典，也是最简单的写法。可以将其变成指针的形式，指针的形式是非线程安全的，需要</p><h1 id="饿汉式">饿汉式</h1><p>饿汉式和懒汉式的区别在于变量的初始化时间，如果是在getInstance里初始化和声明的，则一定是懒汉式，如果不在，则一定是饿汉式，饿汉式一定是线程安全的，因为其初始化是在程序开始之前，这时候还没有加载其他的线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton2</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton2</span>(<span class="hljs-type">const</span> Singleton2&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton2&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton2&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">static</span> Singleton2 instance;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Singleton2</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Singleton2 destructed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton2&amp; <span class="hljs-title">getinstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Singleton2 Singleton2::instance;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;singleton2 add is &quot;</span> &lt;&lt; &amp;Singleton2::getinstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t4</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;singletion add is &quot;</span> &lt;&lt; &amp;Singleton2::getinstance() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br>t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br>t<span class="hljs-number">4.</span><span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">singleton2 add is <span class="hljs-number">0x55b795618151</span>singletion add is <br><span class="hljs-number">0x55b795618151</span><br>Singleton2 destructed<br></code></pre></td></tr></table></figure><p>虽然输出结果是乱序的，但是也能说明两个线程是打印的是一个实例，说明其是线程安全的。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何像高手一样阅读源码</title>
    <link href="/posts/2390246322/"/>
    <url>/posts/2390246322/</url>
    
    <content type="html"><![CDATA[<p>今天看了<a href="https://www.bilibili.com/video/BV1xgAteDE9d/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=e0aee50f101b406f0d1414f984f3f5c0">B站上的课程</a>讲如何阅读源码，觉得挺适合现在的我。 <span id="more"></span> 视频中从三个方面讲述如何阅读一个大型的代码库，分别是<strong>心理</strong>,<strong>哲学</strong>,<strong>技术</strong>三个方面</p><h1 id="心理">心理</h1><ol type="1"><li><p>要勇敢，不要害怕去读代码</p></li><li><p>疑惑没有关系，要愿意去疑惑，如果有疑惑的话可以先跳过去。</p></li><li><p>要从多方面去考虑一个事情呢</p></li><li><p>要知道你明白了什么，不明白什么，要诚实。</p></li></ol><h1 id="哲学">哲学</h1><ol type="1"><li><p>知道大脑运作的方式，知道脑科学的</p></li><li><p>你要明白你想看啥，而不是一故脑的的去看代码，不明确要懂啥东西。</p></li><li><p>你在实操上熟悉比你真正理解要重要的多</p></li></ol><h1 id="技术">技术</h1><ol type="1"><li><p>知道数据结构和算法， 比如深度优先遍历等。</p></li><li><p>知道编程语言和编程技巧</p></li><li><p>在心里要有个思路如何去一一的探索代码。</p></li><li><p>在阅读代码的时候，要聚焦于程序员所写的东西，而不是程序运行时的顺序。</p></li></ol><hr /><p>因此在后续阅读代码中</p><p>不要畏难，要大胆看，遇到不懂的也没关系，可以先跳过，不用拘谨于细节。读代码的时候，没必要从main函数开始看，因为这个时候很多都是程序加载所需要的东西，比如配置文件之类的，或者是根据不同的参数去走不同的通路，亦或者是根据平台的不同选择不同的方式，这些都不重要。</p><p>开始读之前一定要有个清晰的目标，我要看什么？比如我要看统排或者是扶持，亦或者是LSM tree中的某个细节，就针对细节去看。</p><p>其次就是coding，你真正的理解，真不如写上的熟悉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
